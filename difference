diff -y ./src/AlkaliAtoms_parameters.f90 ../../Downloads/MultimodeFloquet-0.3/src/AlkaliAtoms_parameters.f90

MODULE ATOMIC_PROPERTIES					MODULE ATOMIC_PROPERTIES
  USE physical_constants					  USE physical_constants
  IMPLICIT NONE							  IMPLICIT NONE
  ! Parameters values by default				  ! Parameters values by default
  DOUBLE PRECISION :: L = 0.0					  DOUBLE PRECISION :: L = 0.0
  DOUBLE PRECISION :: S = 0.5					  DOUBLE PRECISION :: S = 0.5
  DOUBLE PRECISION :: J,F,gf,mf  				  DOUBLE PRECISION :: J,F,gf,mf  
  DOUBLE PRECISION :: gF_2,gF_1,G_F				  DOUBLE PRECISION :: gF_2,gF_1,G_F
  INTEGER          :: Total_states_LSI				  INTEGER          :: Total_states_LSI
  INTEGER          :: Fup,Fdown					  INTEGER          :: Fup,Fdown
  DOUBLE PRECISION :: mass_at,Ftotal,I,g_I,g_J,A,a_s,alpha_E	  DOUBLE PRECISION :: mass_at,Ftotal,I,g_I,g_J,A,a_s,alpha_E
  CHARACTER(LEN=7) :: ID_name					  CHARACTER(LEN=7) :: ID_name
   								   
  !87Rb								  !87Rb
  DOUBLE PRECISION, PARAMETER :: mass_at_87Rb = 87*amu		  DOUBLE PRECISION, PARAMETER :: mass_at_87Rb = 87*amu
  DOUBLE PRECISION, PARAMETER :: Ftotal_87Rb  = 2.0		  DOUBLE PRECISION, PARAMETER :: Ftotal_87Rb  = 2.0
  DOUBLE PRECISION, PARAMETER :: J_87Rb       =  0.5  		  DOUBLE PRECISION, PARAMETER :: J_87Rb       =  0.5  
  DOUBLE PRECISION, PARAMETER :: I_87Rb       =  1.5  		  DOUBLE PRECISION, PARAMETER :: I_87Rb       =  1.5  
  DOUBLE PRECISION, PARAMETER :: g_J_87Rb     =  2.0		  DOUBLE PRECISION, PARAMETER :: g_J_87Rb     =  2.0
  DOUBLE PRECISION, PARAMETER :: g_I_87Rb     = -0.000995	  DOUBLE PRECISION, PARAMETER :: g_I_87Rb     = -0.000995
  DOUBLE PRECISION, PARAMETER :: A_87Rb       =  2*pi*hbar*3.	  DOUBLE PRECISION, PARAMETER :: A_87Rb       =  2*pi*hbar*3.
  DOUBLE PRECISION, PARAMETER :: a_s_87Rb     = 5.77E-9		  DOUBLE PRECISION, PARAMETER :: a_s_87Rb     = 5.77E-9
  DOUBLE PRECISION, PARAMETER :: alpha_E_87Rb = 2*pi*hbar*0.0	  DOUBLE PRECISION, PARAMETER :: alpha_E_87Rb = 2*pi*hbar*0.0
  INTEGER,          PARAMETER :: Fup_87Rb     =  2		  INTEGER,          PARAMETER :: Fup_87Rb     =  2
  INTEGER,          PARAMETER :: Fdown_87Rb   =  1		  INTEGER,          PARAMETER :: Fdown_87Rb   =  1
  CHARACTER(LEN=7) :: ID_name_87Rb = "87Rb"			  CHARACTER(LEN=7) :: ID_name_87Rb = "87Rb"
 								 
  !85Rb								  !85Rb
  DOUBLE PRECISION, PARAMETER :: mass_at_85Rb = 85*amu		  DOUBLE PRECISION, PARAMETER :: mass_at_85Rb = 85*amu
  DOUBLE PRECISION, PARAMETER :: Ftotal_85Rb  = 2.0		  DOUBLE PRECISION, PARAMETER :: Ftotal_85Rb  = 2.0
  DOUBLE PRECISION, PARAMETER :: J_85Rb       =  0.5  		  DOUBLE PRECISION, PARAMETER :: J_85Rb       =  0.5  
  DOUBLE PRECISION, PARAMETER :: I_85Rb       =  1.5  		  DOUBLE PRECISION, PARAMETER :: I_85Rb       =  1.5  
  DOUBLE PRECISION, PARAMETER :: g_J_85Rb     =  2.0		  DOUBLE PRECISION, PARAMETER :: g_J_85Rb     =  2.0
  DOUBLE PRECISION, PARAMETER :: g_I_85Rb     = -0.000995	  DOUBLE PRECISION, PARAMETER :: g_I_85Rb     = -0.000995
  DOUBLE PRECISION, PARAMETER :: A_85Rb       =  2*pi*hbar*3.	  DOUBLE PRECISION, PARAMETER :: A_85Rb       =  2*pi*hbar*3.
  DOUBLE PRECISION, PARAMETER :: a_s_85Rb     = 5.77E-9		  DOUBLE PRECISION, PARAMETER :: a_s_85Rb     = 5.77E-9
  DOUBLE PRECISION, PARAMETER :: alpha_E_85Rb = 2*pi*hbar*0.0	  DOUBLE PRECISION, PARAMETER :: alpha_E_85Rb = 2*pi*hbar*0.0
  INTEGER,          PARAMETER :: Fup_85Rb     =  2		  INTEGER,          PARAMETER :: Fup_85Rb     =  2
  INTEGER,          PARAMETER :: Fdown_85Rb   =  1		  INTEGER,          PARAMETER :: Fdown_85Rb   =  1
  CHARACTER(LEN=7) :: ID_name_85Rb = "85Rb"			  CHARACTER(LEN=7) :: ID_name_85Rb = "85Rb"


  !6Li  							  !6Li  
  DOUBLE PRECISION, PARAMETER :: mass_at_6Li = 6*amu		  DOUBLE PRECISION, PARAMETER :: mass_at_6Li = 6*amu
  DOUBLE PRECISION, PARAMETER :: Ftotal_6Li  = 2.0		  DOUBLE PRECISION, PARAMETER :: Ftotal_6Li  = 2.0
  DOUBLE PRECISION, PARAMETER :: J_6Li       =  0.5  		  DOUBLE PRECISION, PARAMETER :: J_6Li       =  0.5  
  DOUBLE PRECISION, PARAMETER :: I_6Li       =  1.5  		  DOUBLE PRECISION, PARAMETER :: I_6Li       =  1.5  
  DOUBLE PRECISION, PARAMETER :: g_J_6Li     =  2.0		  DOUBLE PRECISION, PARAMETER :: g_J_6Li     =  2.0
  DOUBLE PRECISION, PARAMETER :: g_I_6Li     = -0.000995	  DOUBLE PRECISION, PARAMETER :: g_I_6Li     = -0.000995
  DOUBLE PRECISION, PARAMETER :: A_6Li       =  2*pi*hbar*3.4	  DOUBLE PRECISION, PARAMETER :: A_6Li       =  2*pi*hbar*3.4
  DOUBLE PRECISION, PARAMETER :: a_s_6Li     = 5.77E-9		  DOUBLE PRECISION, PARAMETER :: a_s_6Li     = 5.77E-9
  DOUBLE PRECISION, PARAMETER :: alpha_E_6Li = 2*pi*hbar*0.07	  DOUBLE PRECISION, PARAMETER :: alpha_E_6Li = 2*pi*hbar*0.07
  INTEGER,          PARAMETER :: Fup_6Li     =  2		  INTEGER,          PARAMETER :: Fup_6Li     =  2
  INTEGER,          PARAMETER :: Fdown_6Li   =  1		  INTEGER,          PARAMETER :: Fdown_6Li   =  1
  CHARACTER(LEN=7) :: ID_name_6Li = "6Li"			  CHARACTER(LEN=7) :: ID_name_6Li = "6Li"


  !Cs								  !Cs
  DOUBLE PRECISION, PARAMETER :: mass_at_6Cs = 87*amu		  DOUBLE PRECISION, PARAMETER :: mass_at_6Cs = 87*amu
  DOUBLE PRECISION, PARAMETER :: Ftotal_6Cs  = 2.0		  DOUBLE PRECISION, PARAMETER :: Ftotal_6Cs  = 2.0
  DOUBLE PRECISION, PARAMETER :: J_Cs       =  0.5  		  DOUBLE PRECISION, PARAMETER :: J_Cs       =  0.5  
  DOUBLE PRECISION, PARAMETER :: I_6Cs       =  1.5  		  DOUBLE PRECISION, PARAMETER :: I_6Cs       =  1.5  
  DOUBLE PRECISION, PARAMETER :: g_J_6Cs     =  2.0		  DOUBLE PRECISION, PARAMETER :: g_J_6Cs     =  2.0
  DOUBLE PRECISION, PARAMETER :: g_I_6Cs     = -0.000995	  DOUBLE PRECISION, PARAMETER :: g_I_6Cs     = -0.000995
  DOUBLE PRECISION, PARAMETER :: A_6Cs       =  2*pi*hbar*3.4	  DOUBLE PRECISION, PARAMETER :: A_6Cs       =  2*pi*hbar*3.4
  DOUBLE PRECISION, PARAMETER :: a_s_6Cs     = 5.77E-9		  DOUBLE PRECISION, PARAMETER :: a_s_6Cs     = 5.77E-9
  DOUBLE PRECISION, PARAMETER :: alpha_E_6Cs = 2*pi*hbar*0.07	  DOUBLE PRECISION, PARAMETER :: alpha_E_6Cs = 2*pi*hbar*0.07
  INTEGER,          PARAMETER :: Fup_6Cs     =  2		  INTEGER,          PARAMETER :: Fup_6Cs     =  2
  INTEGER,          PARAMETER :: Fdown_6Cs   =  1		  INTEGER,          PARAMETER :: Fdown_6Cs   =  1
  CHARACTER(LEN=7) :: ID_name_Cs = "Cs"				  CHARACTER(LEN=7) :: ID_name_Cs = "Cs"


  !41K								  !41K
  DOUBLE PRECISION, PARAMETER :: mass_at_6K = 41*amu		  DOUBLE PRECISION, PARAMETER :: mass_at_6K = 41*amu
  DOUBLE PRECISION, PARAMETER :: Ftotal_6K  = 2.0		  DOUBLE PRECISION, PARAMETER :: Ftotal_6K  = 2.0
  DOUBLE PRECISION, PARAMETER :: J_K       =  0.5  		  DOUBLE PRECISION, PARAMETER :: J_K       =  0.5  
  DOUBLE PRECISION, PARAMETER :: I_6K       =  1.5  		  DOUBLE PRECISION, PARAMETER :: I_6K       =  1.5  
  DOUBLE PRECISION, PARAMETER :: g_J_6K     =  2.0		  DOUBLE PRECISION, PARAMETER :: g_J_6K     =  2.0
  DOUBLE PRECISION, PARAMETER :: g_I_6K     = -0.000995		  DOUBLE PRECISION, PARAMETER :: g_I_6K     = -0.000995
  DOUBLE PRECISION, PARAMETER :: A_6K       =  2*pi*hbar*3.41	  DOUBLE PRECISION, PARAMETER :: A_6K       =  2*pi*hbar*3.41
  DOUBLE PRECISION, PARAMETER :: a_s_6K     = 5.77E-9		  DOUBLE PRECISION, PARAMETER :: a_s_6K     = 5.77E-9
  DOUBLE PRECISION, PARAMETER :: alpha_E_6K = 2*pi*hbar*0.079	  DOUBLE PRECISION, PARAMETER :: alpha_E_6K = 2*pi*hbar*0.079
  INTEGER,          PARAMETER :: Fup_6K     =  2		  INTEGER,          PARAMETER :: Fup_6K     =  2
  INTEGER,          PARAMETER :: Fdown_6K   =  1		  INTEGER,          PARAMETER :: Fdown_6K   =  1
  CHARACTER(LEN=7) :: ID_name_41K = "41K"			  CHARACTER(LEN=7) :: ID_name_41K = "41K"

  !Na								  !Na
  DOUBLE PRECISION, PARAMETER :: mass_at_6Na = 87*amu		  DOUBLE PRECISION, PARAMETER :: mass_at_6Na = 87*amu
  DOUBLE PRECISION, PARAMETER :: Ftotal_6Na  = 2.0		  DOUBLE PRECISION, PARAMETER :: Ftotal_6Na  = 2.0
  DOUBLE PRECISION, PARAMETER :: J_Na        =  0.5  		  DOUBLE PRECISION, PARAMETER :: J_Na        =  0.5  
  DOUBLE PRECISION, PARAMETER :: I_6Na       =  1.5  		  DOUBLE PRECISION, PARAMETER :: I_6Na       =  1.5  
  DOUBLE PRECISION, PARAMETER :: g_J_6Na     =  2.0		  DOUBLE PRECISION, PARAMETER :: g_J_6Na     =  2.0
  DOUBLE PRECISION, PARAMETER :: g_I_6Na     = -0.000995	  DOUBLE PRECISION, PARAMETER :: g_I_6Na     = -0.000995
  DOUBLE PRECISION, PARAMETER :: A_6Na       =  2*pi*hbar*3.4	  DOUBLE PRECISION, PARAMETER :: A_6Na       =  2*pi*hbar*3.4
  DOUBLE PRECISION, PARAMETER :: a_s_6Na     = 5.77E-9		  DOUBLE PRECISION, PARAMETER :: a_s_6Na     = 5.77E-9
  DOUBLE PRECISION, PARAMETER :: alpha_E_6Na = 2*pi*hbar*0.07	  DOUBLE PRECISION, PARAMETER :: alpha_E_6Na = 2*pi*hbar*0.07
  INTEGER,          PARAMETER :: Fup_6Na     =  2		  INTEGER,          PARAMETER :: Fup_6Na     =  2
  INTEGER,          PARAMETER :: Fdown_6Na   =  1		  INTEGER,          PARAMETER :: Fdown_6Na   =  1
  CHARACTER(LEN=7) :: ID_name_Na = "Na"				  CHARACTER(LEN=7) :: ID_name_Na = "Na"


  !Qubit							  !Qubit
  DOUBLE PRECISION, PARAMETER :: mass_at_qubit =  amu		  DOUBLE PRECISION, PARAMETER :: mass_at_qubit =  amu
  DOUBLE PRECISION :: Ftotal_qubit  =  0.0			  DOUBLE PRECISION :: Ftotal_qubit  =  0.0
  DOUBLE PRECISION :: J_qubit       =  0.0			  DOUBLE PRECISION :: J_qubit       =  0.0
  DOUBLE PRECISION :: I_qubit       =  0.0			  DOUBLE PRECISION :: I_qubit       =  0.0
  DOUBLE PRECISION, PARAMETER :: g_J_qubit     =  1.0		  DOUBLE PRECISION, PARAMETER :: g_J_qubit     =  1.0
  DOUBLE PRECISION, PARAMETER :: g_I_qubit     =  0.0		  DOUBLE PRECISION, PARAMETER :: g_I_qubit     =  0.0
  DOUBLE PRECISION, PARAMETER :: A_qubit       =  1.0		  DOUBLE PRECISION, PARAMETER :: A_qubit       =  1.0
  DOUBLE PRECISION, PARAMETER :: a_s_qubit     =  0.0		  DOUBLE PRECISION, PARAMETER :: a_s_qubit     =  0.0
  DOUBLE PRECISION, PARAMETER :: alpha_E_qubit =  0.0		  DOUBLE PRECISION, PARAMETER :: alpha_E_qubit =  0.0
  INTEGER,          PARAMETER :: Fup_qubit     =  0		  INTEGER,          PARAMETER :: Fup_qubit     =  0
  INTEGER,          PARAMETER :: Fdown_qubit   =  0.5		  INTEGER,          PARAMETER :: Fdown_qubit   =  0.5
  CHARACTER(LEN=7) :: ID_name_qubit = "qubit"			  CHARACTER(LEN=7) :: ID_name_qubit = "qubit"

  !spin								  !spin
  DOUBLE PRECISION :: I_spin   =  0.0				  DOUBLE PRECISION :: I_spin   =  0.0
  DOUBLE PRECISION :: J_spin   =  0.0  				  DOUBLE PRECISION :: J_spin   =  0.0  
  DOUBLE PRECISION :: gJ_spin  =  1.0				  DOUBLE PRECISION :: gJ_spin  =  1.0
  DOUBLE PRECISION :: gI_spin  =  0.0				  DOUBLE PRECISION :: gI_spin  =  0.0
  DOUBLE PRECISION :: A_spin   =  1.0				  DOUBLE PRECISION :: A_spin   =  1.0
  DOUBLE PRECISION :: a_s_spin =  0.0				  DOUBLE PRECISION :: a_s_spin =  0.0
  DOUBLE PRECISION :: alpha_E_spin = 0.0			  DOUBLE PRECISION :: alpha_E_spin = 0.0
  INTEGER          :: Fup_spin     =  1				  INTEGER          :: Fup_spin     =  1
  INTEGER          :: Fdown_spin   =  1				  INTEGER          :: Fdown_spin   =  1
  CHARACTER(LEN=7) :: ID_name_spin = "spin"			  CHARACTER(LEN=7) :: ID_name_spin = "spin"


  !lattice							  !lattice
  CHARACTER        :: PERIODIC      				  CHARACTER        :: PERIODIC      
  CHARACTER(LEN=7) :: ID_name_lattice = "lattice"		  CHARACTER(LEN=7) :: ID_name_lattice = "lattice"

END MODULE ATOMIC_PROPERTIES					END MODULE ATOMIC_PROPERTIES
diff -y ./src/delta_kr.f90 ../../Downloads/MultimodeFloquet-0.3/src/delta_kr.f90
MODULE funciones						MODULE funciones
  IMPLICIT NONE							  IMPLICIT NONE

CONTAINS							CONTAINS

  FUNCTION delta_kr(M,N)					  FUNCTION delta_kr(M,N)
    IMPLICIT NONE						    IMPLICIT NONE
    DOUBLE PRECISION :: M,N					    DOUBLE PRECISION :: M,N
    INTEGER DELTA_KR    					    INTEGER DELTA_KR    
    IF(M.EQ.N) DELTA_KR = 1					    IF(M.EQ.N) DELTA_KR = 1
    IF(M.NE.N) DELTA_KR = 0    					    IF(M.NE.N) DELTA_KR = 0    
  END FUNCTION delta_kr						  END FUNCTION delta_kr

  FUNCTION delta_kr_int(M,N)    				  FUNCTION delta_kr_int(M,N)    
    IMPLICIT NONE						    IMPLICIT NONE
    INTEGER :: M,N						    INTEGER :: M,N
    INTEGER DELTA_KR_INT    					    INTEGER DELTA_KR_INT    
    IF(M.EQ.N) DELTA_KR_INT = 1					    IF(M.EQ.N) DELTA_KR_INT = 1
    IF(M.NE.N) DELTA_KR_INT = 0    				    IF(M.NE.N) DELTA_KR_INT = 0    
  END FUNCTION delta_kr_int					  END FUNCTION delta_kr_int

END MODULE funciones						END MODULE funciones




diff -y ./src/Floquet_init_C.f90 ../../Downloads/MultimodeFloquet-0.3/src/Floquet_init_C.f90
SUBROUTINE SET_ATOMIC_PARAMETERS_C(ATOMICSPECIE,MANIFOLD,JTOT	SUBROUTINE SET_ATOMIC_PARAMETERS_C(ATOMICSPECIE,MANIFOLD,JTOT
  ! ATOMICSPECIE: 87Rb,6Li,Cs,41K,qubit,lattice, SPIN		  ! ATOMICSPECIE: 87Rb,6Li,Cs,41K,qubit,lattice, SPIN
  ! MANIFOLD : "U" UPPER HYPERFINE MANIFOLD, "L" LOWER HYPERF	  ! MANIFOLD : "U" UPPER HYPERFINE MANIFOLD, "L" LOWER HYPERF
  ! JTOTAL   :  IF ATOMICSPECIE .EQ. SPIN THEN JTOTAL IS THE 	  ! JTOTAL   :  IF ATOMICSPECIE .EQ. SPIN THEN JTOTAL IS THE 
  !             IF ATOMICSPECIE .EQ. LATTICE, THEN JTOTAL IS 	  !             IF ATOMICSPECIE .EQ. LATTICE, THEN JTOTAL IS 
  USE TYPES_C							  USE TYPES_C
  USE MODES_4F							  USE MODES_4F
  IMPLICIT NONE							  IMPLICIT NONE
  CHARACTER (LEN=*),OPTIONAL, INTENT(IN) :: ATOMICSPECIE	  CHARACTER (LEN=*),OPTIONAL, INTENT(IN) :: ATOMICSPECIE
  CHARACTER (LEN=*),OPTIONAL, INTENT(IN) :: MANIFOLD  !		  CHARACTER (LEN=*),OPTIONAL, INTENT(IN) :: MANIFOLD  !
  INTEGER,          OPTIONAL, INTENT(IN) :: JTOTAL		  INTEGER,          OPTIONAL, INTENT(IN) :: JTOTAL
  TYPE(ATOM_C),INTENT(OUT) :: ID_C				  TYPE(ATOM_C),INTENT(OUT) :: ID_C
  INTEGER, INTENT(INOUT) :: INFO				  INTEGER, INTENT(INOUT) :: INFO
  INFO = 0							  INFO = 0

  CALL SET_ATOMIC_PARAMETERS(ATOMICSPECIE,MANIFOLD,1.0D0*JTOT	  CALL SET_ATOMIC_PARAMETERS(ATOMICSPECIE,MANIFOLD,1.0D0*JTOT

END SUBROUTINE SET_ATOMIC_PARAMETERS_C				END SUBROUTINE SET_ATOMIC_PARAMETERS_C



SUBROUTINE DEALLOCATEALL_C(ID)					SUBROUTINE DEALLOCATEALL_C(ID)
  USE ARRAYS							  USE ARRAYS
  IMPLICIT NONE							  IMPLICIT NONE
  INTEGER, INTENT(IN)::ID					  INTEGER, INTENT(IN)::ID
  CALL DEALLOCATEALL(ID)					  CALL DEALLOCATEALL(ID)
END SUBROUTINE DEALLOCATEALL_C					END SUBROUTINE DEALLOCATEALL_C




!MODULE FLOQUETINITINTERFACE_C					!MODULE FLOQUETINITINTERFACE_C
!  INTERFACE FLOQUETINIT_C					!  INTERFACE FLOQUETINIT_C
!     MODULE PROCEDURE FLOQUETINIT_QUBIT_C, FLOQUETINIT_SPIN_	!     MODULE PROCEDURE FLOQUETINIT_QUBIT_C, FLOQUETINIT_SPIN_
!  END INTERFACE FLOQUETINIT_C					!  END INTERFACE FLOQUETINIT_C
!CONTAINS							!CONTAINS
  SUBROUTINE FLOQUETINIT_QUBIT_C(ID_C,length_name,ATOMICSPECI |	SUBROUTINE FLOQUETINIT_QUBIT_C(ID_C,length_name,ATOMICSPECIE,
    ! ATOMICSPECIE: 87Rb,6Li,Cs,41K,qubit,lattice, SPIN		    ! ATOMICSPECIE: 87Rb,6Li,Cs,41K,qubit,lattice, SPIN
    ! MANIFOLD : "U" UPPER HYPERFINE MANIFOLD, "L" LOWER HYPE	    ! MANIFOLD : "U" UPPER HYPERFINE MANIFOLD, "L" LOWER HYPE
    ! JTOTAL   :  IF ATOMICSPECIE .EQ. SPIN THEN JTOTAL IS TH	    ! JTOTAL   :  IF ATOMICSPECIE .EQ. SPIN THEN JTOTAL IS TH
    !             IF ATOMICSPECIE .EQ. LATTICE, THEN JTOTAL I	    !             IF ATOMICSPECIE .EQ. LATTICE, THEN JTOTAL I
    ! calculate the dimenson of the Hilbert space		    ! calculate the dimenson of the Hilbert space
    ! initialize all the matrices required for a full Floquet	    ! initialize all the matrices required for a full Floquet
    ! Calculate the nuclear, electron and total angular momen	    ! Calculate the nuclear, electron and total angular momen
    								    
    USE TYPES_C							    USE TYPES_C
    USE MODES_4F						    USE MODES_4F
    USE FLOQUETINITINTERFACE					    USE FLOQUETINITINTERFACE
    IMPLICIT NONE						    IMPLICIT NONE


    CHARACTER(LEN=*), INTENT(IN)    :: ATOMICSPECIE		    CHARACTER(LEN=*), INTENT(IN)    :: ATOMICSPECIE
    INTEGER,                    INTENT(IN)    :: length_name!	    INTEGER,                    INTENT(IN)    :: length_name!
    !DOUBLE PRECISION,           INTENT(IN)    :: JTOTAL	    !DOUBLE PRECISION,           INTENT(IN)    :: JTOTAL
    TYPE(ATOM_C),               INTENT(OUT)   :: ID_C		    TYPE(ATOM_C),               INTENT(OUT)   :: ID_C
    INTEGER,                    INTENT(INOUT) :: INFO		    INTEGER,                    INTENT(INOUT) :: INFO

    CHARACTER(length_name) atomicspecie_F			    CHARACTER(length_name) atomicspecie_F

    atomicspecie_F = atomicspecie(1:length_name)		    atomicspecie_F = atomicspecie(1:length_name)
    								    
    !CALL FLOQUETINIT_OLD(ATOM_,atomicspecie_F,manifold,1.0D0	    !CALL FLOQUETINIT_OLD(ATOM_,atomicspecie_F,manifold,1.0D0
    CALL FLOQUETINIT_QUBIT(ATOM_,atomicspecie_F,INFO)		    CALL FLOQUETINIT_QUBIT(ATOM_,atomicspecie_F,INFO)
    								    
    ID_C%id_system = ATOM_%id_system				    ID_C%id_system = ATOM_%id_system
    ID_C%D_BARE    = ATOM_%D_BARE				    ID_C%D_BARE    = ATOM_%D_BARE

  END SUBROUTINE FLOQUETINIT_QUBIT_C				  END SUBROUTINE FLOQUETINIT_QUBIT_C

  SUBROUTINE FLOQUETINIT_SPIN_C(ID_C,length_name,atomicspecie	  SUBROUTINE FLOQUETINIT_SPIN_C(ID_C,length_name,atomicspecie
    ! ATOMICSPECIE: 87Rb,6Li,Cs,41K,qubit,lattice, SPIN		    ! ATOMICSPECIE: 87Rb,6Li,Cs,41K,qubit,lattice, SPIN
    ! MANIFOLD : "U" UPPER HYPERFINE MANIFOLD, "L" LOWER HYPE	    ! MANIFOLD : "U" UPPER HYPERFINE MANIFOLD, "L" LOWER HYPE
    ! JTOTAL   :  IF ATOMICSPECIE .EQ. SPIN THEN JTOTAL IS TH	    ! JTOTAL   :  IF ATOMICSPECIE .EQ. SPIN THEN JTOTAL IS TH
    !             IF ATOMICSPECIE .EQ. LATTICE, THEN JTOTAL I	    !             IF ATOMICSPECIE .EQ. LATTICE, THEN JTOTAL I


    ! calculate the dimenson of the Hilbert space		    ! calculate the dimenson of the Hilbert space
    ! initialize all the matrices required for a full Floquet	    ! initialize all the matrices required for a full Floquet
    ! Calculate the nuclear, electron and total angular momen	    ! Calculate the nuclear, electron and total angular momen

    USE TYPES_C							    USE TYPES_C
    USE MODES_4F						    USE MODES_4F
    USE FLOQUETINITINTERFACE					    USE FLOQUETINITINTERFACE
    IMPLICIT NONE						    IMPLICIT NONE


    CHARACTER(length_name), INTENT(IN)    :: ATOMICSPECIE     |	    CHARACTER(LEN=*), INTENT(IN)    :: ATOMICSPECIE
    INTEGER,                    INTENT(IN)    :: length_name!	    INTEGER,                    INTENT(IN)    :: length_name!
    DOUBLE PRECISION,           INTENT(IN)    :: JTOTAL		    DOUBLE PRECISION,           INTENT(IN)    :: JTOTAL
    TYPE(ATOM_C),               INTENT(OUT)   :: ID_C		    TYPE(ATOM_C),               INTENT(OUT)   :: ID_C
    INTEGER,                    INTENT(INOUT) :: INFO		    INTEGER,                    INTENT(INOUT) :: INFO

    CHARACTER(length_name) atomicspecie_F			    CHARACTER(length_name) atomicspecie_F
    								    
    atomicspecie_F = atomicspecie(1:length_name)		    atomicspecie_F = atomicspecie(1:length_name)
    CALL FLOQUETINIT_SPIN(ATOM_,atomicspecie_F,jtotal,info)	    CALL FLOQUETINIT_SPIN(ATOM_,atomicspecie_F,jtotal,info)
    								    
    ID_C%id_system = ATOM_%id_system				    ID_C%id_system = ATOM_%id_system
    ID_C%D_BARE    = ATOM_%D_BARE				    ID_C%D_BARE    = ATOM_%D_BARE



  END SUBROUTINE FLOQUETINIT_SPIN_C				  END SUBROUTINE FLOQUETINIT_SPIN_C

  SUBROUTINE FLOQUETINIT_ALKALI_C(ID_C,length_name,atomicspec	  SUBROUTINE FLOQUETINIT_ALKALI_C(ID_C,length_name,atomicspec
    ! ATOMICSPECIE: 87Rb,6Li,Cs,41K,qubit,lattice, SPIN		    ! ATOMICSPECIE: 87Rb,6Li,Cs,41K,qubit,lattice, SPIN
    ! MANIFOLD : "U" UPPER HYPERFINE MANIFOLD, "L" LOWER HYPE	    ! MANIFOLD : "U" UPPER HYPERFINE MANIFOLD, "L" LOWER HYPE
    ! JTOTAL   :  IF ATOMICSPECIE .EQ. SPIN THEN JTOTAL IS TH	    ! JTOTAL   :  IF ATOMICSPECIE .EQ. SPIN THEN JTOTAL IS TH
    !             IF ATOMICSPECIE .EQ. LATTICE, THEN JTOTAL I	    !             IF ATOMICSPECIE .EQ. LATTICE, THEN JTOTAL I


    ! calculate the dimenson of the Hilbert space		    ! calculate the dimenson of the Hilbert space
    ! initialize all the matrices required for a full Floquet	    ! initialize all the matrices required for a full Floquet
    ! Calculate the nuclear, electron and total angular momen	    ! Calculate the nuclear, electron and total angular momen

    USE TYPES_C							    USE TYPES_C
    USE MODES_4F						    USE MODES_4F
    USE FLOQUETINITINTERFACE					    USE FLOQUETINITINTERFACE
    IMPLICIT NONE						    IMPLICIT NONE


    CHARACTER(length_name), INTENT(IN)    :: ATOMICSPECIE     |	    CHARACTER(LEN=*), INTENT(IN)    :: ATOMICSPECIE
    CHARACTER(length_name2), INTENT(IN)    :: manifold	      |	    CHARACTER(LEN=*), INTENT(IN)    :: manifold
    INTEGER,                    INTENT(IN)    :: length_name,	    INTEGER,                    INTENT(IN)    :: length_name,
    TYPE(ATOM_C),               INTENT(OUT)   :: ID_C		    TYPE(ATOM_C),               INTENT(OUT)   :: ID_C
    INTEGER,                    INTENT(INOUT) :: INFO		    INTEGER,                    INTENT(INOUT) :: INFO

    CHARACTER(length_name) atomicspecie_F		      |	    CHARACTER(length_name)  atomicspecie_F
    CHARACTER(length_name2) manifold_F				    CHARACTER(length_name2) manifold_F
     								     
    atomicspecie_F = atomicspecie(1:length_name)		    atomicspecie_F = atomicspecie(1:length_name)
    manifold_F     = manifold(1:length_name2)			    manifold_F     = manifold(1:length_name2)
    CALL FLOQUETINIT_ALKALI(ATOM_,atomicspecie_F,manifold,inf	    CALL FLOQUETINIT_ALKALI(ATOM_,atomicspecie_F,manifold,inf
    								    
    ID_C%id_system = ATOM_%id_system				    ID_C%id_system = ATOM_%id_system
    ID_C%D_BARE    = ATOM_%D_BARE				    ID_C%D_BARE    = ATOM_%D_BARE

  END SUBROUTINE FLOQUETINIT_ALKALI_C				  END SUBROUTINE FLOQUETINIT_ALKALI_C

!END MODULE FLOQUETINITINTERFACE_C				!END MODULE FLOQUETINITINTERFACE_C

SUBROUTINE FLOQUETINIT_OLD_C(length_name,atomicspecie,manifol	SUBROUTINE FLOQUETINIT_OLD_C(length_name,atomicspecie,manifol
  ! ATOMICSPECIE: 87Rb,6Li,Cs,41K,qubit,lattice, SPIN		  ! ATOMICSPECIE: 87Rb,6Li,Cs,41K,qubit,lattice, SPIN
  ! MANIFOLD : "U" UPPER HYPERFINE MANIFOLD, "L" LOWER HYPERF	  ! MANIFOLD : "U" UPPER HYPERFINE MANIFOLD, "L" LOWER HYPERF
  ! JTOTAL   :  IF ATOMICSPECIE .EQ. SPIN THEN JTOTAL IS THE 	  ! JTOTAL   :  IF ATOMICSPECIE .EQ. SPIN THEN JTOTAL IS THE 
  !             IF ATOMICSPECIE .EQ. LATTICE, THEN JTOTAL IS 	  !             IF ATOMICSPECIE .EQ. LATTICE, THEN JTOTAL IS 


  ! calculate the dimenson of the Hilbert space			  ! calculate the dimenson of the Hilbert space
  ! initialize all the matrices required for a full Floquet c	  ! initialize all the matrices required for a full Floquet c
  ! Calculate the nuclear, electron and total angular momentu	  ! Calculate the nuclear, electron and total angular momentu

  USE TYPES_C							  USE TYPES_C
  USE MODES_4F							  USE MODES_4F
  USE FLOQUETINITINTERFACE					  USE FLOQUETINITINTERFACE
  IMPLICIT NONE							  IMPLICIT NONE


  CHARACTER(length_name), INTENT(IN)    :: ATOMICSPECIE	      |	  CHARACTER(LEN=*),          INTENT(IN)    :: ATOMICSPECIE
  CHARACTER(1),           INTENT(IN)    :: MANIFOLD  !	      |	  CHARACTER(1),               INTENT(IN)    :: MANIFOLD  !
  INTEGER,                    INTENT(IN)    :: length_name!,J	  INTEGER,                    INTENT(IN)    :: length_name!,J
  DOUBLE PRECISION,           INTENT(IN)    :: JTOTAL		  DOUBLE PRECISION,           INTENT(IN)    :: JTOTAL
  TYPE(ATOM_C),               INTENT(OUT)   :: ID_C		  TYPE(ATOM_C),               INTENT(OUT)   :: ID_C
  INTEGER,                    INTENT(INOUT) :: INFO		  INTEGER,                    INTENT(INOUT) :: INFO



  CHARACTER(length_name) atomicspecie_F				  CHARACTER(length_name) atomicspecie_F

  atomicspecie_F = atomicspecie(1:length_name)			  atomicspecie_F = atomicspecie(1:length_name)

  CALL FLOQUETINIT_OLD(ATOM_,atomicspecie_F,manifold,1.0D0*JT	  CALL FLOQUETINIT_OLD(ATOM_,atomicspecie_F,manifold,1.0D0*JT

  ID_C%id_system = ATOM_%id_system				  ID_C%id_system = ATOM_%id_system
  ID_C%D_BARE    = ATOM_%D_BARE					  ID_C%D_BARE    = ATOM_%D_BARE


END SUBROUTINE FLOQUETINIT_OLD_C				END SUBROUTINE FLOQUETINIT_OLD_C


SUBROUTINE SETHAMILTONIANCOMPONENTS_C(ATOM__C,NM,NF,MODES_NUM	SUBROUTINE SETHAMILTONIANCOMPONENTS_C(ATOM__C,NM,NF,MODES_NUM
  ! ID  tYPE OF ATOM						  ! ID  tYPE OF ATOM
  ! MODES_NUM, VECTOR. THE SIZE OF THE VECTOR TELL US THE NUM	  ! MODES_NUM, VECTOR. THE SIZE OF THE VECTOR TELL US THE NUM
  ! FIELDS : IN AND OUTPUT THE MATRICES				  ! FIELDS : IN AND OUTPUT THE MATRICES
  ! INFO							  ! INFO

  !USE ARRAYS							  !USE ARRAYS

  USE TYPES_C							  USE TYPES_C
  USE MODES_4F							  USE MODES_4F

  IMPLICIT NONE							  IMPLICIT NONE
  INTEGER,                     INTENT(IN)    :: NM,NF		  INTEGER,                     INTENT(IN)    :: NM,NF
  TYPE(ATOM_C),                INTENT(IN)    :: ATOM__C		  TYPE(ATOM_C),                INTENT(IN)    :: ATOM__C
  INTEGER,      DIMENSION(NM), INTENT(IN)    :: MODES_NUM	  INTEGER,      DIMENSION(NM), INTENT(IN)    :: MODES_NUM
  TYPE(MODE_C), DIMENSION(NF), INTENT(INOUT) :: COUPLING_C	  TYPE(MODE_C), DIMENSION(NF), INTENT(INOUT) :: COUPLING_C
  INTEGER,                     INTENT(INOUT) :: INFO		  INTEGER,                     INTENT(INOUT) :: INFO


  CALL COUPLINGINIT_C(ATOM__C%D_BARE,NF,ATOM__C,COUPLING_C,IN	  CALL COUPLINGINIT_C(ATOM__C%D_BARE,NF,ATOM__C,COUPLING_C,IN
  ! TO DEFINE AND INITIALISE THE GLOBAL FORTRAN TYPES ATOM_ A	  ! TO DEFINE AND INITIALISE THE GLOBAL FORTRAN TYPES ATOM_ A
  ! THESE TWO TYPES ARE THEN PASSED ON TO THE ALL OTHER ROUTI	  ! THESE TWO TYPES ARE THEN PASSED ON TO THE ALL OTHER ROUTI
  !write(*,*) info,nm,nf					  !write(*,*) info,nm,nf
  CALL SETHAMILTONIANCOMPONENTS(ATOM_,NM,NF,MODES_NUM,COUPLIN	  CALL SETHAMILTONIANCOMPONENTS(ATOM_,NM,NF,MODES_NUM,COUPLIN

END SUBROUTINE SETHAMILTONIANCOMPONENTS_C			END SUBROUTINE SETHAMILTONIANCOMPONENTS_C

Only in ../../Downloads/MultimodeFloquet-0.3/src/: Floquet_init_C.f90~
diff -y ./src/Floquet_init.f90 ../../Downloads/MultimodeFloquet-0.3/src/Floquet_init.f90
SUBROUTINE SET_ATOMIC_PARAMETERS(ATOMICSPECIE,MANIFOLD,JTOTAL	SUBROUTINE SET_ATOMIC_PARAMETERS(ATOMICSPECIE,MANIFOLD,JTOTAL
  ! ATOMICSPECIE: 87Rb,6Li,Cs,41K,qubit,lattice, SPIN		  ! ATOMICSPECIE: 87Rb,6Li,Cs,41K,qubit,lattice, SPIN
  ! MANIFOLD : "U" UPPER HYPERFINE MANIFOLD, "L" LOWER HYPERF	  ! MANIFOLD : "U" UPPER HYPERFINE MANIFOLD, "L" LOWER HYPERF
  ! JTOTAL   :  IF ATOMICSPECIE .EQ. SPIN THEN JTOTAL IS THE 	  ! JTOTAL   :  IF ATOMICSPECIE .EQ. SPIN THEN JTOTAL IS THE 
  !             IF ATOMICSPECIE .EQ. LATTICE, THEN JTOTAL IS 	  !             IF ATOMICSPECIE .EQ. LATTICE, THEN JTOTAL IS 

  USE ATOMIC_PROPERTIES						  USE ATOMIC_PROPERTIES
  USE TYPES							  USE TYPES

  IMPLICIT NONE							  IMPLICIT NONE
  CHARACTER (LEN=*),OPTIONAL, INTENT(IN) :: ATOMICSPECIE	  CHARACTER (LEN=*),OPTIONAL, INTENT(IN) :: ATOMICSPECIE
  CHARACTER (LEN=*),OPTIONAL, INTENT(IN) :: MANIFOLD  !		  CHARACTER (LEN=*),OPTIONAL, INTENT(IN) :: MANIFOLD  !
  !  INTEGER,          OPTIONAL, INTENT(IN) :: JTOTAL		  !  INTEGER,          OPTIONAL, INTENT(IN) :: JTOTAL
  DOUBLE PRECISION,  OPTIONAL, INTENT(IN) :: JTOTAL_		  DOUBLE PRECISION,  OPTIONAL, INTENT(IN) :: JTOTAL_
  TYPE(ATOM),INTENT(OUT) :: ID					  TYPE(ATOM),INTENT(OUT) :: ID
  INTEGER, INTENT(INOUT) :: INFO				  INTEGER, INTENT(INOUT) :: INFO

  DOUBLE PRECISION  JTOTAL					  DOUBLE PRECISION  JTOTAL
!  write(*,*) atomicspecie,jtotal_				!  write(*,*) atomicspecie,jtotal_
  JTOTAL = JTOTAL_/2.0						  JTOTAL = JTOTAL_/2.0
  !  IF(JTOTAL.NE.JTOTAL_) JTOTAL = JTOTAL_			  !  IF(JTOTAL.NE.JTOTAL_) JTOTAL = JTOTAL_

  INFO = 4 !UNDEFINED ID					  INFO = 4 !UNDEFINED ID
  IF(PRESENT(ATOMICSPECIE)) THEN				  IF(PRESENT(ATOMICSPECIE)) THEN
     SELECT CASE (ATOMICSPECIE)					     SELECT CASE (ATOMICSPECIE)
     CASE("87Rb")						     CASE("87Rb")
        mass_at = 87*amu					        mass_at = 87*amu
        I       = I_87Rb					        I       = I_87Rb
        g_I     = g_I_87Rb					        g_I     = g_I_87Rb
        J       = J_87Rb					        J       = J_87Rb
        g_J     = g_J_87Rb					        g_J     = g_J_87Rb
        A       = A_87Rb					        A       = A_87Rb
        a_s     = a_s_87Rb					        a_s     = a_s_87Rb
        alpha_E = alpha_E_87Rb					        alpha_E = alpha_E_87Rb
        Fup     = Fup_87Rb					        Fup     = Fup_87Rb
        Fdown   = Fdown_87Rb					        Fdown   = Fdown_87Rb
        INFO    = 1						        INFO    = 1
        ID_name = ID_name_87Rb					        ID_name = ID_name_87Rb
!        write(*,*) "# 87Rb"					!        write(*,*) "# 87Rb"
     CASE ("6Li")						     CASE ("6Li")
        mass_at = 6*amu						        mass_at = 6*amu
        I       = I_6Li						        I       = I_6Li
        g_I     = g_I_6Li					        g_I     = g_I_6Li
        J       = J_6Li						        J       = J_6Li
        g_J     = g_J_6Li					        g_J     = g_J_6Li
        A       = A_6Li						        A       = A_6Li
        a_s     = a_s_6Li					        a_s     = a_s_6Li
        alpha_E = alpha_E_6Li					        alpha_E = alpha_E_6Li
        Fup     = Fup_6Li					        Fup     = Fup_6Li
        Fdown   = Fdown_87Rb     				        Fdown   = Fdown_87Rb     
        INFO    = 1  ! ITS AN ATOM				        INFO    = 1  ! ITS AN ATOM
        ID_name = ID_name_6Li					        ID_name = ID_name_6Li
!        write(*,*) "# 6Li"					!        write(*,*) "# 6Li"
     CASE("qubit")						     CASE("qubit")
        mass_at = amu						        mass_at = amu
        I       = I_qubit					        I       = I_qubit
        g_I     = I_qubit					        g_I     = I_qubit
        J       = J_qubit					        J       = J_qubit
        g_J     = J_qubit					        g_J     = J_qubit
        A       = A_qubit					        A       = A_qubit
        a_s     = a_s_qubit					        a_s     = a_s_qubit
        alpha_E = alpha_E_qubit					        alpha_E = alpha_E_qubit
        Fup     = Fup_qubit					        Fup     = Fup_qubit
        Fdown   = Fdown_qubit					        Fdown   = Fdown_qubit
        INFO    = 2 ! ITS A QUBIT				        INFO    = 2 ! ITS A QUBIT
        ID_name = ID_name_qubit					        ID_name = ID_name_qubit

        !write(*,*) "# qubit"					        !write(*,*) "# qubit"
     CASE("spin")						     CASE("spin")
        mass_at = amu						        mass_at = amu
        I       = I_spin					        I       = I_spin
        g_I     = I_spin					        g_I     = I_spin
        J       = J_spin					        J       = J_spin
        g_J     = J_spin					        g_J     = J_spin
        A       = A_spin					        A       = A_spin
        a_s     = a_s_spin					        a_s     = a_s_spin
        alpha_E = alpha_E_spin					        alpha_E = alpha_E_spin
        Fup     = Fup_spin					        Fup     = Fup_spin
        Fdown   = Fdown_spin					        Fdown   = Fdown_spin
        INFO    = 3 ! ITS A SPIN				        INFO    = 3 ! ITS A SPIN
        ID_name = ID_name_spin					        ID_name = ID_name_spin

        write(*,*) "# spin"					        write(*,*) "# spin"
     CASE("lattice")						     CASE("lattice")
        INFO    = 5 ! ITS A lattice				        INFO    = 5 ! ITS A lattice
        ID_name = ID_name_lattice				        ID_name = ID_name_lattice

     END SELECT							     END SELECT
  END IF							  END IF
  IF(INFO.EQ.1) THEN						  IF(INFO.EQ.1) THEN
     ! HERE WE DEFINE THE ATOMIC PARAMETES ENTERING THE HAMIL	     ! HERE WE DEFINE THE ATOMIC PARAMETES ENTERING THE HAMIL
     ! H = A I \cdot J + sum_fields mu_B g_J B \cdot J + mu_B	     ! H = A I \cdot J + sum_fields mu_B g_J B \cdot J + mu_B
     ! H = sum_fields mu_B g_F B \cdot F			     ! H = sum_fields mu_B g_F B \cdot F

     J = L+S							     J = L+S
     F    = Fup							     F    = Fup
     gF_2 = g_J*(F*(F+1) - I*(I+1) +J*(J+1))/(2*F*(F+1)) + g_	     gF_2 = g_J*(F*(F+1) - I*(I+1) +J*(J+1))/(2*F*(F+1)) + g_
     F    = Fdown						     F    = Fdown
     gF_1 = g_J*(F*(F+1) - I*(I+1) +J*(J+1))/(2*F*(F+1)) + g_	     gF_1 = g_J*(F*(F+1) - I*(I+1) +J*(J+1))/(2*F*(F+1)) + g_
     G_F  = (g_J-g_I)/16.0					     G_F  = (g_J-g_I)/16.0
     IF(PRESENT(MANIFOLD)) THEN					     IF(PRESENT(MANIFOLD)) THEN
        IF(MANIFOLD.EQ."U") THEN				        IF(MANIFOLD.EQ."U") THEN

           Ftotal           = Fup				           Ftotal           = Fup
           total_states_lsi = 2*Fup + 1				           total_states_lsi = 2*Fup + 1
           gF               = gF_2				           gF               = gF_2
           ID%id_system = 1					           ID%id_system = 1

        ELSE  IF(MANIFOLD.EQ."L") THEN				        ELSE  IF(MANIFOLD.EQ."L") THEN

           Ftotal           = Fdown				           Ftotal           = Fdown
           total_states_lsi = 2*Fdown + 1			           total_states_lsi = 2*Fdown + 1
           gF               = gF_1        			           gF               = gF_1        
           ID%id_system = 2					           ID%id_system = 2

        ELSE IF(MANIFOLD.EQ."B") THEN				        ELSE IF(MANIFOLD.EQ."B") THEN
           Ftotal = Fup						           Ftotal = Fup

           !----- Counting the number of states			           !----- Counting the number of states
           J = L+S						           J = L+S
           Total_states_LSI = 0					           Total_states_LSI = 0
           DO WHILE(J.GE.ABS(L-S))				           DO WHILE(J.GE.ABS(L-S))
              F = I+J						              F = I+J
              DO WHILE(F.GE.ABS(J-I))				              DO WHILE(F.GE.ABS(J-I))
                 !        write(*,*) Total_states_LSI,F,I,J	                 !        write(*,*) Total_states_LSI,F,I,J
                 Total_states_LSI = Total_states_LSI + 2*int(	                 Total_states_LSI = Total_states_LSI + 2*int(
                 F = F - 1					                 F = F - 1
              END DO						              END DO
              J= J - 1 ! only two values allowed for J: J = L	              J= J - 1 ! only two values allowed for J: J = L
           END DO						           END DO
           J = L+S  ! reseting value of J modifeid before	           J = L+S  ! reseting value of J modifeid before
           IF(s.eq.0.5 .and. i.LT.0.5) total_states_lsi = 2	           IF(s.eq.0.5 .and. i.LT.0.5) total_states_lsi = 2
           ID%id_system = 3					           ID%id_system = 3
        END IF							        END IF
     END IF							     END IF
  ELSE IF(INFO .EQ. 2) THEN					  ELSE IF(INFO .EQ. 2) THEN
     ! HERE WE DEFINE THE PARAMETERS OF THE QUBIT HAMILTONIAN	     ! HERE WE DEFINE THE PARAMETERS OF THE QUBIT HAMILTONIAN
     ! H = HBAR OMEGA_0 S_x + HBAR OMEGA_T S_x + HBAR OMEGA_R	     ! H = HBAR OMEGA_0 S_x + HBAR OMEGA_T S_x + HBAR OMEGA_R
     total_states_lsi = 2					     total_states_lsi = 2
     J  = 0.0							     J  = 0.0
     S  = 0.5							     S  = 0.5
     F  = 0.5							     F  = 0.5
     L  = 0.0							     L  = 0.0
     gF = 1.0							     gF = 1.0
     Ftotal = 0.5						     Ftotal = 0.5
     ID%id_system = 4						     ID%id_system = 4
  ELSE IF(INFO .EQ. 3) THEN					  ELSE IF(INFO .EQ. 3) THEN
     ! HERE WE DEFINE THE PARRAMETES OF THE SPIN HAMILTONIAN	     ! HERE WE DEFINE THE PARRAMETES OF THE SPIN HAMILTONIAN
     ! H = HBAR OMEGA_0 S_x + HBAR OMEGA_T S_x + HBAR OMEGA_R	     ! H = HBAR OMEGA_0 S_x + HBAR OMEGA_T S_x + HBAR OMEGA_R
     total_states_lsi = 2*JTOTAL + 1				     total_states_lsi = 2*JTOTAL + 1
     J      = 0.0						     J      = 0.0
     S      = JTOTAL						     S      = JTOTAL
     F      = JTOTAL						     F      = JTOTAL
     L      = 0.0						     L      = 0.0
     gF     = 1.0						     gF     = 1.0
     Ftotal = JTOTAL						     Ftotal = JTOTAL
     ID%id_system = 5						     ID%id_system = 5
  ELSE IF(INFO .EQ. 4) THEN					  ELSE IF(INFO .EQ. 4) THEN
     ! HERE WE DEFINE THE PARAMETES OF THE LATTICE HAMILTONIA	     ! HERE WE DEFINE THE PARAMETES OF THE LATTICE HAMILTONIA
     ID%id_system = 6     					     ID%id_system = 6     
     ID_name      = "unnamed"					     ID_name      = "unnamed"
  ELSE IF(INFO.EQ.5) THEN					  ELSE IF(INFO.EQ.5) THEN
     ID%id_system    = 7					     ID%id_system    = 7
     ID_name         = "lattice"				     ID_name         = "lattice"
     IF(PRESENT(MANIFOLD)) PERIODIC        =  manifold ! boun	     IF(PRESENT(MANIFOLD)) PERIODIC        =  manifold ! boun
     total_states_lsi = JTOTAL_   ! number of sites		     total_states_lsi = JTOTAL_   ! number of sites
  END IF							  END IF
  !WRITE(*,*) 'set_atomic_properties',JTOTAL,JTOTAL_,TOTAL_ST	  !WRITE(*,*) 'set_atomic_properties',JTOTAL,JTOTAL_,TOTAL_ST
  ID%D_bare = total_states_lsi					  ID%D_bare = total_states_lsi

END SUBROUTINE SET_ATOMIC_PARAMETERS				END SUBROUTINE SET_ATOMIC_PARAMETERS

SUBROUTINE DEALLOCATEALL(ID)					SUBROUTINE DEALLOCATEALL(ID)

  USE ARRAYS							  USE ARRAYS
  IMPLICIT NONE							  IMPLICIT NONE
  INTEGER, INTENT(IN)::ID					  INTEGER, INTENT(IN)::ID
  !  write(*,*) ID						  !  write(*,*) ID
  IF(ALLOCATED(H_IJ)) DEALLOCATE(H_IJ)				  IF(ALLOCATED(H_IJ)) DEALLOCATE(H_IJ)
  IF(ALLOCATED(U_ZEEMAN)) DEALLOCATE(U_ZEEMAN)			  IF(ALLOCATED(U_ZEEMAN)) DEALLOCATE(U_ZEEMAN)
  !  DEALLOCATE(U_RF)						  !  DEALLOCATE(U_RF)
  IF(ALLOCATED(HAMILTONIAN)) DEALLOCATE(HAMILTONIAN)		  IF(ALLOCATED(HAMILTONIAN)) DEALLOCATE(HAMILTONIAN)
  !  DEALLOCATE(H_AUX) 						  !  DEALLOCATE(H_AUX) 
  !  DEALLOCATE(H_RF)						  !  DEALLOCATE(H_RF)
  !  DEALLOCATE(H_RF_DAGGER)					  !  DEALLOCATE(H_RF_DAGGER)
  !  DEALLOCATE(H_MW)						  !  DEALLOCATE(H_MW)
  !  DEALLOCATE(H_ALPHA)					  !  DEALLOCATE(H_ALPHA)
  !  DEALLOCATE(H_ALPHA_DAGGER)					  !  DEALLOCATE(H_ALPHA_DAGGER)

  IF(ALLOCATED(j_x)) DEALLOCATE(j_x)				  IF(ALLOCATED(j_x)) DEALLOCATE(j_x)
  IF(ALLOCATED(j_y)) DEALLOCATE(j_y)				  IF(ALLOCATED(j_y)) DEALLOCATE(j_y)
  IF(ALLOCATED(j_z)) DEALLOCATE(j_z)				  IF(ALLOCATED(j_z)) DEALLOCATE(j_z)
  IF(ALLOCATED(Identity)) DEALLOCATE(Identity)			  IF(ALLOCATED(Identity)) DEALLOCATE(Identity)
  IF(ALLOCATED(H_FLOQUET)) DEALLOCATE(H_FLOQUET)		  IF(ALLOCATED(H_FLOQUET)) DEALLOCATE(H_FLOQUET)
  IF(ALLOCATED(H_FLOQUET_COPY)) DEALLOCATE(H_FLOQUET_COPY)	  IF(ALLOCATED(H_FLOQUET_COPY)) DEALLOCATE(H_FLOQUET_COPY)
  SELECT CASE(ID)						  SELECT CASE(ID)
  CASE(1)							  CASE(1)

  CASE(2)							  CASE(2)

  CASE(3)							  CASE(3)
     !     DEALLOCATE(jz_dash)					     !     DEALLOCATE(jz_dash)
     DEALLOCATE(I_x)						     DEALLOCATE(I_x)
     DEALLOCATE(I_y)						     DEALLOCATE(I_y)
     DEALLOCATE(I_z)						     DEALLOCATE(I_z)
     !     DEALLOCATE(CLEBSH_GORDAN_JtoF)			     !     DEALLOCATE(CLEBSH_GORDAN_JtoF)

     !    DEALLOCATE(g_F_matrix)				     !    DEALLOCATE(g_F_matrix)
     !    DEALLOCATE(Fx)					     !    DEALLOCATE(Fx)
     !    DEALLOCATE(Fy)					     !    DEALLOCATE(Fy)
     !    DEALLOCATE(Fz)					     !    DEALLOCATE(Fz)
     !    DEALLOCATE(Fz_DASH)					     !    DEALLOCATE(Fz_DASH)
     !    DEALLOCATE(Hamiltonian_F)				     !    DEALLOCATE(Hamiltonian_F)
     !    DEALLOCATE(Identity_F)				     !    DEALLOCATE(Identity_F)
     !    DEALLOCATE(F_t)					     !    DEALLOCATE(F_t)
     !    DEALLOCATE(H_w)					     !    DEALLOCATE(H_w)
     !    DEALLOCATE(H_M)					     !    DEALLOCATE(H_M)
     !    DEALLOCATE(H_J)					     !    DEALLOCATE(H_J)
  CASE(4)							  CASE(4)

  CASE(5)							  CASE(5)
     IF(ALLOCATED(j_x)) DEALLOCATE(j_x)				     IF(ALLOCATED(j_x)) DEALLOCATE(j_x)
     IF(ALLOCATED(j_y)) DEALLOCATE(j_y)				     IF(ALLOCATED(j_y)) DEALLOCATE(j_y)
     IF(ALLOCATED(j_z)) DEALLOCATE(j_z)				     IF(ALLOCATED(j_z)) DEALLOCATE(j_z)
  END SELECT							  END SELECT


END SUBROUTINE DEALLOCATEALL					END SUBROUTINE DEALLOCATEALL

MODULE FLOQUETINITINTERFACE					MODULE FLOQUETINITINTERFACE
  INTERFACE FLOQUETINIT						  INTERFACE FLOQUETINIT
     MODULE PROCEDURE FLOQUETINIT_QUBIT, FLOQUETINIT_SPIN,FLO	     MODULE PROCEDURE FLOQUETINIT_QUBIT, FLOQUETINIT_SPIN,FLO
  END INTERFACE FLOQUETINIT					  END INTERFACE FLOQUETINIT
contains							contains
  SUBROUTINE FLOQUETINIT_QUBIT(ID,atomicspecie,INFO)		  SUBROUTINE FLOQUETINIT_QUBIT(ID,atomicspecie,INFO)
    ! ATOMICSPECIE: 87Rb,6Li,Cs,41K,qubit,lattice, SPIN		    ! ATOMICSPECIE: 87Rb,6Li,Cs,41K,qubit,lattice, SPIN
    ! MANIFOLD : "U" UPPER HYPERFINE MANIFOLD, "L" LOWER HYPE	    ! MANIFOLD : "U" UPPER HYPERFINE MANIFOLD, "L" LOWER HYPE
    ! JTOTAL   :  IF ATOMICSPECIE .EQ. SPIN THEN JTOTAL IS TH	    ! JTOTAL   :  IF ATOMICSPECIE .EQ. SPIN THEN JTOTAL IS TH
    !             IF ATOMICSPECIE .EQ. LATTICE, THEN JTOTAL I	    !             IF ATOMICSPECIE .EQ. LATTICE, THEN JTOTAL I
    ! calculate the dimenson of the Hilbert space		    ! calculate the dimenson of the Hilbert space
    ! initialize all the matrices required for a full Floquet	    ! initialize all the matrices required for a full Floquet
    ! Calculate the nuclear, electron and total angular momen	    ! Calculate the nuclear, electron and total angular momen
    								    
    USE physical_constants ! Standard Module with constants	    USE physical_constants ! Standard Module with constants
    USE ATOMIC_PROPERTIES  ! gF, F , etc. factors for several	    USE ATOMIC_PROPERTIES  ! gF, F , etc. factors for several
  USE subinterface       ! To ubroutines for representation o	  USE subinterface       ! To ubroutines for representation o
  USE ARRAYS							  USE ARRAYS
  USE SUBINTERFACE_LAPACK					  USE SUBINTERFACE_LAPACK
  USE TYPES							  USE TYPES
  IMPLICIT NONE							  IMPLICIT NONE
  								  
  TYPE(ATOM),        INTENT(INOUT) :: ID			  TYPE(ATOM),        INTENT(INOUT) :: ID
  CHARACTER (LEN=*), INTENT(IN)    :: ATOMICSPECIE		  CHARACTER (LEN=*), INTENT(IN)    :: ATOMICSPECIE
  INTEGER,           INTENT(INOUT) :: INFO			  INTEGER,           INTENT(INOUT) :: INFO
  								  
  INTEGER  r,D_F2,P,r_,p_					  INTEGER  r,D_F2,P,r_,p_
  DOUBLE PRECISION, DIMENSION(:),ALLOCATABLE:: Energy		  DOUBLE PRECISION, DIMENSION(:),ALLOCATABLE:: Energy

!  write(*,*) atomicspecie,info,id%d_bare			!  write(*,*) atomicspecie,info,id%d_bare
    								    
  INFO = 4							  INFO = 4
  CALL SET_ATOMIC_PARAMETERS(ATOMICSPECIE,'U',0.1D1,ID,INFO)	  CALL SET_ATOMIC_PARAMETERS(ATOMICSPECIE,'U',0.1D1,ID,INFO)
  !------ ALLOCATE NEEDED ARRAYS: Hamiltonian and Lapack	  !------ ALLOCATE NEEDED ARRAYS: Hamiltonian and Lapack
  ALLOCATE(Energy(TOTAL_STATES_LSI))				  ALLOCATE(Energy(TOTAL_STATES_LSI))
  ALLOCATE(H_IJ(Total_states_LSI,Total_states_LSI))		  ALLOCATE(H_IJ(Total_states_LSI,Total_states_LSI))
  ALLOCATE(U_ZEEMAN(Total_states_LSI,Total_states_LSI))		  ALLOCATE(U_ZEEMAN(Total_states_LSI,Total_states_LSI))
  ALLOCATE(HAMILTONIAN(Total_states_LSI,Total_states_LSI))	  ALLOCATE(HAMILTONIAN(Total_states_LSI,Total_states_LSI))
  U_zeeman = 0							  U_zeeman = 0
  								  
  IF(INFO.EQ.2) THEN						  IF(INFO.EQ.2) THEN
     ALLOCATE(j_x(Total_states_LSI,Total_states_LSI))		     ALLOCATE(j_x(Total_states_LSI,Total_states_LSI))
     ALLOCATE(j_y(Total_states_LSI,Total_states_LSI))		     ALLOCATE(j_y(Total_states_LSI,Total_states_LSI))
     ALLOCATE(j_z(Total_states_LSI,Total_states_LSI))		     ALLOCATE(j_z(Total_states_LSI,Total_states_LSI))
     CALL F_REPRESENTATION(j_x,j_y,j_z,0.05D1)			     CALL F_REPRESENTATION(j_x,j_y,j_z,0.05D1)
  END IF							  END IF
  								  
END SUBROUTINE FLOQUETINIT_QUBIT				END SUBROUTINE FLOQUETINIT_QUBIT

SUBROUTINE FLOQUETINIT_SPIN(ID,atomicspecie,jtotal,info)	SUBROUTINE FLOQUETINIT_SPIN(ID,atomicspecie,jtotal,info)
  ! ATOMICSPECIE: 87Rb,6Li,Cs,41K,qubit,lattice, SPIN		  ! ATOMICSPECIE: 87Rb,6Li,Cs,41K,qubit,lattice, SPIN
  ! MANIFOLD : "U" UPPER HYPERFINE MANIFOLD, "L" LOWER HYPERF	  ! MANIFOLD : "U" UPPER HYPERFINE MANIFOLD, "L" LOWER HYPERF
  ! JTOTAL   :  IF ATOMICSPECIE .EQ. SPIN THEN JTOTAL IS THE 	  ! JTOTAL   :  IF ATOMICSPECIE .EQ. SPIN THEN JTOTAL IS THE 
  !             IF ATOMICSPECIE .EQ. LATTICE, THEN JTOTAL IS 	  !             IF ATOMICSPECIE .EQ. LATTICE, THEN JTOTAL IS 


  ! calculate the dimenson of the Hilbert space			  ! calculate the dimenson of the Hilbert space
  ! initialize all the matrices required for a full Floquet c	  ! initialize all the matrices required for a full Floquet c
  ! Calculate the nuclear, electron and total angular momentu	  ! Calculate the nuclear, electron and total angular momentu

  USE physical_constants ! Standard Module with constants	  USE physical_constants ! Standard Module with constants
  USE ATOMIC_PROPERTIES  ! gF, F , etc. factors for several s	  USE ATOMIC_PROPERTIES  ! gF, F , etc. factors for several s
  USE subinterface       ! To ubroutines for representation o	  USE subinterface       ! To ubroutines for representation o
  USE ARRAYS							  USE ARRAYS
  USE SUBINTERFACE_LAPACK					  USE SUBINTERFACE_LAPACK
  USE TYPES							  USE TYPES
  IMPLICIT NONE							  IMPLICIT NONE

  TYPE(ATOM),        INTENT(INOUT) :: ID			  TYPE(ATOM),        INTENT(INOUT) :: ID
  CHARACTER (LEN=*), INTENT(IN)    :: ATOMICSPECIE		  CHARACTER (LEN=*), INTENT(IN)    :: ATOMICSPECIE
  DOUBLE PRECISION,  intent(in)    :: jtotal			  DOUBLE PRECISION,  intent(in)    :: jtotal
  INTEGER,           INTENT(INOUT) :: INFO			  INTEGER,           INTENT(INOUT) :: INFO
  								  
  INTEGER  r,D_F2,P,r_,p_					  INTEGER  r,D_F2,P,r_,p_
  DOUBLE PRECISION, DIMENSION(:),ALLOCATABLE:: Energy		  DOUBLE PRECISION, DIMENSION(:),ALLOCATABLE:: Energy

!  write(*,*) atomicspecie					!  write(*,*) atomicspecie
  INFO = 4							  INFO = 4
  CALL SET_ATOMIC_PARAMETERS(ATOMICSPECIE,'B',JTOTAL,ID,INFO)	  CALL SET_ATOMIC_PARAMETERS(ATOMICSPECIE,'B',JTOTAL,ID,INFO)
  !------ ALLOCATE NEEDED ARRAYS: Hamiltonian and Lapack	  !------ ALLOCATE NEEDED ARRAYS: Hamiltonian and Lapack
  ALLOCATE(Energy(TOTAL_STATES_LSI))				  ALLOCATE(Energy(TOTAL_STATES_LSI))
  ALLOCATE(H_IJ(Total_states_LSI,Total_states_LSI))		  ALLOCATE(H_IJ(Total_states_LSI,Total_states_LSI))
  ALLOCATE(U_ZEEMAN(Total_states_LSI,Total_states_LSI))		  ALLOCATE(U_ZEEMAN(Total_states_LSI,Total_states_LSI))
  ALLOCATE(HAMILTONIAN(Total_states_LSI,Total_states_LSI))	  ALLOCATE(HAMILTONIAN(Total_states_LSI,Total_states_LSI))
  U_zeeman = 0							  U_zeeman = 0
  IF(INFO.EQ.3) THEN						  IF(INFO.EQ.3) THEN
     ALLOCATE(j_x(Total_states_LSI,Total_states_LSI))		     ALLOCATE(j_x(Total_states_LSI,Total_states_LSI))
     ALLOCATE(j_y(Total_states_LSI,Total_states_LSI))		     ALLOCATE(j_y(Total_states_LSI,Total_states_LSI))
     ALLOCATE(j_z(Total_states_LSI,Total_states_LSI))		     ALLOCATE(j_z(Total_states_LSI,Total_states_LSI))
     CALL F_REPRESENTATION(j_x,j_y,j_z,1.0D0*Ftotal)     	     CALL F_REPRESENTATION(j_x,j_y,j_z,1.0D0*Ftotal)     
  ELSE 								  ELSE 
     ALLOCATE(j_x(Total_states_LSI,Total_states_LSI))		     ALLOCATE(j_x(Total_states_LSI,Total_states_LSI))
     ALLOCATE(j_y(Total_states_LSI,Total_states_LSI))		     ALLOCATE(j_y(Total_states_LSI,Total_states_LSI))
     ALLOCATE(j_z(Total_states_LSI,Total_states_LSI))		     ALLOCATE(j_z(Total_states_LSI,Total_states_LSI))
     j_x = 0.0							     j_x = 0.0
     j_y = 0.0							     j_y = 0.0
     j_z = 0.0							     j_z = 0.0
  END IF							  END IF

END SUBROUTINE FLOQUETINIT_SPIN					END SUBROUTINE FLOQUETINIT_SPIN

SUBROUTINE FLOQUETINIT_ALKALI(ID,atomicspecie,manifold,info)	SUBROUTINE FLOQUETINIT_ALKALI(ID,atomicspecie,manifold,info)
  ! ATOMICSPECIE: 87Rb,6Li,Cs,41K,qubit,lattice, SPIN		  ! ATOMICSPECIE: 87Rb,6Li,Cs,41K,qubit,lattice, SPIN
  ! MANIFOLD : "U" UPPER HYPERFINE MANIFOLD, "L" LOWER HYPERF	  ! MANIFOLD : "U" UPPER HYPERFINE MANIFOLD, "L" LOWER HYPERF
  ! JTOTAL   :  IF ATOMICSPECIE .EQ. SPIN THEN JTOTAL IS THE 	  ! JTOTAL   :  IF ATOMICSPECIE .EQ. SPIN THEN JTOTAL IS THE 
  !             IF ATOMICSPECIE .EQ. LATTICE, THEN JTOTAL IS 	  !             IF ATOMICSPECIE .EQ. LATTICE, THEN JTOTAL IS 


  ! calculate the dimenson of the Hilbert space			  ! calculate the dimenson of the Hilbert space
  ! initialize all the matrices required for a full Floquet c	  ! initialize all the matrices required for a full Floquet c
  ! Calculate the nuclear, electron and total angular momentu	  ! Calculate the nuclear, electron and total angular momentu

  USE physical_constants ! Standard Module with constants	  USE physical_constants ! Standard Module with constants
  USE ATOMIC_PROPERTIES  ! gF, F , etc. factors for several s	  USE ATOMIC_PROPERTIES  ! gF, F , etc. factors for several s
  USE subinterface       ! To ubroutines for representation o	  USE subinterface       ! To ubroutines for representation o
  USE ARRAYS							  USE ARRAYS
  USE SUBINTERFACE_LAPACK					  USE SUBINTERFACE_LAPACK
  USE TYPES							  USE TYPES
  IMPLICIT NONE							  IMPLICIT NONE

  TYPE(ATOM),        INTENT(INOUT) :: ID			  TYPE(ATOM),        INTENT(INOUT) :: ID
  CHARACTER (LEN=*), INTENT(IN)    :: ATOMICSPECIE		  CHARACTER (LEN=*), INTENT(IN)    :: ATOMICSPECIE
  CHARACTER (LEN=1), INTENT(IN)    :: MANIFOLD  		  CHARACTER (LEN=1), INTENT(IN)    :: MANIFOLD  
  INTEGER,           INTENT(INOUT) :: INFO			  INTEGER,           INTENT(INOUT) :: INFO
  								  
  INTEGER  r,D_F2,P,r_,p_					  INTEGER  r,D_F2,P,r_,p_
  DOUBLE PRECISION, DIMENSION(:),ALLOCATABLE:: Energy		  DOUBLE PRECISION, DIMENSION(:),ALLOCATABLE:: Energy

!  write(*,*) atomicspecie, ' alkali ', manifold		!  write(*,*) atomicspecie, ' alkali ', manifold
  INFO = 4							  INFO = 4
  CALL SET_ATOMIC_PARAMETERS(ATOMICSPECIE,MANIFOLD,0.2D1,ID,I	  CALL SET_ATOMIC_PARAMETERS(ATOMICSPECIE,MANIFOLD,0.2D1,ID,I
  !------ ALLOCATE NEEDED ARRAYS: Hamiltonian and Lapack	  !------ ALLOCATE NEEDED ARRAYS: Hamiltonian and Lapack
!  write(*,*) total_states_lsi,info				!  write(*,*) total_states_lsi,info
  ALLOCATE(Energy(TOTAL_STATES_LSI))				  ALLOCATE(Energy(TOTAL_STATES_LSI))
  ALLOCATE(H_IJ(Total_states_LSI,Total_states_LSI))		  ALLOCATE(H_IJ(Total_states_LSI,Total_states_LSI))
  ALLOCATE(U_ZEEMAN(Total_states_LSI,Total_states_LSI))		  ALLOCATE(U_ZEEMAN(Total_states_LSI,Total_states_LSI))
  ALLOCATE(HAMILTONIAN(Total_states_LSI,Total_states_LSI))	  ALLOCATE(HAMILTONIAN(Total_states_LSI,Total_states_LSI))
  U_zeeman = 0							  U_zeeman = 0
!  IF(INFO.EQ.1 .AND. PRESENT(MANIFOLD)) THEN			!  IF(INFO.EQ.1 .AND. PRESENT(MANIFOLD)) THEN
     IF(INFO.EQ.1 .AND. MANIFOLD.EQ.'B') THEN			     IF(INFO.EQ.1 .AND. MANIFOLD.EQ.'B') THEN
        ALLOCATE(j_x(Total_states_LSI,Total_states_LSI))	        ALLOCATE(j_x(Total_states_LSI,Total_states_LSI))
        ALLOCATE(j_y(Total_states_LSI,Total_states_LSI))	        ALLOCATE(j_y(Total_states_LSI,Total_states_LSI))
        ALLOCATE(j_z(Total_states_LSI,Total_states_LSI))	        ALLOCATE(j_z(Total_states_LSI,Total_states_LSI))
        ALLOCATE(I_x(Total_states_LSI,Total_states_LSI))	        ALLOCATE(I_x(Total_states_LSI,Total_states_LSI))
        ALLOCATE(I_y(Total_states_LSI,Total_states_LSI))	        ALLOCATE(I_y(Total_states_LSI,Total_states_LSI))
        ALLOCATE(I_z(Total_states_LSI,Total_states_LSI))	        ALLOCATE(I_z(Total_states_LSI,Total_states_LSI))
        j_x           = 0.0					        j_x           = 0.0
        j_y           = 0.0					        j_y           = 0.0
        j_z           = 0.0					        j_z           = 0.0
        I_x           = 0.0					        I_x           = 0.0
        I_y           = 0.0					        I_y           = 0.0
        I_z           = 0.0					        I_z           = 0.0

        !---------------- Build the angular momentum operator	        !---------------- Build the angular momentum operator
        !---------------- in decresing order of m=mI+mJ, with	        !---------------- in decresing order of m=mI+mJ, with
        CALL I_and_J_representations(j_x,j_y,j_z,I_x,I_y,I_z,	        CALL I_and_J_representations(j_x,j_y,j_z,I_x,I_y,I_z,

    ELSE IF(INFO.EQ.1 .AND. MANIFOLD.NE.'B') THEN		    ELSE IF(INFO.EQ.1 .AND. MANIFOLD.NE.'B') THEN
        ALLOCATE(j_x(Total_states_LSI,Total_states_LSI))	        ALLOCATE(j_x(Total_states_LSI,Total_states_LSI))
        ALLOCATE(j_y(Total_states_LSI,Total_states_LSI))	        ALLOCATE(j_y(Total_states_LSI,Total_states_LSI))
        ALLOCATE(j_z(Total_states_LSI,Total_states_LSI))	        ALLOCATE(j_z(Total_states_LSI,Total_states_LSI))
        CALL F_REPRESENTATION(j_x,j_y,j_z,1.0D0*Ftotal)		        CALL F_REPRESENTATION(j_x,j_y,j_z,1.0D0*Ftotal)
     END IF							     END IF
!  END IF							!  END IF

END SUBROUTINE FLOQUETINIT_ALKALI				END SUBROUTINE FLOQUETINIT_ALKALI
END MODULE FLOQUETINITINTERFACE					END MODULE FLOQUETINITINTERFACE


SUBROUTINE SETHAMILTONIANCOMPONENTS(ID,NM,NF,MODES_NUM,FIELD,	SUBROUTINE SETHAMILTONIANCOMPONENTS(ID,NM,NF,MODES_NUM,FIELD,
  ! ID  tYPE OF ATOM						  ! ID  tYPE OF ATOM
  ! MODES_NUM, VECTOR. THE SIZE OF THE VECTOR TELL US THE NUM	  ! MODES_NUM, VECTOR. THE SIZE OF THE VECTOR TELL US THE NUM
  ! FIELDS : IN AND OUTPUT THE MATRICES				  ! FIELDS : IN AND OUTPUT THE MATRICES
  ! INFO							  ! INFO

  USE ARRAYS							  USE ARRAYS
  USE ATOMIC_PROPERTIES						  USE ATOMIC_PROPERTIES
  USE TYPES							  USE TYPES
  USE SUBINTERFACE_LAPACK ! write_matrix interface		  USE SUBINTERFACE_LAPACK ! write_matrix interface

  IMPLICIT NONE							  IMPLICIT NONE
  INTEGER,                   INTENT(IN)    :: NM,NF		  INTEGER,                   INTENT(IN)    :: NM,NF
  TYPE(ATOM),                INTENT(IN)    :: ID		  TYPE(ATOM),                INTENT(IN)    :: ID
  INTEGER,    DIMENSION(NM), INTENT(IN)    :: MODES_NUM		  INTEGER,    DIMENSION(NM), INTENT(IN)    :: MODES_NUM
  TYPE(MODE), DIMENSION(NF), INTENT(INOUT) :: FIELD		  TYPE(MODE), DIMENSION(NF), INTENT(INOUT) :: FIELD
  INTEGER,                   INTENT(INOUT) :: INFO		  INTEGER,                   INTENT(INOUT) :: INFO

  INTEGER m,TOTAL_FREQUENCIES,N_FLOQUET_,KD			  INTEGER m,TOTAL_FREQUENCIES,N_FLOQUET_,KD
  DOUBLE PRECISION, DIMENSION(:),ALLOCATABLE :: mFs		  DOUBLE PRECISION, DIMENSION(:),ALLOCATABLE :: mFs
  DOUBLE PRECISION, DIMENSION(id%d_bare) :: E_ZEEMAN		  DOUBLE PRECISION, DIMENSION(id%d_bare) :: E_ZEEMAN
  DOUBLE PRECISION :: RESONANTrfFREQUENCY			  DOUBLE PRECISION :: RESONANTrfFREQUENCY

  !  WRITE(*,*) "# Setting the Hamiltonian components for a "	  !  WRITE(*,*) "# Setting the Hamiltonian components for a "
  !  WRITE(*,*) "# with ",nm, " modes and ",nf," fields"	  !  WRITE(*,*) "# with ",nm, " modes and ",nf," fields"
  TOTAL_FREQUENCIES = NF					  TOTAL_FREQUENCIES = NF
  !  write(*,*) "# total frequencies:", total_frequencies,ID%	  !  write(*,*) "# total frequencies:", total_frequencies,ID%
  SELECT CASE(ID%id_system)					  SELECT CASE(ID%id_system)
  CASE(3) ! ATOM, BOTH HYPERFINE MANIFOLDS			  CASE(3) ! ATOM, BOTH HYPERFINE MANIFOLDS
     U_ZEEMAN = 0.0						     U_ZEEMAN = 0.0
     DO m=1,TOTAL_FREQUENCIES					     DO m=1,TOTAL_FREQUENCIES
        IF(m.EQ.1) THEN						        IF(m.EQ.1) THEN
           FIELD(m)%V = A*(MATMUL(I_x,J_x) - MATMUL(I_y,J_y) 	           FIELD(m)%V = A*(MATMUL(I_x,J_x) - MATMUL(I_y,J_y) 
                &       mu_B*(g_J*(FIELD(m)%X*EXP(DCMPLX(0.0,	                &       mu_B*(g_J*(FIELD(m)%X*EXP(DCMPLX(0.0,
                & DCMPLX(0.0,-1.0)*FIELD(m)%Y*EXP(DCMPLX(0.0,	                & DCMPLX(0.0,-1.0)*FIELD(m)%Y*EXP(DCMPLX(0.0,
                &                  FIELD(m)%Z*EXP(DCMPLX(0.0,	                &                  FIELD(m)%Z*EXP(DCMPLX(0.0,
                &            (g_I*(FIELD(m)%X*EXP(DCMPLX(0.0,	                &            (g_I*(FIELD(m)%X*EXP(DCMPLX(0.0,
                & DCMPLX(0.0,-1.0)*FIELD(m)%Y*EXP(DCMPLX(0.0,	                & DCMPLX(0.0,-1.0)*FIELD(m)%Y*EXP(DCMPLX(0.0,
                &                  FIELD(m)%Z*EXP(DCMPLX(0.0,	                &                  FIELD(m)%Z*EXP(DCMPLX(0.0,
           FIELD(m)%V = FIELD(m)%V/A				           FIELD(m)%V = FIELD(m)%V/A
           U_ZEEMAN = FIELD(m)%V 				           U_ZEEMAN = FIELD(m)%V 
           CALL LAPACK_FULLEIGENVALUES(U_ZEEMAN,SIZE(FIELD(m)	           CALL LAPACK_FULLEIGENVALUES(U_ZEEMAN,SIZE(FIELD(m)
           FIELD(m)%V = MATMUL(TRANSPOSE(CONJG(U_ZEEMAN)),MAT	           FIELD(m)%V = MATMUL(TRANSPOSE(CONJG(U_ZEEMAN)),MAT
        END IF							        END IF

        IF(m.GT.1) THEN						        IF(m.GT.1) THEN
           FIELD(m)%V = mu_B*(g_J*(FIELD(m)%X*EXP(DCMPLX(0.0,	           FIELD(m)%V = mu_B*(g_J*(FIELD(m)%X*EXP(DCMPLX(0.0,
                & DCMPLX(0.0,-1.0)*FIELD(m)%Y*EXP(DCMPLX(0.0,	                & DCMPLX(0.0,-1.0)*FIELD(m)%Y*EXP(DCMPLX(0.0,
                &                  FIELD(m)%Z*EXP(DCMPLX(0.0,	                &                  FIELD(m)%Z*EXP(DCMPLX(0.0,
                &            (g_I*(FIELD(m)%X*EXP(DCMPLX(0.0,	                &            (g_I*(FIELD(m)%X*EXP(DCMPLX(0.0,
                & DCMPLX(0.0,-1.0)*FIELD(m)%Y*EXP(DCMPLX(0.0,	                & DCMPLX(0.0,-1.0)*FIELD(m)%Y*EXP(DCMPLX(0.0,
                &                  FIELD(m)%Z*EXP(DCMPLX(0.0,	                &                  FIELD(m)%Z*EXP(DCMPLX(0.0,
           FIELD(m)%V = FIELD(m)%V/A				           FIELD(m)%V = FIELD(m)%V/A
           FIELD(m)%V = MATMUL(TRANSPOSE(CONJG(U_ZEEMAN)),MAT	           FIELD(m)%V = MATMUL(TRANSPOSE(CONJG(U_ZEEMAN)),MAT
        END IF							        END IF
     END DO							     END DO

     KD = SIZE(U_ZEEMAN,1)					     KD = SIZE(U_ZEEMAN,1)
     DO m=2,TOTAL_FREQUENCIES-1					     DO m=2,TOTAL_FREQUENCIES-1
        N_FLOQUET_  = MODES_NUM(m)				        N_FLOQUET_  = MODES_NUM(m)
        KD = KD*(2*N_FLOQUET_+1)				        KD = KD*(2*N_FLOQUET_+1)
     END DO							     END DO
     KD = KD + SIZE(U_ZEEMAN,1) - 1				     KD = KD + SIZE(U_ZEEMAN,1) - 1

  CASE(7) ! ONE DIMENSIONAL TIGHT BINDING LATTICE		  CASE(7) ! ONE DIMENSIONAL TIGHT BINDING LATTICE

  CASE(8) ! TWO-DIMENSIONAL TIGHT BINDING LATTICE		  CASE(8) ! TWO-DIMENSIONAL TIGHT BINDING LATTICE

  CASE DEFAULT ! alkali ATOM with ONE MANIFOLD, QUBIT, SPIN	  CASE DEFAULT ! alkali ATOM with ONE MANIFOLD, QUBIT, SPIN

     U_ZEEMAN = 0.0						     U_ZEEMAN = 0.0
     DO m=1,TOTAL_FREQUENCIES					     DO m=1,TOTAL_FREQUENCIES
        IF(m.EQ.1) THEN						        IF(m.EQ.1) THEN
           FIELD(m)%V =            (FIELD(m)%X*EXP(DCMPLX(0.0	           FIELD(m)%V =            (FIELD(m)%X*EXP(DCMPLX(0.0
                &  DCMPLX(0.0,-1.0)*FIELD(m)%Y*EXP(DCMPLX(0.0	                &  DCMPLX(0.0,-1.0)*FIELD(m)%Y*EXP(DCMPLX(0.0
                FIELD(m)%Z*EXP(DCMPLX(0.0,1.0)*FIELD(m)%phi_z	                FIELD(m)%Z*EXP(DCMPLX(0.0,1.0)*FIELD(m)%phi_z
           U_ZEEMAN   = FIELD(m)%V 				           U_ZEEMAN   = FIELD(m)%V 
           CALL LAPACK_FULLEIGENVALUES(U_ZEEMAN,SIZE(FIELD(m)	           CALL LAPACK_FULLEIGENVALUES(U_ZEEMAN,SIZE(FIELD(m)
        END IF							        END IF

        IF(m.GT.1) THEN						        IF(m.GT.1) THEN
           FIELD(m)%V =            (FIELD(m)%X*EXP(DCMPLX(0.0	           FIELD(m)%V =            (FIELD(m)%X*EXP(DCMPLX(0.0
                &  DCMPLX(0.0,-1.0)*FIELD(m)%Y*EXP(DCMPLX(0.0	                &  DCMPLX(0.0,-1.0)*FIELD(m)%Y*EXP(DCMPLX(0.0
                FIELD(m)%Z*EXP(DCMPLX(0.0,1.0)*FIELD(m)%phi_z	                FIELD(m)%Z*EXP(DCMPLX(0.0,1.0)*FIELD(m)%phi_z
           FIELD(m)%V = MATMUL(TRANSPOSE(CONJG(U_ZEEMAN)),MAT	           FIELD(m)%V = MATMUL(TRANSPOSE(CONJG(U_ZEEMAN)),MAT
           !           write(*,*) m, field(m)%X			           !           write(*,*) m, field(m)%X

        END IF							        END IF
     END DO							     END DO
     KD = SIZE(U_ZEEMAN,1)					     KD = SIZE(U_ZEEMAN,1)
     DO m=2,TOTAL_FREQUENCIES-1					     DO m=2,TOTAL_FREQUENCIES-1
        N_FLOQUET_  = MODES_NUM(m)				        N_FLOQUET_  = MODES_NUM(m)
        KD = KD*(2*N_FLOQUET_+1)				        KD = KD*(2*N_FLOQUET_+1)
     END DO							     END DO
     KD = KD + SIZE(U_ZEEMAN,1) - 1				     KD = KD + SIZE(U_ZEEMAN,1) - 1

  END SELECT							  END SELECT

END SUBROUTINE SETHAMILTONIANCOMPONENTS				END SUBROUTINE SETHAMILTONIANCOMPONENTS


SUBROUTINE FLOQUETINIT_OLD(ID,jtotal,manifold,atomicspecie)	SUBROUTINE FLOQUETINIT_OLD(ID,jtotal,manifold,atomicspecie)
  ! ATOMICSPECIE: 87Rb,6Li,Cs,41K,qubit,lattice, SPIN		  ! ATOMICSPECIE: 87Rb,6Li,Cs,41K,qubit,lattice, SPIN
  ! MANIFOLD : "U" UPPER HYPERFINE MANIFOLD, "L" LOWER HYPERF	  ! MANIFOLD : "U" UPPER HYPERFINE MANIFOLD, "L" LOWER HYPERF
  ! JTOTAL   :  IF ATOMICSPECIE .EQ. SPIN THEN JTOTAL IS THE 	  ! JTOTAL   :  IF ATOMICSPECIE .EQ. SPIN THEN JTOTAL IS THE 
  !             IF ATOMICSPECIE .EQ. LATTICE, THEN JTOTAL IS 	  !             IF ATOMICSPECIE .EQ. LATTICE, THEN JTOTAL IS 


  ! calculate the dimenson of the Hilbert space			  ! calculate the dimenson of the Hilbert space
  ! initialize all the matrices required for a full Floquet c	  ! initialize all the matrices required for a full Floquet c
  ! Calculate the nuclear, electron and total angular momentu	  ! Calculate the nuclear, electron and total angular momentu

  USE physical_constants ! Standard Module with constants	  USE physical_constants ! Standard Module with constants
  USE ATOMIC_PROPERTIES  ! gF, F , etc. factors for several s	  USE ATOMIC_PROPERTIES  ! gF, F , etc. factors for several s
  USE subinterface       ! To ubroutines for representation o	  USE subinterface       ! To ubroutines for representation o
  USE ARRAYS							  USE ARRAYS
  USE SUBINTERFACE_LAPACK					  USE SUBINTERFACE_LAPACK
  USE TYPES							  USE TYPES
  IMPLICIT NONE							  IMPLICIT NONE

  TYPE(ATOM),        INTENT(INOUT)       :: ID			  TYPE(ATOM),        INTENT(INOUT)       :: ID
  CHARACTER (LEN=*), INTENT(IN),optional :: ATOMICSPECIE	  CHARACTER (LEN=*), INTENT(IN),optional :: ATOMICSPECIE
  !integer, intent(in),optional :: jtotal			  !integer, intent(in),optional :: jtotal
    DOUBLE PRECISION,  INTENT(IN),optional :: JTOTAL		    DOUBLE PRECISION,  INTENT(IN),optional :: JTOTAL
  CHARACTER (LEN=1), INTENT(IN),optional :: MANIFOLD  		  CHARACTER (LEN=1), INTENT(IN),optional :: MANIFOLD  
  ! INTEGER,           INTENT(INOUT)       :: INFO		  ! INTEGER,           INTENT(INOUT)       :: INFO
  								  
  INTEGER  r,D_F2,P,r_,p_,info					  INTEGER  r,D_F2,P,r_,p_,info
  DOUBLE PRECISION, DIMENSION(:),ALLOCATABLE:: Energy		  DOUBLE PRECISION, DIMENSION(:),ALLOCATABLE:: Energy

  INFO = 4							  INFO = 4
  IF( PRESENT(ATOMICSPECIE) .AND. PRESENT(MANIFOLD) .AND. PRE	  IF( PRESENT(ATOMICSPECIE) .AND. PRESENT(MANIFOLD) .AND. PRE
     CALL SET_ATOMIC_PARAMETERS(ATOMICSPECIE,MANIFOLD,JTOTAL,	     CALL SET_ATOMIC_PARAMETERS(ATOMICSPECIE,MANIFOLD,JTOTAL,
  ELSE IF( PRESENT(ATOMICSPECIE) .AND. PRESENT(JTOTAL)) THEN	  ELSE IF( PRESENT(ATOMICSPECIE) .AND. PRESENT(JTOTAL)) THEN
     CALL SET_ATOMIC_PARAMETERS(ATOMICSPECIE,'B',JTOTAL,ID,IN	     CALL SET_ATOMIC_PARAMETERS(ATOMICSPECIE,'B',JTOTAL,ID,IN
  ELSE IF(PRESENT(ATOMICSPECIE) .AND. PRESENT(MANIFOLD)) THEN	  ELSE IF(PRESENT(ATOMICSPECIE) .AND. PRESENT(MANIFOLD)) THEN
     CALL SET_ATOMIC_PARAMETERS(ATOMICSPECIE,MANIFOLD,0.2D1,I	     CALL SET_ATOMIC_PARAMETERS(ATOMICSPECIE,MANIFOLD,0.2D1,I
  ELSE IF (PRESENT(ATOMICSPECIE)) THEN 				  ELSE IF (PRESENT(ATOMICSPECIE)) THEN 
     CALL SET_ATOMIC_PARAMETERS(ATOMICSPECIE,'U',0.1D1,ID,INF	     CALL SET_ATOMIC_PARAMETERS(ATOMICSPECIE,'U',0.1D1,ID,INF
  END IF							  END IF
  !------ ALLOCATE NEEDED ARRAYS: Hamiltonian and Lapack	  !------ ALLOCATE NEEDED ARRAYS: Hamiltonian and Lapack
  ALLOCATE(Energy(TOTAL_STATES_LSI))				  ALLOCATE(Energy(TOTAL_STATES_LSI))
  ALLOCATE(H_IJ(Total_states_LSI,Total_states_LSI))		  ALLOCATE(H_IJ(Total_states_LSI,Total_states_LSI))
  ALLOCATE(U_ZEEMAN(Total_states_LSI,Total_states_LSI))		  ALLOCATE(U_ZEEMAN(Total_states_LSI,Total_states_LSI))
  !  ALLOCATE(U_RF(Total_states_LSI,Total_states_LSI))		  !  ALLOCATE(U_RF(Total_states_LSI,Total_states_LSI))
  ALLOCATE(HAMILTONIAN(Total_states_LSI,Total_states_LSI))	  ALLOCATE(HAMILTONIAN(Total_states_LSI,Total_states_LSI))
  !  ALLOCATE(H_AUX(Total_states_LSI,Total_states_LSI)) 	  !  ALLOCATE(H_AUX(Total_states_LSI,Total_states_LSI)) 
  !  ALLOCATE(H_RF(Total_states_LSI,Total_states_LSI))		  !  ALLOCATE(H_RF(Total_states_LSI,Total_states_LSI))
  !  ALLOCATE(H_RF_DAGGER(Total_states_LSI,Total_states_LSI))	  !  ALLOCATE(H_RF_DAGGER(Total_states_LSI,Total_states_LSI))
  !  ALLOCATE(H_MW(Total_states_LSI,Total_states_LSI))		  !  ALLOCATE(H_MW(Total_states_LSI,Total_states_LSI))
  !  ALLOCATE(H_ALPHA(Total_states_LSI,Total_states_LSI))	  !  ALLOCATE(H_ALPHA(Total_states_LSI,Total_states_LSI))
  !  ALLOCATE(H_ALPHA_DAGGER(Total_states_LSI,Total_states_LS	  !  ALLOCATE(H_ALPHA_DAGGER(Total_states_LSI,Total_states_LS
  !  write(*,*) "Floquet inint says:", total_states_lsi		  !  write(*,*) "Floquet inint says:", total_states_lsi
  U_zeeman = 0							  U_zeeman = 0
  !  write(*,*) real(u_zeeman(1,8))				  !  write(*,*) real(u_zeeman(1,8))
  !  call write_matrix(abs(u_zeeman)) 				  !  call write_matrix(abs(u_zeeman)) 
  IF(INFO.EQ.1 .AND. PRESENT(MANIFOLD)) THEN			  IF(INFO.EQ.1 .AND. PRESENT(MANIFOLD)) THEN
     IF(INFO.EQ.1 .AND. MANIFOLD.EQ.'B') THEN			     IF(INFO.EQ.1 .AND. MANIFOLD.EQ.'B') THEN
        ALLOCATE(j_x(Total_states_LSI,Total_states_LSI))	        ALLOCATE(j_x(Total_states_LSI,Total_states_LSI))
        ALLOCATE(j_y(Total_states_LSI,Total_states_LSI))	        ALLOCATE(j_y(Total_states_LSI,Total_states_LSI))
        ALLOCATE(j_z(Total_states_LSI,Total_states_LSI))	        ALLOCATE(j_z(Total_states_LSI,Total_states_LSI))
        !ALLOCATE(jz_dash(Total_states_LSI,Total_states_LSI))	        !ALLOCATE(jz_dash(Total_states_LSI,Total_states_LSI))
        ALLOCATE(I_x(Total_states_LSI,Total_states_LSI))	        ALLOCATE(I_x(Total_states_LSI,Total_states_LSI))
        ALLOCATE(I_y(Total_states_LSI,Total_states_LSI))	        ALLOCATE(I_y(Total_states_LSI,Total_states_LSI))
        ALLOCATE(I_z(Total_states_LSI,Total_states_LSI))	        ALLOCATE(I_z(Total_states_LSI,Total_states_LSI))
        !ALLOCATE(CLEBSH_GORDAN_JtoF(Total_states_LSI,Total_s	        !ALLOCATE(CLEBSH_GORDAN_JtoF(Total_states_LSI,Total_s
        j_x           = 0.0					        j_x           = 0.0
        j_y           = 0.0					        j_y           = 0.0
        j_z           = 0.0					        j_z           = 0.0
        I_x           = 0.0					        I_x           = 0.0
        I_y           = 0.0					        I_y           = 0.0
        I_z           = 0.0					        I_z           = 0.0
        !CLEBSH_GORDAN_JtoF = 0.0				        !CLEBSH_GORDAN_JtoF = 0.0

        !---------------- Build the angular momentum operator	        !---------------- Build the angular momentum operator
        !---------------- in decresing order of m=mI+mJ, with	        !---------------- in decresing order of m=mI+mJ, with
        CALL I_and_J_representations(j_x,j_y,j_z,I_x,I_y,I_z,	        CALL I_and_J_representations(j_x,j_y,j_z,I_x,I_y,I_z,

!!$        !(BECAUSE SOME ROUTINES ARE WRITEN IN THE F BASIS,	!!$        !(BECAUSE SOME ROUTINES ARE WRITEN IN THE F BASIS,
!!$        ALLOCATE(g_F_matrix(Total_states_LSI,Total_states_	!!$        ALLOCATE(g_F_matrix(Total_states_LSI,Total_states_
!!$        ALLOCATE(Fx(Total_states_LSI,Total_states_LSI))	!!$        ALLOCATE(Fx(Total_states_LSI,Total_states_LSI))
!!$        ALLOCATE(Fy(Total_states_LSI,Total_states_LSI))	!!$        ALLOCATE(Fy(Total_states_LSI,Total_states_LSI))
!!$        ALLOCATE(Fz(Total_states_LSI,Total_states_LSI))	!!$        ALLOCATE(Fz(Total_states_LSI,Total_states_LSI))
!!$        ALLOCATE(Fz_DASH(Total_states_LSI,Total_states_LSI	!!$        ALLOCATE(Fz_DASH(Total_states_LSI,Total_states_LSI
!!$        ALLOCATE(Hamiltonian_F(Total_states_LSI,Total_stat	!!$        ALLOCATE(Hamiltonian_F(Total_states_LSI,Total_stat
!!$        ALLOCATE(Identity_F(Total_states_LSI,Total_states_	!!$        ALLOCATE(Identity_F(Total_states_LSI,Total_states_
!!$        ALLOCATE(F_t(Total_states_LSI,Total_states_LSI))	!!$        ALLOCATE(F_t(Total_states_LSI,Total_states_LSI))
!!$        ALLOCATE(H_w(Total_states_LSI,Total_states_LSI))	!!$        ALLOCATE(H_w(Total_states_LSI,Total_states_LSI))
!!$        ALLOCATE(H_M(Total_states_LSI,Total_states_LSI))	!!$        ALLOCATE(H_M(Total_states_LSI,Total_states_LSI))
!!$        ALLOCATE(H_J(Total_states_LSI,Total_states_LSI))	!!$        ALLOCATE(H_J(Total_states_LSI,Total_states_LSI))
!!$        Hamiltonian_F = 0.0					!!$        Hamiltonian_F = 0.0
!!$        Fx            = 0.0					!!$        Fx            = 0.0
!!$        Fy            = 0.0					!!$        Fy            = 0.0
!!$        Fz            = 0.0					!!$        Fz            = 0.0
!!$        F_t           = 0					!!$        F_t           = 0
!!$        Identity_F = 0.0					!!$        Identity_F = 0.0
!!$        DO r=1,SIZE(Identity_F,1)				!!$        DO r=1,SIZE(Identity_F,1)
!!$           Identity_F(r,r) = 1.0				!!$           Identity_F(r,r) = 1.0
!!$        END DO						!!$        END DO
!!$								!!$
!!$								!!$
!!$        !CALL WRITE_MATRIX(j_x)				!!$        !CALL WRITE_MATRIX(j_x)
!!$        !  CALL WRITE_MATRIX(j_y)				!!$        !  CALL WRITE_MATRIX(j_y)
!!$        !  CALL WRITE_MATRIX(j_z)				!!$        !  CALL WRITE_MATRIX(j_z)
!!$        !							!!$        !
!!$        !  CALL WRITE_MATRIX(I_x)				!!$        !  CALL WRITE_MATRIX(I_x)
!!$        !  CALL WRITE_MATRIX(I_y)				!!$        !  CALL WRITE_MATRIX(I_y)
!!$        !  CALL WRITE_MATRIX(I_z)				!!$        !  CALL WRITE_MATRIX(I_z)
!!$        !  CALL IJtoF_Matrix(L,S,I,INT(Total_states_LSI),C	!!$        !  CALL IJtoF_Matrix(L,S,I,INT(Total_states_LSI),C
!!$        !CALL F_representation(Fx,Fy,Fz,Ftotal)		!!$        !CALL F_representation(Fx,Fy,Fz,Ftotal)
!!$								!!$
!!$        Fx = J_x+I_x						!!$        Fx = J_x+I_x
!!$        Fy = J_y+I_y						!!$        Fy = J_y+I_y
!!$        Fz = J_z+I_z						!!$        Fz = J_z+I_z
!!$								!!$
!!$        !  CALL WRITE_MATRIX(J_Z+I_Z)			!!$        !  CALL WRITE_MATRIX(J_Z+I_Z)
!!$								!!$
!!$        !IF(TOTAL_STATES_LSI.EQ.8) THEN			!!$        !IF(TOTAL_STATES_LSI.EQ.8) THEN
!!$        F_t = 0						!!$        F_t = 0
!!$        DO r=1,2*Fdown+1					!!$        DO r=1,2*Fdown+1
!!$           F_t(r,r) = 1					!!$           F_t(r,r) = 1
!!$        END DO						!!$        END DO
!!$        DO r=2*Fdown+1,total_states_lsi			!!$        DO r=2*Fdown+1,total_states_lsi
!!$           F_t(r,r) = -1					!!$           F_t(r,r) = -1
!!$        END DO						!!$        END DO
!!$        !END IF						!!$        !END IF
!!$								!!$
!!$								!!$
!!$        !IF(TOTAL_STATES_LSI.EQ.8) THEN			!!$        !IF(TOTAL_STATES_LSI.EQ.8) THEN
!!$        g_F_matrix = 0					!!$        g_F_matrix = 0
!!$        DO r=1,2*Fdown+1					!!$        DO r=1,2*Fdown+1
!!$           g_F_matrix(r,r) = gF_1				!!$           g_F_matrix(r,r) = gF_1
!!$        END DO						!!$        END DO
!!$        DO r=2*Fdown+1,total_states_lsi			!!$        DO r=2*Fdown+1,total_states_lsi
!!$           g_F_matrix(r,r) = gF_2				!!$           g_F_matrix(r,r) = gF_2
!!$        END DO						!!$        END DO
!!$        !END IF						!!$        !END IF
!!$								!!$
!!$        HAMILTONIAN_F = 0.00001*(g_J*J_z+g_I*I_z) + 2*(MAT	!!$        HAMILTONIAN_F = 0.00001*(g_J*J_z+g_I*I_z) + 2*(MAT
!!$								!!$
!!$        CALL LAPACK_FULLEIGENVALUES(HAMILTONIAN_F,TOTAL_ST	!!$        CALL LAPACK_FULLEIGENVALUES(HAMILTONIAN_F,TOTAL_ST
!!$								!!$
!!$        Fx=MATMUL(TRANSPOSE(CONJG(HAMILTONIAN_F)),MATMUL(F	!!$        Fx=MATMUL(TRANSPOSE(CONJG(HAMILTONIAN_F)),MATMUL(F
!!$        Fy=MATMUL(TRANSPOSE(CONJG(HAMILTONIAN_F)),MATMUL(F	!!$        Fy=MATMUL(TRANSPOSE(CONJG(HAMILTONIAN_F)),MATMUL(F
!!$        Fz=MATMUL(TRANSPOSE(CONJG(HAMILTONIAN_F)),MATMUL(F	!!$        Fz=MATMUL(TRANSPOSE(CONJG(HAMILTONIAN_F)),MATMUL(F
!!$        H_IJ = MATMUL(I_X,J_X)+MATMUL(I_Z,J_Z)-MATMUL(I_Y,	!!$        H_IJ = MATMUL(I_X,J_X)+MATMUL(I_Z,J_Z)-MATMUL(I_Y,
!!$        H_IJ=MATMUL(TRANSPOSE(CONJG(HAMILTONIAN_F)),MATMUL	!!$        H_IJ=MATMUL(TRANSPOSE(CONJG(HAMILTONIAN_F)),MATMUL
!!$								!!$
!!$        DO r=1,TOTAL_STATES_lsi				!!$        DO r=1,TOTAL_STATES_lsi
!!$           DO P=1,TOTAL_STATES_lsi				!!$           DO P=1,TOTAL_STATES_lsi
!!$              IF(ABS(HAMILTONIAN_F(r,p)).LT.1E-2) HAMILTON	!!$              IF(ABS(HAMILTONIAN_F(r,p)).LT.1E-2) HAMILTON
!!$              IF(ABS(H_IJ(r,p)).LT.1E-2) H_IJ(r,p) = 0.0	!!$              IF(ABS(H_IJ(r,p)).LT.1E-2) H_IJ(r,p) = 0.0
!!$              IF(ABS(Fx(r,p)).LT.1E-2) Fx(r,p) = 0.0		!!$              IF(ABS(Fx(r,p)).LT.1E-2) Fx(r,p) = 0.0
!!$              IF(ABS(Fy(r,p)).LT.1E-2) Fy(r,p) = 0.0		!!$              IF(ABS(Fy(r,p)).LT.1E-2) Fy(r,p) = 0.0
!!$              IF(ABS(Fz(r,p)).LT.1E-2) Fz(r,p) = 0.0		!!$              IF(ABS(Fz(r,p)).LT.1E-2) Fz(r,p) = 0.0
!!$           END DO						!!$           END DO
!!$        END DO						!!$        END DO
!!$        CLEBSH_GORDAN_JtoF = real(HAMILTONIAN_F)		!!$        CLEBSH_GORDAN_JtoF = real(HAMILTONIAN_F)
!!$								!!$
!!$        ! CALL WRITE_MATRIX(FZ)				!!$        ! CALL WRITE_MATRIX(FZ)
!!$								!!$
!!$        DO r=1,TOTAL_STATES_LSI				!!$        DO r=1,TOTAL_STATES_LSI
!!$           IF(r.le.2*Fdown+1) r_ = -(r-2)			!!$           IF(r.le.2*Fdown+1) r_ = -(r-2)
!!$           IF(r.gt.2*Fdown+1) r_ =   r-6			!!$           IF(r.gt.2*Fdown+1) r_ =   r-6
!!$           DO p=1,TOTAL_STATES_LSI				!!$           DO p=1,TOTAL_STATES_LSI
!!$              IF(p.le.2*Fdown+1) p_ = -(p-2)			!!$              IF(p.le.2*Fdown+1) p_ = -(p-2)
!!$              IF(p.gt.2*Fdown+1) p_ =   p-6			!!$              IF(p.gt.2*Fdown+1) p_ =   p-6
!!$              H_W(r,p) = r_ - p_        			!!$              H_W(r,p) = r_ - p_        
!!$           END DO						!!$           END DO
!!$        END DO						!!$        END DO
!!$								!!$
!!$        Fz_dash = 0.0					!!$        Fz_dash = 0.0
!!$        DO r=1,TOTAL_STATES_LSI				!!$        DO r=1,TOTAL_STATES_LSI
!!$           ! DC DRESSED HAMILTONIAN IN A FRAME OF REFERENC	!!$           ! DC DRESSED HAMILTONIAN IN A FRAME OF REFERENC
!!$           FZ_DASH(r,r) = int(g_F_matrix(r,r)/abs(g_F_matr	!!$           FZ_DASH(r,r) = int(g_F_matrix(r,r)/abs(g_F_matr
!!$        END DO						!!$        END DO
!!$        !  CALL WRITE_MATRIX(1.0D0*(Fz))			!!$        !  CALL WRITE_MATRIX(1.0D0*(Fz))
!!$        !  CALL WRITE_MATRIX(1.0D0*(Fz_dash))		!!$        !  CALL WRITE_MATRIX(1.0D0*(Fz_dash))
!!$        !  WRITE(*,*) Fz(3,3),Fz_dash(3,3)			!!$        !  WRITE(*,*) Fz(3,3),Fz_dash(3,3)
!!$								!!$
!!$        DO r=1,TOTAL_STATES_LSI				!!$        DO r=1,TOTAL_STATES_LSI
!!$           IF(r.le.2*Fdown+1) r_ = (r-Fdown)			!!$           IF(r.le.2*Fdown+1) r_ = (r-Fdown)
!!$           IF(r.gt.2*Fdown+1) r_ =  r-(2*Fdown+1 + Fup + 1	!!$           IF(r.gt.2*Fdown+1) r_ =  r-(2*Fdown+1 + Fup + 1
!!$           DO p=1,TOTAL_STATES_LSI				!!$           DO p=1,TOTAL_STATES_LSI
!!$              IF(p.le.2*Fdown+1) p_ = (p-Fdown)		!!$              IF(p.le.2*Fdown+1) p_ = (p-Fdown)
!!$              IF(p.gt.2*Fdown+1) p_ =  p-(2*Fdown+1 + Fup 	!!$              IF(p.gt.2*Fdown+1) p_ =  p-(2*Fdown+1 + Fup 
!!$              H_M(p,r) = p_ - r_        			!!$              H_M(p,r) = p_ - r_        
!!$              !        write(*,*) p,r,Fz_dash(p,p) , Fz_da	!!$              !        write(*,*) p,r,Fz_dash(p,p) , Fz_da
!!$              !        H_M(p,r) = Fz_dash(p,p) - Fz_dash(r	!!$              !        H_M(p,r) = Fz_dash(p,p) - Fz_dash(r
!!$           END DO						!!$           END DO
!!$        END DO						!!$        END DO
!!$								!!$
!!$        !  CALL WRITE_MATRIX(1.0D0*H_M)			!!$        !  CALL WRITE_MATRIX(1.0D0*H_M)
!!$								!!$
!!$        Jz_dash = 0.0					!!$        Jz_dash = 0.0
!!$								!!$
!!$        DO r=1,TOTAL_STATES_LSI  				!!$        DO r=1,TOTAL_STATES_LSI  
!!$           Jz_dash(r,r) = INT(g_F_matrix(r,r)/abs(g_F_matr	!!$           Jz_dash(r,r) = INT(g_F_matrix(r,r)/abs(g_F_matr
!!$        END DO						!!$        END DO
!!$								!!$
!!$        !  CALL WRITE_MATRIX(1.0D0*(Jz_DASH))		!!$        !  CALL WRITE_MATRIX(1.0D0*(Jz_DASH))
!!$        DO r=1,TOTAL_STATES_LSI				!!$        DO r=1,TOTAL_STATES_LSI
!!$           !     IF(r.le.3) r_ = (r-2)			!!$           !     IF(r.le.3) r_ = (r-2)
!!$           !     IF(r.gt.3) r_ =  r-6			!!$           !     IF(r.gt.3) r_ =  r-6
!!$           DO p=1,TOTAL_STATES_LSI				!!$           DO p=1,TOTAL_STATES_LSI
!!$              !        IF(p.le.3) p_ = (p-2)			!!$              !        IF(p.le.3) p_ = (p-2)
!!$              !        IF(p.gt.3) p_ =  p-6			!!$              !        IF(p.gt.3) p_ =  p-6
!!$              !        H_M(p,r) = p_ - r_        		!!$              !        H_M(p,r) = p_ - r_        
!!$              H_J(p,r) = Jz_dash(p,p) - Jz_dash(r,r)  	!!$              H_J(p,r) = Jz_dash(p,p) - Jz_dash(r,r)  
!!$           END DO						!!$           END DO
!!$        END DO						!!$        END DO
!!$								!!$
!!$        !  CALL WRITE_MATRIX(1.0D0*H_J)			!!$        !  CALL WRITE_MATRIX(1.0D0*H_J)
!!$        !  CALL write_MATRIX(MATMUL(TRANSPOSE(CLEBSH_GORDA	!!$        !  CALL write_MATRIX(MATMUL(TRANSPOSE(CLEBSH_GORDA
!!$        !  CALL write_MATRIX(MATMUL(CLEBSH_GORDAN_JtoF,TRA	!!$        !  CALL write_MATRIX(MATMUL(CLEBSH_GORDAN_JtoF,TRA
!!$  CALL WRITE_MATRIX(CLEBSH_GORDAN_JtoF)			!!$  CALL WRITE_MATRIX(CLEBSH_GORDAN_JtoF)
!!$  CALL WRITE_MATRIX(Fx)					!!$  CALL WRITE_MATRIX(Fx)
!!$  CALL WRITE_MATRIX(Fy)					!!$  CALL WRITE_MATRIX(Fy)
!!$  call WRITE_MATRIX(Fz)					!!$  call WRITE_MATRIX(Fz)
!!$  CALL WRITE_MATRIX(real(H_IJ))				!!$  CALL WRITE_MATRIX(real(H_IJ))
    ELSE IF(INFO.EQ.1 .AND. MANIFOLD.NE.'B') THEN		    ELSE IF(INFO.EQ.1 .AND. MANIFOLD.NE.'B') THEN
        ALLOCATE(j_x(Total_states_LSI,Total_states_LSI))	        ALLOCATE(j_x(Total_states_LSI,Total_states_LSI))
        ALLOCATE(j_y(Total_states_LSI,Total_states_LSI))	        ALLOCATE(j_y(Total_states_LSI,Total_states_LSI))
        ALLOCATE(j_z(Total_states_LSI,Total_states_LSI))	        ALLOCATE(j_z(Total_states_LSI,Total_states_LSI))
        CALL F_REPRESENTATION(j_x,j_y,j_z,1.0D0*Ftotal)		        CALL F_REPRESENTATION(j_x,j_y,j_z,1.0D0*Ftotal)
     END IF							     END IF
  END IF							  END IF

  IF(INFO.EQ.2) THEN						  IF(INFO.EQ.2) THEN
     ALLOCATE(j_x(Total_states_LSI,Total_states_LSI))		     ALLOCATE(j_x(Total_states_LSI,Total_states_LSI))
     ALLOCATE(j_y(Total_states_LSI,Total_states_LSI))		     ALLOCATE(j_y(Total_states_LSI,Total_states_LSI))
     ALLOCATE(j_z(Total_states_LSI,Total_states_LSI))		     ALLOCATE(j_z(Total_states_LSI,Total_states_LSI))
     CALL F_REPRESENTATION(j_x,j_y,j_z,0.05D1)			     CALL F_REPRESENTATION(j_x,j_y,j_z,0.05D1)
  ELSE IF(INFO.EQ.3) THEN					  ELSE IF(INFO.EQ.3) THEN
     ALLOCATE(j_x(Total_states_LSI,Total_states_LSI))		     ALLOCATE(j_x(Total_states_LSI,Total_states_LSI))
     ALLOCATE(j_y(Total_states_LSI,Total_states_LSI))		     ALLOCATE(j_y(Total_states_LSI,Total_states_LSI))
     ALLOCATE(j_z(Total_states_LSI,Total_states_LSI))		     ALLOCATE(j_z(Total_states_LSI,Total_states_LSI))
     CALL F_REPRESENTATION(j_x,j_y,j_z,1.0D0*Ftotal)     	     CALL F_REPRESENTATION(j_x,j_y,j_z,1.0D0*Ftotal)     
  ELSE IF(INFO.EQ.4) THEN					  ELSE IF(INFO.EQ.4) THEN
  ELSE IF(INFO.EQ.5) THEN					  ELSE IF(INFO.EQ.5) THEN
     ALLOCATE(j_x(Total_states_LSI,Total_states_LSI))		     ALLOCATE(j_x(Total_states_LSI,Total_states_LSI))
     ALLOCATE(j_y(Total_states_LSI,Total_states_LSI))		     ALLOCATE(j_y(Total_states_LSI,Total_states_LSI))
     ALLOCATE(j_z(Total_states_LSI,Total_states_LSI))		     ALLOCATE(j_z(Total_states_LSI,Total_states_LSI))
  END IF							  END IF

END SUBROUTINE FLOQUETINIT_OLD					END SUBROUTINE FLOQUETINIT_OLD


diff -y ./src/F_representation.f90 ../../Downloads/MultimodeFloquet-0.3/src/F_representation.f90
SUBROUTINE F_representation(Fx,Fy,Fz,Ftotal)			SUBROUTINE F_representation(Fx,Fy,Fz,Ftotal)

  USE FUNCIONES							  USE FUNCIONES
  								  
  IMPLICIT NONE							  IMPLICIT NONE
  DOUBLE PRECISION, DIMENSION(:,:), INTENT(OUT):: Fx,Fy,Fz	  DOUBLE PRECISION, DIMENSION(:,:), INTENT(OUT):: Fx,Fy,Fz
  DOUBLE PRECISION, INTENT(IN) :: Ftotal			  DOUBLE PRECISION, INTENT(IN) :: Ftotal
  !INTEGER, INTENT(IN) :: Ftotal_				  !INTEGER, INTENT(IN) :: Ftotal_

  !DOUBLE PRECISION						  !DOUBLE PRECISION
  INTEGER k,p,N_k						  INTEGER k,p,N_k
  double precision k_!,Ftotal					  double precision k_!,Ftotal

  Fx = 0.0							  Fx = 0.0
  Fy = 0.0 							  Fy = 0.0 
  Fz = 0.0							  Fz = 0.0
!  Ftotal = 1.0*Ftotal_						!  Ftotal = 1.0*Ftotal_
!  write(*,*) "with F",ftotal					!  write(*,*) "with F",ftotal
!!$  N_k = 2*Ftotal + 1						!!$  N_k = 2*Ftotal + 1
!!$  DO k=-int(Ftotal),int(Ftotal),1				!!$  DO k=-int(Ftotal),int(Ftotal),1
!!$     							!!$     
!!$     Fz(k+int(Ftotal) + 1,k+int(Ftotal) + 1) = 1.0*k		!!$     Fz(k+int(Ftotal) + 1,k+int(Ftotal) + 1) = 1.0*k
!!$     							!!$     
!!$  END DO							!!$  END DO
!!$								!!$
!!$   DO k=-int(Ftotal),int(Ftotal),1				!!$   DO k=-int(Ftotal),int(Ftotal),1
!!$     DO p=-int(Ftotal),int(Ftotal),1				!!$     DO p=-int(Ftotal),int(Ftotal),1
!!$        							!!$        
!!$        Fx(k+int(Ftotal+1),p+int(Ftotal+1)) = 0.5*(SQRT(Ft	!!$        Fx(k+int(Ftotal+1),p+int(Ftotal+1)) = 0.5*(SQRT(Ft
!!$             &  SQRT(Ftotal*(Ftotal+1) - k*(k-1))*delta_kr	!!$             &  SQRT(Ftotal*(Ftotal+1) - k*(k-1))*delta_kr
!!$        Fy(k+int(Ftotal+1),p+int(Ftotal+1)) = 0.5*(SQRT(Ft	!!$        Fy(k+int(Ftotal+1),p+int(Ftotal+1)) = 0.5*(SQRT(Ft
!!$             & SQRT(Ftotal*(Ftotal+1) - k*(k-1))*delta_kr_	!!$             & SQRT(Ftotal*(Ftotal+1) - k*(k-1))*delta_kr_
!!$								!!$
!!$     END DO							!!$     END DO
!!$  END DO							!!$  END DO
  N_k = 2*Ftotal + 1						  N_k = 2*Ftotal + 1
  k_ = -(N_k - 1.0)/2.0						  k_ = -(N_k - 1.0)/2.0
 								 
  DO k=1,N_k!-int(Ftotal),int(Ftotal),1				  DO k=1,N_k!-int(Ftotal),int(Ftotal),1
     Fz(k,k) = k_						     Fz(k,k) = k_
     k_ = k_ + 1						     k_ = k_ + 1
  END DO							  END DO

  k_ = -(N_k - 1.0)/2.0  					  k_ = -(N_k - 1.0)/2.0  
  DO k=1,N_k!-int(Ftotal),int(Ftotal),1				  DO k=1,N_k!-int(Ftotal),int(Ftotal),1
     DO p=1,N_k!-int(Ftotal),int(Ftotal),1			     DO p=1,N_k!-int(Ftotal),int(Ftotal),1
!        write(*,*) k_,k,p,N_k,Ftotal				!        write(*,*) k_,k,p,N_k,Ftotal
        Fx(k,p) = 0.5*(SQRT(Ftotal*(Ftotal+1) - k_*(k_+1))*de	        Fx(k,p) = 0.5*(SQRT(Ftotal*(Ftotal+1) - k_*(k_+1))*de
             &  SQRT(Ftotal*(Ftotal+1) - k_*(k_-1))*delta_kr_	             &  SQRT(Ftotal*(Ftotal+1) - k_*(k_-1))*delta_kr_
        Fy(k,p) = 0.5*(SQRT(Ftotal*(Ftotal+1) - k_*(k_+1))*de	        Fy(k,p) = 0.5*(SQRT(Ftotal*(Ftotal+1) - k_*(k_+1))*de
             & SQRT(Ftotal*(Ftotal+1) - k_*(k_-1))*delta_kr_i	             & SQRT(Ftotal*(Ftotal+1) - k_*(k_-1))*delta_kr_i
        							        
     END DO							     END DO
     k_ = k_ + 1						     k_ = k_ + 1
  END DO							  END DO
!!$  do p=1,int(2*FTotal+1)					!!$  do p=1,int(2*FTotal+1)
!!$     write(*,*) (abs(Fy(p,k)), k=1,int(2*FTotal+1))		!!$     write(*,*) (abs(Fy(p,k)), k=1,int(2*FTotal+1))
!!$  end do							!!$  end do
!!$  write(*,*) 						!!$  write(*,*) 
!!$  do p=1,int(2*FTotal+1)					!!$  do p=1,int(2*FTotal+1)
!!$     write(*,*) (abs(Fx(p,k)), k=1,int(2*FTotal+1))		!!$     write(*,*) (abs(Fx(p,k)), k=1,int(2*FTotal+1))
!!$  end do							!!$  end do
!!$  write(*,*)							!!$  write(*,*)

 205 FORMAT(5e15.6)						 205 FORMAT(5e15.6)
END SUBROUTINE F_representation					END SUBROUTINE F_representation
diff -y ./src/I_and_J_representations.f90 ../../Downloads/MultimodeFloquet-0.3/src/I_and_J_representations.f90
SUBROUTINE I_and_J_representations(j_x,j_y,j_z,I_x,I_y,I_z,L,	SUBROUTINE I_and_J_representations(j_x,j_y,j_z,I_x,I_y,I_z,L,

  USE FUNCIONES							  USE FUNCIONES
  								  
  IMPLICIT  NONE						  IMPLICIT  NONE
  DOUBLE PRECISION, DIMENSION(:,:),INTENT(INOUT) :: j_x,j_y,j	  DOUBLE PRECISION, DIMENSION(:,:),INTENT(INOUT) :: j_x,j_y,j
  DOUBLE PRECISION, INTENT(IN) :: L,S,I				  DOUBLE PRECISION, INTENT(IN) :: L,S,I
  								  
  DOUBLE PRECISION J,F,M,M_,mI,mI_,mJ,mJ_			  DOUBLE PRECISION J,F,M,M_,mI,mI_,mJ,mJ_
  INTEGER :: r,p,k,v						  INTEGER :: r,p,k,v
  J = L+S							  J = L+S
  r = 0								  r = 0
  p = 0    							  p = 0    
  j_x = 0							  j_x = 0
  j_y = 0							  j_y = 0
  j_z = 0							  j_z = 0
  I_x = 0							  I_x = 0
  I_y = 0							  I_y = 0
  I_z = 0							  I_z = 0
  								  
  DO k=1,int(2*(I+S)+1)						  DO k=1,int(2*(I+S)+1)
     M  = I+S - (k-1)						     M  = I+S - (k-1)
     mJ = J							     mJ = J
     mI = M-J							     mI = M-J
     if(abs(mI).GT.I)  then					     if(abs(mI).GT.I)  then
        mJ = -J							        mJ = -J
        mI = M + J						        mI = M + J
     end if							     end if
     DO WHILE ((mJ.GE.-J).AND.(ABS(mI).LE.I))			     DO WHILE ((mJ.GE.-J).AND.(ABS(mI).LE.I))
        r = r + 1						        r = r + 1
        p = 0        						        p = 0        
        DO v=1,int(2*(I+S)+1)					        DO v=1,int(2*(I+S)+1)
           M_ = I+S - (v-1) 					           M_ = I+S - (v-1) 
           mJ_ = J						           mJ_ = J
           mI_ = M_ - J						           mI_ = M_ - J
           if(abs(mI_).GT.I) THEN				           if(abs(mI_).GT.I) THEN
              mJ_ = -J						              mJ_ = -J
              mI_ = M_ + J					              mI_ = M_ + J
           END if						           END if
           DO WHILE ((mJ_.GE.-J) .AND. (ABS(mI_).LE.I))      	           DO WHILE ((mJ_.GE.-J) .AND. (ABS(mI_).LE.I))      
              p = p + 1						              p = p + 1
              j_x(r,p) = 0.5*(sqrt((J-mJ_)*(J+mJ_+1))*delta_k	              j_x(r,p) = 0.5*(sqrt((J-mJ_)*(J+mJ_+1))*delta_k
                   & sqrt((J+mJ_)*(J-mJ_+1))*delta_kr(mJ,mJ_-	                   & sqrt((J+mJ_)*(J-mJ_+1))*delta_kr(mJ,mJ_-
              j_y(r,p) = 0.5*(sqrt((J-mJ_)*(J+mJ_+1))*delta_k	              j_y(r,p) = 0.5*(sqrt((J-mJ_)*(J+mJ_+1))*delta_k
                   & sqrt((J+mJ_)*(J-mJ_+1))*delta_kr(mJ,mJ_-	                   & sqrt((J+mJ_)*(J-mJ_+1))*delta_kr(mJ,mJ_-
              j_z(r,p) = mJ_*delta_kr(mJ,mJ_)*delta_kr(mI,mI_	              j_z(r,p) = mJ_*delta_kr(mJ,mJ_)*delta_kr(mI,mI_
              							              
              I_x(r,p) = 0.5*(sqrt((I-mI_)*(I+mI_+1))*delta_k	              I_x(r,p) = 0.5*(sqrt((I-mI_)*(I+mI_+1))*delta_k
                   & sqrt((I+mI_)*(I-mI_+1))*delta_kr(mI,mI_-	                   & sqrt((I+mI_)*(I-mI_+1))*delta_kr(mI,mI_-
              I_y(r,p) = 0.5*(sqrt((I-mI_)*(I+mI_+1))*delta_k	              I_y(r,p) = 0.5*(sqrt((I-mI_)*(I+mI_+1))*delta_k
                   & sqrt((I+mI_)*(I-mI_+1))*delta_kr(mI,mI_-	                   & sqrt((I+mI_)*(I-mI_+1))*delta_kr(mI,mI_-
              I_z(r,p) = mI_*delta_kr(mJ,mJ_)*delta_kr(mI,mI_	              I_z(r,p) = mI_*delta_kr(mJ,mJ_)*delta_kr(mI,mI_
              !write(*,*) r,p,mI,mJ,mI_,mJ_,j_z(r,p)		              !write(*,*) r,p,mI,mJ,mI_,mJ_,j_z(r,p)
              mJ_ = mJ_ - 1					              mJ_ = mJ_ - 1
              mI_ = mI_ + 1              			              mI_ = mI_ + 1              
              							              
           END DO						           END DO
        END DO							        END DO
        mJ = mJ - 1						        mJ = mJ - 1
        mI = mI + 1        					        mI = mI + 1        
     END DO							     END DO
  END DO							  END DO
END SUBROUTINE I_and_J_representations				END SUBROUTINE I_and_J_representations
diff -y ./src/LapackEigenValues_C.f90 ../../Downloads/MultimodeFloquet-0.3/src/LapackEigenValues_C.f90
SUBROUTINE PACKINGBANDMATRIX_C(N,A,KD,AB,INFO)			SUBROUTINE PACKINGBANDMATRIX_C(N,A,KD,AB,INFO)

! brute force packing of a banded matrix			! brute force packing of a banded matrix
  								  
  IMPLICIT NONE							  IMPLICIT NONE
  INTEGER, INTENT(INOUT) :: INFO				  INTEGER, INTENT(INOUT) :: INFO
  INTEGER, INTENT(IN)    :: N,KD				  INTEGER, INTENT(IN)    :: N,KD
  COMPLEX*16, DIMENSION(N,N)    :: A				  COMPLEX*16, DIMENSION(N,N)    :: A
  COMPLEX*16, DIMENSION(KD+1,N) :: AB				  COMPLEX*16, DIMENSION(KD+1,N) :: AB

  INTEGER i,j,N_,I_						  INTEGER i,j,N_,I_

  								  
  CALL PACKINGBANDMATRIX(N,A,KD,AB,INFO)			  CALL PACKINGBANDMATRIX(N,A,KD,AB,INFO)
  								  
END SUBROUTINE PACKINGBANDMATRIX_C				END SUBROUTINE PACKINGBANDMATRIX_C


SUBROUTINE LAPACK_FULLEIGENVALUESBAND_C(AB,Z,KD,N,W,INFO)	SUBROUTINE LAPACK_FULLEIGENVALUESBAND_C(AB,Z,KD,N,W,INFO)
  !eigenvalues/vectors of banded matrix ab			  !eigenvalues/vectors of banded matrix ab
!AB, inout, packed banded matrix				!AB, inout, packed banded matrix
!Z, out,eigenvectors						!Z, out,eigenvectors
!KD out, calcuated eigenvectors					!KD out, calcuated eigenvectors
!N, in,matrix dimension						!N, in,matrix dimension
!W, out, eigenvalues						!W, out, eigenvalues
!INFO,inout, error flag						!INFO,inout, error flag

  !H is COMPLEX*16 array, dimension (N, N)			  !H is COMPLEX*16 array, dimension (N, N)
  !  69 *>          On entry, the Hermitian matrix A.  If UPL	  !  69 *>          On entry, the Hermitian matrix A.  If UPL
  !  70 *>          leading N-by-N upper triangular part of A	  !  70 *>          leading N-by-N upper triangular part of A
  !  71 *>          upper triangular part of the matrix A.  I	  !  71 *>          upper triangular part of the matrix A.  I
  !  72 *>          the leading N-by-N lower triangular part 	  !  72 *>          the leading N-by-N lower triangular part 
  !  73 *>          the lower triangular part of the matrix A	  !  73 *>          the lower triangular part of the matrix A
  !  74 *>          On exit, if JOBZ = 'V', then if INFO = 0,	  !  74 *>          On exit, if JOBZ = 'V', then if INFO = 0,
  !  75 *>          orthonormal eigenvectors of the matrix A.	  !  75 *>          orthonormal eigenvectors of the matrix A.
  !  76 *>          If JOBZ = 'N', then on exit the lower tri	  !  76 *>          If JOBZ = 'N', then on exit the lower tri
  !  77 *>          or the upper triangle (if UPLO='U') of A,	  !  77 *>          or the upper triangle (if UPLO='U') of A,
  !  78 *>          diagonal, is destroyed.			  !  78 *>          diagonal, is destroyed.
  !								  !
  ! The eigenvector H(:,r) corresponds to the eigenvalue W_SP	  ! The eigenvector H(:,r) corresponds to the eigenvalue W_SP
  !								  !
  IMPLICIT NONE							  IMPLICIT NONE
  INTEGER,                                INTENT(IN)    :: N,	  INTEGER,                                INTENT(IN)    :: N,
  COMPLEX*16,       DIMENSION(KD+1,N), INTENT(INOUT)    :: AB	  COMPLEX*16,       DIMENSION(KD+1,N), INTENT(INOUT)    :: AB
  COMPLEX*16,       DIMENSION(N,N),       INTENT(INOUT) :: Z	  COMPLEX*16,       DIMENSION(N,N),       INTENT(INOUT) :: Z
  DOUBLE PRECISION, DIMENSION(N),         INTENT(INOUT) :: W	  DOUBLE PRECISION, DIMENSION(N),         INTENT(INOUT) :: W
  INTEGER,                                INTENT(OUT)   :: IN	  INTEGER,                                INTENT(OUT)   :: IN

  CALL LAPACK_FULLEIGENVALUESBAND(AB,Z,KD,N,W,INFO)		  CALL LAPACK_FULLEIGENVALUESBAND(AB,Z,KD,N,W,INFO)

END SUBROUTINE LAPACK_FULLEIGENVALUESBAND_C			END SUBROUTINE LAPACK_FULLEIGENVALUESBAND_C




SUBROUTINE LAPACK_FULLEIGENVALUES_C(U_F,N,W_SPACE_,INFO)	SUBROUTINE LAPACK_FULLEIGENVALUES_C(U_F,N,W_SPACE_,INFO)
!eigenvalues/vectors of matrix ab				!eigenvalues/vectors of matrix ab
!H, inout, packed banded matrix					!H, inout, packed banded matrix
! , out,eigenvectors						! , out,eigenvectors
!N, in,matrix dimension						!N, in,matrix dimension
!W_space, out, eigenvalues					!W_space, out, eigenvalues
!INFO,inout, error flag						!INFO,inout, error flag

  !H is COMPLEX*16 array, dimension (N, N)			  !H is COMPLEX*16 array, dimension (N, N)
  !  69 *>          On entry, the Hermitian matrix A.  If UPL	  !  69 *>          On entry, the Hermitian matrix A.  If UPL
  !  70 *>          leading N-by-N upper triangular part of A	  !  70 *>          leading N-by-N upper triangular part of A
  !  71 *>          upper triangular part of the matrix A.  I	  !  71 *>          upper triangular part of the matrix A.  I
  !  72 *>          the leading N-by-N lower triangular part 	  !  72 *>          the leading N-by-N lower triangular part 
  !  73 *>          the lower triangular part of the matrix A	  !  73 *>          the lower triangular part of the matrix A
  !  74 *>          On exit, if JOBZ = 'V', then if INFO = 0,	  !  74 *>          On exit, if JOBZ = 'V', then if INFO = 0,
  !  75 *>          orthonormal eigenvectors of the matrix A.	  !  75 *>          orthonormal eigenvectors of the matrix A.
  !  76 *>          If JOBZ = 'N', then on exit the lower tri	  !  76 *>          If JOBZ = 'N', then on exit the lower tri
  !  77 *>          or the upper triangle (if UPLO='U') of A,	  !  77 *>          or the upper triangle (if UPLO='U') of A,
  !  78 *>          diagonal, is destroyed.			  !  78 *>          diagonal, is destroyed.
  !								  !
  ! The eigenvector H(:,r) corresponds to the eigenvalue W_SP	  ! The eigenvector H(:,r) corresponds to the eigenvalue W_SP
  !								  !
  USE ARRAYS							  USE ARRAYS
  IMPLICIT NONE							  IMPLICIT NONE
  INTEGER,                          INTENT(IN)    :: N		  INTEGER,                          INTENT(IN)    :: N
  COMPLEX*16,       DIMENSION(N,N), INTENT(INOUT) :: U_F	  COMPLEX*16,       DIMENSION(N,N), INTENT(INOUT) :: U_F
  DOUBLE PRECISION, DIMENSION(N),   INTENT(INOUT) :: W_SPACE_	  DOUBLE PRECISION, DIMENSION(N),   INTENT(INOUT) :: W_SPACE_
  INTEGER,                          INTENT(OUT)   :: INFO	  INTEGER,                          INTENT(OUT)   :: INFO

  !ALLOCATE(H_FLOQUET(N,N))					  !ALLOCATE(H_FLOQUET(N,N))
  !H_FLOQUET = 1.0						  !H_FLOQUET = 1.0
  !write(*,*) H_FLOQUET(1,1)!,SIZE(H_FLOQUET,1),SIZE(W_SPACE_	  !write(*,*) H_FLOQUET(1,1)!,SIZE(H_FLOQUET,1),SIZE(W_SPACE_
  CALL LAPACK_FULLEIGENVALUES(H_FLOQUET,N,W_SPACE_,INFO)	  CALL LAPACK_FULLEIGENVALUES(H_FLOQUET,N,W_SPACE_,INFO)
  								  
  U_F = H_FLOQUET						  U_F = H_FLOQUET
  DEALLOCATE(H_FLOQUET)						  DEALLOCATE(H_FLOQUET)
  								  
END SUBROUTINE LAPACK_FULLEIGENVALUES_C				END SUBROUTINE LAPACK_FULLEIGENVALUES_C


SUBROUTINE LAPACK_SELECTEIGENVALUES_C(H,N,W_SPACE,L1,L2,Z,INF	SUBROUTINE LAPACK_SELECTEIGENVALUES_C(H,N,W_SPACE,L1,L2,Z,INF
!selected eigenvalues/vectors of hermitian matrix		!selected eigenvalues/vectors of hermitian matrix
!H, inout, packed banded matrix					!H, inout, packed banded matrix
! , out,eigenvectors						! , out,eigenvectors
!N, in,matrix dimension						!N, in,matrix dimension
!W_space, out, eigenvalues					!W_space, out, eigenvalues
!L1 ordinal lowest eigenvalue					!L1 ordinal lowest eigenvalue
!L2 ordinal highest eigenvlaue					!L2 ordinal highest eigenvlaue
!Z : eigenvectors						!Z : eigenvectors
!INFO,inout, error flag						!INFO,inout, error flag

  !USE FLOQUET							  !USE FLOQUET
  IMPLICIT NONE							  IMPLICIT NONE
  INTEGER,                        INTENT(IN)    :: N,L1,L2	  INTEGER,                        INTENT(IN)    :: N,L1,L2
  COMPLEX*16, DIMENSION(:,:),     INTENT(INOUT) :: H		  COMPLEX*16, DIMENSION(:,:),     INTENT(INOUT) :: H
  COMPLEX*16, DIMENSION(:,:),     INTENT(OUT)   :: Z		  COMPLEX*16, DIMENSION(:,:),     INTENT(OUT)   :: Z
  DOUBLE PRECISION, DIMENSION(:), INTENT(OUT)   :: W_SPACE	  DOUBLE PRECISION, DIMENSION(:), INTENT(OUT)   :: W_SPACE
  INTEGER,                        INTENT(OUT)   :: INFO		  INTEGER,                        INTENT(OUT)   :: INFO

  CALL LAPACK_SELECTEIGENVALUES(H,N,W_SPACE,L1,L2,Z,INFO)	  CALL LAPACK_SELECTEIGENVALUES(H,N,W_SPACE,L1,L2,Z,INFO)

END SUBROUTINE LAPACK_SELECTEIGENVALUES_C			END SUBROUTINE LAPACK_SELECTEIGENVALUES_C

diff -y ./src/LapackEigenValues.f90 ../../Downloads/MultimodeFloquet-0.3/src/LapackEigenValues.f90
SUBROUTINE PACKINGBANDMATRIX(N,A,KD,AB,INFO)			SUBROUTINE PACKINGBANDMATRIX(N,A,KD,AB,INFO)

! brute force packing of a banded matrix			! brute force packing of a banded matrix
  								  
  IMPLICIT NONE							  IMPLICIT NONE
  INTEGER, INTENT(INOUT) :: INFO				  INTEGER, INTENT(INOUT) :: INFO
  INTEGER, INTENT(IN)    :: N,KD				  INTEGER, INTENT(IN)    :: N,KD
  COMPLEX*16, DIMENSION(N,N)    :: A				  COMPLEX*16, DIMENSION(N,N)    :: A
  COMPLEX*16, DIMENSION(KD+1,N) :: AB				  COMPLEX*16, DIMENSION(KD+1,N) :: AB

  INTEGER i,j,N_,I_						  INTEGER i,j,N_,I_

  								  
  								  
  DO j=1,N							  DO j=1,N
     IF(1.GE.(j-KD)) THEN					     IF(1.GE.(j-KD)) THEN
        I_=1							        I_=1
     ELSE							     ELSE
        I_ = j-KD						        I_ = j-KD
     END IF							     END IF
     ! U STORAGE						     ! U STORAGE
     DO i=I_,j							     DO i=I_,j
        AB(KD+1+i-j,j) = A(i,j)					        AB(KD+1+i-j,j) = A(i,j)
     END DO							     END DO
  END DO							  END DO

END SUBROUTINE PACKINGBANDMATRIX				END SUBROUTINE PACKINGBANDMATRIX


SUBROUTINE LAPACK_FULLEIGENVALUESBAND(AB,Z,KD,N,W,INFO)		SUBROUTINE LAPACK_FULLEIGENVALUESBAND(AB,Z,KD,N,W,INFO)
!eigenvalues/vectors of banded matrix ab			!eigenvalues/vectors of banded matrix ab
!AB, inout, packed banded matrix				!AB, inout, packed banded matrix
!Z, out,eigenvectors						!Z, out,eigenvectors
!KD out, calcuated eigenvectors					!KD out, calcuated eigenvectors
!N, in,matrix dimension						!N, in,matrix dimension
!W, out, eigenvalues						!W, out, eigenvalues
!INFO,inout, error flag						!INFO,inout, error flag

  !H is COMPLEX*16 array, dimension (N, N)			  !H is COMPLEX*16 array, dimension (N, N)
  !  69 *>          On entry, the Hermitian matrix A.  If UPL	  !  69 *>          On entry, the Hermitian matrix A.  If UPL
  !  70 *>          leading N-by-N upper triangular part of A	  !  70 *>          leading N-by-N upper triangular part of A
  !  71 *>          upper triangular part of the matrix A.  I	  !  71 *>          upper triangular part of the matrix A.  I
  !  72 *>          the leading N-by-N lower triangular part 	  !  72 *>          the leading N-by-N lower triangular part 
  !  73 *>          the lower triangular part of the matrix A	  !  73 *>          the lower triangular part of the matrix A
  !  74 *>          On exit, if JOBZ = 'V', then if INFO = 0,	  !  74 *>          On exit, if JOBZ = 'V', then if INFO = 0,
  !  75 *>          orthonormal eigenvectors of the matrix A.	  !  75 *>          orthonormal eigenvectors of the matrix A.
  !  76 *>          If JOBZ = 'N', then on exit the lower tri	  !  76 *>          If JOBZ = 'N', then on exit the lower tri
  !  77 *>          or the upper triangle (if UPLO='U') of A,	  !  77 *>          or the upper triangle (if UPLO='U') of A,
  !  78 *>          diagonal, is destroyed.			  !  78 *>          diagonal, is destroyed.
  !								  !
  ! The eigenvector H(:,r) corresponds to the eigenvalue W_SP	  ! The eigenvector H(:,r) corresponds to the eigenvalue W_SP
  !								  !
  IMPLICIT NONE							  IMPLICIT NONE
  INTEGER,                                INTENT(IN)    :: N,	  INTEGER,                                INTENT(IN)    :: N,
  COMPLEX*16,       DIMENSION(KD+1,N), INTENT(INOUT)    :: AB	  COMPLEX*16,       DIMENSION(KD+1,N), INTENT(INOUT)    :: AB
  COMPLEX*16,       DIMENSION(N,N),       INTENT(INOUT) :: Z	  COMPLEX*16,       DIMENSION(N,N),       INTENT(INOUT) :: Z
  DOUBLE PRECISION, DIMENSION(N),         INTENT(INOUT) :: W	  DOUBLE PRECISION, DIMENSION(N),         INTENT(INOUT) :: W
  INTEGER,                                INTENT(OUT)   :: IN	  INTEGER,                                INTENT(OUT)   :: IN


  !---SETTING  LAPACK VARIABLES: START ---------!		  !---SETTING  LAPACK VARIABLES: START ---------!
  CHARACTER         JOBZ, UPLO					  CHARACTER         JOBZ, UPLO
  INTEGER           LDAB,LDZ					  INTEGER           LDAB,LDZ
  DOUBLE PRECISION, DIMENSION(:),   ALLOCATABLE :: RWORK	  DOUBLE PRECISION, DIMENSION(:),   ALLOCATABLE :: RWORK
  COMPLEX*16,       DIMENSION(:),   ALLOCATABLE :: WORK		  COMPLEX*16,       DIMENSION(:),   ALLOCATABLE :: WORK
  								  
  JOBZ = 'V'							  JOBZ = 'V'
  UPLO = 'U'  							  UPLO = 'U'  

  LDAB = KD+1							  LDAB = KD+1
  LDZ  = N							  LDZ  = N

  ALLOCATE(WORK(N))						  ALLOCATE(WORK(N))
  ALLOCATE(RWORK(3*N-2))					  ALLOCATE(RWORK(3*N-2))

!  WRITE(*,*) JOBZ, UPLO, N, KD,  LDAB, LDZ,  INFO		!  WRITE(*,*) JOBZ, UPLO, N, KD,  LDAB, LDZ,  INFO
  CALL ZHBEV(JOBZ, UPLO, N, KD, AB, LDAB, W, Z, LDZ, WORK, RW	  CALL ZHBEV(JOBZ, UPLO, N, KD, AB, LDAB, W, Z, LDZ, WORK, RW
  IF(INFO /= 0) WRITE(*,*) "# DIAG FAIL 1",INFO			  IF(INFO /= 0) WRITE(*,*) "# DIAG FAIL 1",INFO

  DEALLOCATE(WORK)						  DEALLOCATE(WORK)
  DEALLOCATE(RWORK) 						  DEALLOCATE(RWORK) 
 								 
END SUBROUTINE LAPACK_FULLEIGENVALUESBAND			END SUBROUTINE LAPACK_FULLEIGENVALUESBAND




SUBROUTINE LAPACK_FULLEIGENVALUES(H,N,W_SPACE,INFO)		SUBROUTINE LAPACK_FULLEIGENVALUES(H,N,W_SPACE,INFO)
!eigenvalues/vectors of matrix ab				!eigenvalues/vectors of matrix ab
!H, inout, packed banded matrix					!H, inout, packed banded matrix
! , out,eigenvectors						! , out,eigenvectors
!N, in,matrix dimension						!N, in,matrix dimension
!W_space, out, eigenvalues					!W_space, out, eigenvalues
!INFO,inout, error flag						!INFO,inout, error flag

  !H is COMPLEX*16 array, dimension (N, N)			  !H is COMPLEX*16 array, dimension (N, N)
  !  69 *>          On entry, the Hermitian matrix A.  If UPL	  !  69 *>          On entry, the Hermitian matrix A.  If UPL
  !  70 *>          leading N-by-N upper triangular part of A	  !  70 *>          leading N-by-N upper triangular part of A
  !  71 *>          upper triangular part of the matrix A.  I	  !  71 *>          upper triangular part of the matrix A.  I
  !  72 *>          the leading N-by-N lower triangular part 	  !  72 *>          the leading N-by-N lower triangular part 
  !  73 *>          the lower triangular part of the matrix A	  !  73 *>          the lower triangular part of the matrix A
  !  74 *>          On exit, if JOBZ = 'V', then if INFO = 0,	  !  74 *>          On exit, if JOBZ = 'V', then if INFO = 0,
  !  75 *>          orthonormal eigenvectors of the matrix A.	  !  75 *>          orthonormal eigenvectors of the matrix A.
  !  76 *>          If JOBZ = 'N', then on exit the lower tri	  !  76 *>          If JOBZ = 'N', then on exit the lower tri
  !  77 *>          or the upper triangle (if UPLO='U') of A,	  !  77 *>          or the upper triangle (if UPLO='U') of A,
  !  78 *>          diagonal, is destroyed.			  !  78 *>          diagonal, is destroyed.
  !								  !
  ! The eigenvector H(:,r) corresponds to the eigenvalue W_SP	  ! The eigenvector H(:,r) corresponds to the eigenvalue W_SP
  !								  !
  IMPLICIT NONE							  IMPLICIT NONE
  INTEGER,                          INTENT(IN)    :: N		  INTEGER,                          INTENT(IN)    :: N
  COMPLEX*16,       DIMENSION(N,N), INTENT(INOUT) :: H		  COMPLEX*16,       DIMENSION(N,N), INTENT(INOUT) :: H
  DOUBLE PRECISION, DIMENSION(N),   INTENT(INOUT) :: W_SPACE	  DOUBLE PRECISION, DIMENSION(N),   INTENT(INOUT) :: W_SPACE
  INTEGER,                          INTENT(OUT)   :: INFO	  INTEGER,                          INTENT(OUT)   :: INFO


  !---SETTING  LAPACK VARIABLES: START ---------!		  !---SETTING  LAPACK VARIABLES: START ---------!
  CHARACTER         JOBZ, UPLO					  CHARACTER         JOBZ, UPLO
  INTEGER           LWORK,LDA					  INTEGER           LWORK,LDA
  INTEGER,          DIMENSION(:),   ALLOCATABLE :: IWORK,ISUP	  INTEGER,          DIMENSION(:),   ALLOCATABLE :: IWORK,ISUP
  DOUBLE PRECISION, DIMENSION(:),   ALLOCATABLE :: RWORK	  DOUBLE PRECISION, DIMENSION(:),   ALLOCATABLE :: RWORK
  COMPLEX*16,       DIMENSION(:),   ALLOCATABLE :: WORK		  COMPLEX*16,       DIMENSION(:),   ALLOCATABLE :: WORK
  COMPLEX*16,       DIMENSION(:,:), ALLOCATABLE :: H_AUX_  	  COMPLEX*16,       DIMENSION(:,:), ALLOCATABLE :: H_AUX_  
  DOUBLE PRECISION, DIMENSION(N) :: E				  DOUBLE PRECISION, DIMENSION(N) :: E
  JOBZ = 'V'							  JOBZ = 'V'
  UPLO = 'L'  							  UPLO = 'L'  

!  write(*,*) "# call to lapack diagonalization of a matrix o	!  write(*,*) "# call to lapack diagonalization of a matrix o
!  write(*,*) H							!  write(*,*) H

  ALLOCATE(H_AUX_(N,N))						  ALLOCATE(H_AUX_(N,N))
  H_AUX_ = 0.0							  H_AUX_ = 0.0
  LDA   =  N							  LDA   =  N
  LWORK = 2*N							  LWORK = 2*N

  ALLOCATE(WORK(2*N))						  ALLOCATE(WORK(2*N))
  ALLOCATE(RWORK(3*N-2))					  ALLOCATE(RWORK(3*N-2))

  !---- use zheev to get the optimun value of LWORK		  !---- use zheev to get the optimun value of LWORK
  WORK = -1							  WORK = -1
  CALL ZHEEV(JOBZ,UPLO,N,H_AUX_,LDA,W_SPACE,WORK,LWORK,RWORK,	  CALL ZHEEV(JOBZ,UPLO,N,H_AUX_,LDA,W_SPACE,WORK,LWORK,RWORK,
  LWORK = INT(WORK(1))						  LWORK = INT(WORK(1))
  IF(LWORK.GT.0) THEN						  IF(LWORK.GT.0) THEN
     DEALLOCATE(WORK)						     DEALLOCATE(WORK)
     ALLOCATE(WORK(LWORK))					     ALLOCATE(WORK(LWORK))
  ELSE								  ELSE
     WRITE(*,*) "ERROR IN ZHEEV CALLED BY LAPACK_FULLEIGENVAL	     WRITE(*,*) "ERROR IN ZHEEV CALLED BY LAPACK_FULLEIGENVAL
  END IF							  END IF
  !write(*,*) info,LWORK,UPLO,N,H				  !write(*,*) info,LWORK,UPLO,N,H
  IF(INFO /= 0) WRITE(*,*) "# DIAG FAIL 0",INFO			  IF(INFO /= 0) WRITE(*,*) "# DIAG FAIL 0",INFO

  CALL ZHEEV(JOBZ,UPLO,N,H,LDA,W_SPACE, WORK, LWORK, RWORK,IN	  CALL ZHEEV(JOBZ,UPLO,N,H,LDA,W_SPACE, WORK, LWORK, RWORK,IN
  !IF(INFO /= 0) WRITE(*,*) "# DIAG FAIL 1",INFO		  !IF(INFO /= 0) WRITE(*,*) "# DIAG FAIL 1",INFO
  DEALLOCATE(WORK)						  DEALLOCATE(WORK)
  DEALLOCATE(RWORK) 						  DEALLOCATE(RWORK) 
  DEALLOCATE(H_AUX_)						  DEALLOCATE(H_AUX_)
END SUBROUTINE LAPACK_FULLEIGENVALUES				END SUBROUTINE LAPACK_FULLEIGENVALUES


SUBROUTINE LAPACK_SELECTEIGENVALUES(H,N,W_SPACE,L1,L2,Z,INFO)	SUBROUTINE LAPACK_SELECTEIGENVALUES(H,N,W_SPACE,L1,L2,Z,INFO)
!selected eigenvalues/vectors of hermitian matrix		!selected eigenvalues/vectors of hermitian matrix
!H, inout, packed banded matrix					!H, inout, packed banded matrix
! , out,eigenvectors						! , out,eigenvectors
!N, in,matrix dimension						!N, in,matrix dimension
!W_space, out, eigenvalues					!W_space, out, eigenvalues
!L1 ordinal lowest eigenvalue					!L1 ordinal lowest eigenvalue
!L2 ordinal highest eigenvlaue					!L2 ordinal highest eigenvlaue
!Z : eigenvectors						!Z : eigenvectors
!INFO,inout, error flag						!INFO,inout, error flag

  !USE FLOQUET							  !USE FLOQUET
  IMPLICIT NONE							  IMPLICIT NONE
  INTEGER,                        INTENT(IN)    :: N,L1,L2	  INTEGER,                        INTENT(IN)    :: N,L1,L2
  COMPLEX*16, DIMENSION(:,:),     INTENT(INOUT) :: H		  COMPLEX*16, DIMENSION(:,:),     INTENT(INOUT) :: H
  COMPLEX*16, DIMENSION(:,:),     INTENT(OUT)   :: Z		  COMPLEX*16, DIMENSION(:,:),     INTENT(OUT)   :: Z
  DOUBLE PRECISION, DIMENSION(:), INTENT(OUT)   :: W_SPACE	  DOUBLE PRECISION, DIMENSION(:), INTENT(OUT)   :: W_SPACE
  INTEGER,                        INTENT(OUT)   :: INFO		  INTEGER,                        INTENT(OUT)   :: INFO


  !---SETTING  LAPACK VARIABLES: START ---------!		  !---SETTING  LAPACK VARIABLES: START ---------!
  CHARACTER         JOBZ, UPLO, RANGE				  CHARACTER         JOBZ, UPLO, RANGE
  DOUBLE PRECISION ABSTOL, VL, VU				  DOUBLE PRECISION ABSTOL, VL, VU
  INTEGER           LWORK,LDA,LRWORK, LIWORK, IL, IU, MP,LDZ,	  INTEGER           LWORK,LDA,LRWORK, LIWORK, IL, IU, MP,LDZ,
  INTEGER,          DIMENSION(:),   ALLOCATABLE :: IWORK,ISUP	  INTEGER,          DIMENSION(:),   ALLOCATABLE :: IWORK,ISUP
  DOUBLE PRECISION, DIMENSION(:),   ALLOCATABLE :: RWORK	  DOUBLE PRECISION, DIMENSION(:),   ALLOCATABLE :: RWORK
  COMPLEX*16,       DIMENSION(:),   ALLOCATABLE :: WORK		  COMPLEX*16,       DIMENSION(:),   ALLOCATABLE :: WORK
  COMPLEX*16,       DIMENSION(:,:), ALLOCATABLE :: H_AUX_  	  COMPLEX*16,       DIMENSION(:,:), ALLOCATABLE :: H_AUX_  
  JOBZ = 'V'							  JOBZ = 'V'
  UPLO = 'L'							  UPLO = 'L'
  RANGE = 'A'							  RANGE = 'A'
  LWMAX  = 2000							  LWMAX  = 2000
  ABSTOL = -1.0							  ABSTOL = -1.0

  ALLOCATE(H_AUX_(N,N))						  ALLOCATE(H_AUX_(N,N))
  H_AUX_ = 0.0							  H_AUX_ = 0.0
  LDA   =   N							  LDA   =   N
  LWORK = 2*N							  LWORK = 2*N
  LDZ   =   N							  LDZ   =   N
  ALLOCATE(WORK(LWMAX))						  ALLOCATE(WORK(LWMAX))
  ALLOCATE(RWORK(LWMAX))					  ALLOCATE(RWORK(LWMAX))
  ALLOCATE(IWORK(LWMAX))					  ALLOCATE(IWORK(LWMAX))
  ALLOCATE(ISUPPZ(N))						  ALLOCATE(ISUPPZ(N))
  LWORK = -1							  LWORK = -1
  LRWORK = -1							  LRWORK = -1
  LIWORK = -1      						  LIWORK = -1      
  VL = 0.749							  VL = 0.749
  VU = 0.7503! 45.0						  VU = 0.7503! 45.0
  IL = 1!L1!(2*N_Floquet+1)*(3) + 5*(int(0.5*(2*N_Floquet+1))	  IL = 1!L1!(2*N_Floquet+1)*(3) + 5*(int(0.5*(2*N_Floquet+1))
  IU = 1!L2!IL + (2*SUBSPACES + 1)*5 - 1			  IU = 1!L2!IL + (2*SUBSPACES + 1)*5 - 1
  !  write(*,*) IL,IU,N						  !  write(*,*) IL,IU,N
!!$  IF(JOBZ.EQ.'V')  THEN					!!$  IF(JOBZ.EQ.'V')  THEN
!!$     ALLOCATE(Z(N,IU-IL + 1))				!!$     ALLOCATE(Z(N,IU-IL + 1))
!!$  ELSE							!!$  ELSE
!!$     ALLOCATE(Z(1,1))					!!$     ALLOCATE(Z(1,1))
!!$  END IF							!!$  END IF

  CALL ZHEEVR( JOBZ, RANGE, 'L', N, H_AUX_, LDA, VL, VU, IL, 	  CALL ZHEEVR( JOBZ, RANGE, 'L', N, H_AUX_, LDA, VL, VU, IL, 
       &   IU, ABSTOL, MP, W_SPACE, Z, LDZ, ISUPPZ, WORK, LWO	       &   IU, ABSTOL, MP, W_SPACE, Z, LDZ, ISUPPZ, WORK, LWO
       &   LRWORK, IWORK, LIWORK, INFO )			       &   LRWORK, IWORK, LIWORK, INFO )
  IF(INFO /= 0) WRITE(*,*) "DIAG FAIL"				  IF(INFO /= 0) WRITE(*,*) "DIAG FAIL"
  LWORK  = WORK(1)						  LWORK  = WORK(1)
  LRWORK = RWORK(1)						  LRWORK = RWORK(1)
  LIWORK = IWORK(1)						  LIWORK = IWORK(1)
  DEALLOCATE(WORK,RWORK,IWORK)					  DEALLOCATE(WORK,RWORK,IWORK)
  ALLOCATE(WORK(LWORK))						  ALLOCATE(WORK(LWORK))
  ALLOCATE(RWORK(LRWORK))					  ALLOCATE(RWORK(LRWORK))
  ALLOCATE(IWORK(LIWORK))					  ALLOCATE(IWORK(LIWORK))
  !write(*,*)INFO,LWORK,LRWORK,LIWORK				  !write(*,*)INFO,LWORK,LRWORK,LIWORK
  CALL ZHEEVR( JOBZ, RANGE, 'L', N, H, LDA, VL, VU, IL, &	  CALL ZHEEVR( JOBZ, RANGE, 'L', N, H, LDA, VL, VU, IL, &
       &   IU, ABSTOL, MP, W_SPACE, Z, LDZ, ISUPPZ, WORK, LWO	       &   IU, ABSTOL, MP, W_SPACE, Z, LDZ, ISUPPZ, WORK, LWO
       &   LRWORK, IWORK, LIWORK, INFO )			       &   LRWORK, IWORK, LIWORK, INFO )
  IF(INFO /= 0) WRITE(*,*) "DIAG FAIL"				  IF(INFO /= 0) WRITE(*,*) "DIAG FAIL"
  !  write(*,*) info						  !  write(*,*) info

  DEALLOCATE(WORK,RWORK,IWORK,H_AUX_,ISUPPZ)			  DEALLOCATE(WORK,RWORK,IWORK,H_AUX_,ISUPPZ)


END SUBROUTINE LAPACK_SELECTEIGENVALUES  			END SUBROUTINE LAPACK_SELECTEIGENVALUES  
diff -y ./src/MKLSparseEigenvalues_C.f90 ../../Downloads/MultimodeFloquet-0.3/src/MKLSparseEigenvalues_C.f90
SUBROUTINE MKLSPARSE_FULLEIGENVALUES_C(D,E_L,E_R,E_FLOQUET,U_	SUBROUTINE MKLSPARSE_FULLEIGENVALUES_C(D,E_L,E_R,E_FLOQUET,U_

!CALCULATES THE ENERGY SPECTRUM OF THE MATRIX REPRESENTED BY 	!CALCULATES THE ENERGY SPECTRUM OF THE MATRIX REPRESENTED BY 
! D (IN), MATRIX DIMENSION == NUMBER OF EIGENVALUES		! D (IN), MATRIX DIMENSION == NUMBER OF EIGENVALUES
! DV (IN), NUMBER OF VALUES != 0				! DV (IN), NUMBER OF VALUES != 0
! VALUES (IN) ARRAY OF VALUES					! VALUES (IN) ARRAY OF VALUES
! ROW_INDEX (IN), ARRAY OF INDICES				! ROW_INDEX (IN), ARRAY OF INDICES
! COLUMN (IN),    ARRAY OF COLUMN NUMBERS			! COLUMN (IN),    ARRAY OF COLUMN NUMBERS
! E_L (IN),       LEFT BOUNDARY OF THE SEARCH INTERVAL		! E_L (IN),       LEFT BOUNDARY OF THE SEARCH INTERVAL
! E_R (IN),       RIGHT BOUNDARY OF THE SEARCH INTERVAL		! E_R (IN),       RIGHT BOUNDARY OF THE SEARCH INTERVAL
! E_FLOQUET (OUT), ARRAY OF EIGENVALUES				! E_FLOQUET (OUT), ARRAY OF EIGENVALUES
! INFO     (INOUT)  ERROR FLAG					! INFO     (INOUT)  ERROR FLAG

  USE MODES_4F							  USE MODES_4F
  USE FEAST							  USE FEAST
  IMPLICIT NONE							  IMPLICIT NONE
  INTEGER,                          INTENT(IN)    :: D		  INTEGER,                          INTENT(IN)    :: D
  DOUBLE PRECISION,                 INTENT(IN)    :: E_L,E_R	  DOUBLE PRECISION,                 INTENT(IN)    :: E_L,E_R
  DOUBLE PRECISION, DIMENSION(D),   INTENT(OUT)   :: E_FLOQUE	  DOUBLE PRECISION, DIMENSION(D),   INTENT(OUT)   :: E_FLOQUE
  COMPLEX*16,       DIMENSION(D,D), INTENT(OUT)   :: U_F	  COMPLEX*16,       DIMENSION(D,D), INTENT(OUT)   :: U_F
  INTEGER,                          INTENT(INOUT) :: INFO	  INTEGER,                          INTENT(INOUT) :: INFO

  INTEGER DV							  INTEGER DV
  								  
  DV = SIZE(VALUES__,1)						  DV = SIZE(VALUES__,1)
  								  
  CALL MKLSPARSE_FULLEIGENVALUES(D,DV,VALUES__,ROW_INDEX__,CO	  CALL MKLSPARSE_FULLEIGENVALUES(D,DV,VALUES__,ROW_INDEX__,CO
  								  
  								  
END SUBROUTINE MKLSPARSE_FULLEIGENVALUES_C			END SUBROUTINE MKLSPARSE_FULLEIGENVALUES_C

diff -y ./src/MKLSparseEigenvalues.f90 ../../Downloads/MultimodeFloquet-0.3/src/MKLSparseEigenvalues.f90
SUBROUTINE MKLSPARSE_FULLEIGENVALUES(D,DV,VALUES,ROW_INDEX,CO	SUBROUTINE MKLSPARSE_FULLEIGENVALUES(D,DV,VALUES,ROW_INDEX,CO

!CALCULATES THE ENERGY SPECTRUM OF THE MATRIX REPRESENTED BY 	!CALCULATES THE ENERGY SPECTRUM OF THE MATRIX REPRESENTED BY 
! D (IN), MATRIX DIMENSION == NUMBER OF EIGENVALUES		! D (IN), MATRIX DIMENSION == NUMBER OF EIGENVALUES
! DV (IN), NUMBER OF VALUES != 0				! DV (IN), NUMBER OF VALUES != 0
! VALUES (IN) ARRAY OF VALUES					! VALUES (IN) ARRAY OF VALUES
! ROW_INDEX (IN), ARRAY OF INDICES				! ROW_INDEX (IN), ARRAY OF INDICES
! COLUMN (IN),    ARRAY OF COLUMN NUMBERS			! COLUMN (IN),    ARRAY OF COLUMN NUMBERS
! E_L (IN),       LEFT BOUNDARY OF THE SEARCH INTERVAL		! E_L (IN),       LEFT BOUNDARY OF THE SEARCH INTERVAL
! E_R (IN),       RIGHT BOUNDARY OF THE SEARCH INTERVAL		! E_R (IN),       RIGHT BOUNDARY OF THE SEARCH INTERVAL
! E_FLOQUET (OUT), ARRAY OF EIGENVALUES				! E_FLOQUET (OUT), ARRAY OF EIGENVALUES
! INFO     (INOUT)  ERROR FLAG					! INFO     (INOUT)  ERROR FLAG

  USE FEAST							  USE FEAST
  IMPLICIT NONE							  IMPLICIT NONE
  INTEGER,                          INTENT(IN)    :: D,DV	  INTEGER,                          INTENT(IN)    :: D,DV
  COMPLEX*16,       DIMENSION(DV),  INTENT(INOUT) :: VALUES	  COMPLEX*16,       DIMENSION(DV),  INTENT(INOUT) :: VALUES
  INTEGER,          DIMENSION(DV),  INTENT(INOUT) :: COLUMN	  INTEGER,          DIMENSION(DV),  INTENT(INOUT) :: COLUMN
  INTEGER,          DIMENSION(D+1), INTENT(INOUT) :: ROW_INDE	  INTEGER,          DIMENSION(D+1), INTENT(INOUT) :: ROW_INDE
  DOUBLE PRECISION,                 INTENT(IN)    :: E_L,E_R	  DOUBLE PRECISION,                 INTENT(IN)    :: E_L,E_R
  DOUBLE PRECISION, DIMENSION(D),   INTENT(OUT)   :: E_FLOQUE	  DOUBLE PRECISION, DIMENSION(D),   INTENT(OUT)   :: E_FLOQUE
  COMPLEX*16,       DIMENSION(D,D), INTENT(OUT)   :: U_F	  COMPLEX*16,       DIMENSION(D,D), INTENT(OUT)   :: U_F
  INTEGER,                          INTENT(INOUT) :: INFO	  INTEGER,                          INTENT(INOUT) :: INFO

  CHARACTER*1 UPLO						  CHARACTER*1 UPLO
  								  
  ! ----- 2. RUN FEASTINIT					  ! ----- 2. RUN FEASTINIT
  								  
  CALL feastinit(fpm)						  CALL feastinit(fpm)
  								  
  ! ----- 3. SOLVE THE STANDARD EIGENVALUE PROBLEM		  ! ----- 3. SOLVE THE STANDARD EIGENVALUE PROBLEM

  M0  = D  ! number of eignevalues requested			  M0  = D  ! number of eignevalues requested
  								  
  ALLOCATE(E(M0)) ! array of eigenvalues			  ALLOCATE(E(M0)) ! array of eigenvalues
  ALLOCATE(RES(M0)) ! array of residuals			  ALLOCATE(RES(M0)) ! array of residuals
  ALLOCATE(X(D,M0)) ! matrix with eigenvectors			  ALLOCATE(X(D,M0)) ! matrix with eigenvectors
  E   = 0							  E   = 0
  RES = 0							  RES = 0
  X   = 0							  X   = 0


  info_FEAST = 0						  info_FEAST = 0
  Emin = E_L!-15.0 ! SEARCH INTERVAL: LOWER BOUND		  Emin = E_L!-15.0 ! SEARCH INTERVAL: LOWER BOUND
  Emax = E_R! 15.0 ! SEARCH INTERVAL: UPPER BOUND		  Emax = E_R! 15.0 ! SEARCH INTERVAL: UPPER BOUND
  UPLO = 'F'							  UPLO = 'F'
 ! write(*,*) values						 ! write(*,*) values
  !WRITE(*,*) '#MKL Sparse Eigenvalue, matrix dimension:',D	  !WRITE(*,*) '#MKL Sparse Eigenvalue, matrix dimension:',D
!  WRITE(*,*) D,SIZE(VALUES,1),SIZE(ROW_INDEX,1),SIZE(COLUMN,	!  WRITE(*,*) D,SIZE(VALUES,1),SIZE(ROW_INDEX,1),SIZE(COLUMN,
!  WRITE(*,*) UPLO,D,SIZE(VALUES,1),SIZE(ROW_INDEX,1),SIZE(CO	!  WRITE(*,*) UPLO,D,SIZE(VALUES,1),SIZE(ROW_INDEX,1),SIZE(CO
!       &   Emin,Emax,M0,SIZE(E,1),SIZE(X,1),SIZE(X,2),M1,SIZ	!       &   Emin,Emax,M0,SIZE(E,1),SIZE(X,1),SIZE(X,2),M1,SIZ
  CALL zfeast_hcsrev(UPLO,D,VALUES,ROW_INDEX,COLUMN,fpm,epsou	  CALL zfeast_hcsrev(UPLO,D,VALUES,ROW_INDEX,COLUMN,fpm,epsou
       &   Emin,Emax,M0,E,X,M1,res,info_FEAST)			       &   Emin,Emax,M0,E,X,M1,res,info_FEAST)
  IF(info.EQ.1) THEN						  IF(info.EQ.1) THEN
     PRINT  *,'FEAST OUTPUT INFO ',info_FEAST			     PRINT  *,'FEAST OUTPUT INFO ',info_FEAST
     WRITE(*,*) 'GUESSED NUMBER OF EIGENVALUES:', m0		     WRITE(*,*) 'GUESSED NUMBER OF EIGENVALUES:', m0
     WRITE(*,*) 'NUMBER OF EIGENVALUES FOUND:', m1		     WRITE(*,*) 'NUMBER OF EIGENVALUES FOUND:', m1
  END IF							  END IF
  IF(info.eq.10) then 						  IF(info.eq.10) then 
     PRINT  *,'FEAST OUTPUT INFO ',info_FEAST			     PRINT  *,'FEAST OUTPUT INFO ',info_FEAST
     WRITE(*,*) 'GUESSED NUMBER OF EIGENVALUES:', m0		     WRITE(*,*) 'GUESSED NUMBER OF EIGENVALUES:', m0
     WRITE(*,*) 'NUMBER OF EIGENVALUES FOUND:', m1		     WRITE(*,*) 'NUMBER OF EIGENVALUES FOUND:', m1
     WRITE(*,*) 'EIGENVALUES:', E, D				     WRITE(*,*) 'EIGENVALUES:', E, D
     WRITE(*,*) 'EIGENVECTORS:', ABS(X)				     WRITE(*,*) 'EIGENVECTORS:', ABS(X)
!     CALL WRITE_MATRIX(D_MULTIFLOQUET,D_MULTIFLOQUET,ABS(X))	!     CALL WRITE_MATRIX(D_MULTIFLOQUET,D_MULTIFLOQUET,ABS(X))
  END IF							  END IF
  E_FLOQUET = E							  E_FLOQUET = E
  U_F       = X							  U_F       = X
  INFO      = info_FEAST					  INFO      = info_FEAST

  DEALLOCATE(RES)						  DEALLOCATE(RES)
  DEALLOCATE(X)							  DEALLOCATE(X)
  DEALLOCATE(E)							  DEALLOCATE(E)
  								  
END SUBROUTINE MKLSPARSE_FULLEIGENVALUES			END SUBROUTINE MKLSPARSE_FULLEIGENVALUES

diff -y ./src/modes_C.f90 ../../Downloads/MultimodeFloquet-0.3/src/modes_C.f90
MODULE TYPES_C							MODULE TYPES_C

  TYPE :: MODE_C						  TYPE :: MODE_C
     DOUBLE PRECISION :: OMEGA					     DOUBLE PRECISION :: OMEGA
     COMPLEX*16       :: X,Y,Z					     COMPLEX*16       :: X,Y,Z
     DOUBLE PRECISION :: phi_x,phi_y,phi_z			     DOUBLE PRECISION :: phi_x,phi_y,phi_z
     INTEGER          :: N_Floquet				     INTEGER          :: N_Floquet
     !COMPLEX*16, DIMENSION(:,:), ALLOCATABLE :: V		     !COMPLEX*16, DIMENSION(:,:), ALLOCATABLE :: V
     !COMPLEX*16, DIMENSION(:),   ALLOCATABLE :: VALUES		     !COMPLEX*16, DIMENSION(:),   ALLOCATABLE :: VALUES
     !INTEGER,    DIMENSION(:),   ALLOCATABLE :: ROW,COLUMN	     !INTEGER,    DIMENSION(:),   ALLOCATABLE :: ROW,COLUMN
  END TYPE MODE_C						  END TYPE MODE_C
  								  
  TYPE :: ATOM_C						  TYPE :: ATOM_C
     INTEGER          :: id_system				     INTEGER          :: id_system
     INTEGER          :: D_BARE					     INTEGER          :: D_BARE
     !DOUBLE PRECISION, DIMENSION(:), ALLOCATABLE :: E_BARE	     !DOUBLE PRECISION, DIMENSION(:), ALLOCATABLE :: E_BARE
  END TYPE ATOM_C						  END TYPE ATOM_C
  								  
END MODULE TYPES_C						END MODULE TYPES_C

MODULE MODES_4F							MODULE MODES_4F
  ! THIS IS A GLOBAL DEFINITIO OF ATOM AND COUPLING PARAMETER	  ! THIS IS A GLOBAL DEFINITIO OF ATOM AND COUPLING PARAMETER
  ! THEIR VALUES ARE INITIALISES BELOW, IN COUPLINGINIT_C USI	  ! THEIR VALUES ARE INITIALISES BELOW, IN COUPLINGINIT_C USI
  ! THE VARIABLES PASSED BY C					  ! THE VARIABLES PASSED BY C
  USE TYPES							  USE TYPES
  USE ISO_C_BINDING						  USE ISO_C_BINDING
  TYPE(MODE),DIMENSION(:),ALLOCATABLE :: COUPLING		  TYPE(MODE),DIMENSION(:),ALLOCATABLE :: COUPLING
  TYPE(ATOM)                          :: ATOM_			  TYPE(ATOM)                          :: ATOM_
  INTEGER(C_INT),BIND(C,name="h_floquet_size") :: H_FLOQUET_S	  INTEGER(C_INT),BIND(C,name="h_floquet_size") :: H_FLOQUET_S
  LOGICAL COUPLINGALLOCATED 					  LOGICAL COUPLINGALLOCATED 
  								  
  								  
  ! THESE ARE GLOBAL DEFINITIONS OF ARRAYS NEEDED TO REPRESEN	  ! THESE ARE GLOBAL DEFINITIONS OF ARRAYS NEEDED TO REPRESEN
  ! HAMILTONIAN REQUIRED BY THE MKL LIBRARY FOR SPARSE MATRIC	  ! HAMILTONIAN REQUIRED BY THE MKL LIBRARY FOR SPARSE MATRIC
  COMPLEX*16, DIMENSION(:), ALLOCATABLE   :: VALUES__		  COMPLEX*16, DIMENSION(:), ALLOCATABLE   :: VALUES__
  INTEGER,    DIMENSION(:), ALLOCATABLE   :: COLUMN__		  INTEGER,    DIMENSION(:), ALLOCATABLE   :: COLUMN__
  INTEGER,    DIMENSION(:), ALLOCATABLE   :: ROW_INDEX__	  INTEGER,    DIMENSION(:), ALLOCATABLE   :: ROW_INDEX__


  ! THESE ARE GLOBAL DEFINITIONS OF ARRAYS NEEDED TO STORE TH	  ! THESE ARE GLOBAL DEFINITIONS OF ARRAYS NEEDED TO STORE TH
  ! FOURIER COMPONENTS AND SPECTRUM OF THE MICROMOTION OPERAT	  ! FOURIER COMPONENTS AND SPECTRUM OF THE MICROMOTION OPERAT
  ! OF A DRESSING SUBSET 					  ! OF A DRESSING SUBSET 

  COMPLEX*16,       DIMENSION(:,:), ALLOCATABLE :: U_FD__	  COMPLEX*16,       DIMENSION(:,:), ALLOCATABLE :: U_FD__
  DOUBLE PRECISION, DIMENSION(:),   ALLOCATABLE :: E_DRESSED_	  DOUBLE PRECISION, DIMENSION(:),   ALLOCATABLE :: E_DRESSED_

END MODULE MODES_4F						END MODULE MODES_4F


SUBROUTINE COUPLINGINIT_C(DB,NF,ATOM__C,COUPLING_C,INFO) 	SUBROUTINE COUPLINGINIT_C(DB,NF,ATOM__C,COUPLING_C,INFO) 
  ! CUOPLING_C AND ATOM_C ARE C STRUCTURES			  ! CUOPLING_C AND ATOM_C ARE C STRUCTURES

  USE TYPES_C							  USE TYPES_C
  USE MODES_4F							  USE MODES_4F
  IMPLICIT NONE							  IMPLICIT NONE
  								  
  INTEGER,                    INTENT(IN)    :: NF,DB		  INTEGER,                    INTENT(IN)    :: NF,DB
  TYPE(ATOM_C),               INTENT(IN)    :: ATOM__C		  TYPE(ATOM_C),               INTENT(IN)    :: ATOM__C
  TYPE(MODE_C),DIMENSION(NF), INTENT(IN)    :: COUPLING_C	  TYPE(MODE_C),DIMENSION(NF), INTENT(IN)    :: COUPLING_C
  INTEGER,                    INTENT(INOUT) :: INFO		  INTEGER,                    INTENT(INOUT) :: INFO
  								  
  INTEGER r							  INTEGER r

  IF(COUPLINGALLOCATED .EQV. .FALSE. ) THEN			  IF(COUPLINGALLOCATED .EQV. .FALSE. ) THEN
     ALLOCATE(COUPLING(NF))					     ALLOCATE(COUPLING(NF))
     COUPLINGALLOCATED = .TRUE.					     COUPLINGALLOCATED = .TRUE.
     DO r=1,NF							     DO r=1,NF
       ! ALLOCATE(COUPLING(r)%VALUES(DB*DB))			       ! ALLOCATE(COUPLING(r)%VALUES(DB*DB))
       ! ALLOCATE(COUPLING(r)%COLUMN(DB*DB))			       ! ALLOCATE(COUPLING(r)%COLUMN(DB*DB))
       ! ALLOCATE(COUPLING(r)%ROW(DB*DB))			       ! ALLOCATE(COUPLING(r)%ROW(DB*DB))
        ALLOCATE(COUPLING(r)%V(DB,DB))				        ALLOCATE(COUPLING(r)%V(DB,DB))
     END DO							     END DO
     ALLOCATE(ATOM_%E_BARE(DB))					     ALLOCATE(ATOM_%E_BARE(DB))
  END IF							  END IF
  								  
  DO r=1,NF							  DO r=1,NF
     COUPLING(r)%OMEGA  = COUPLING_C(r)%OMEGA			     COUPLING(r)%OMEGA  = COUPLING_C(r)%OMEGA
     !COUPLING(r)%VALUES = 0.0					     !COUPLING(r)%VALUES = 0.0
     !COUPLING(r)%ROW    = 0					     !COUPLING(r)%ROW    = 0
     !COUPLING(r)%COLUMN = 0					     !COUPLING(r)%COLUMN = 0
     COUPLING(r)%X      = COUPLING_C(r)%X			     COUPLING(r)%X      = COUPLING_C(r)%X
     COUPLING(r)%Y      = COUPLING_C(r)%Y			     COUPLING(r)%Y      = COUPLING_C(r)%Y
     COUPLING(r)%Z      = COUPLING_C(r)%Z			     COUPLING(r)%Z      = COUPLING_C(r)%Z
     COUPLING(r)%phi_x  = COUPLING_C(r)%phi_x			     COUPLING(r)%phi_x  = COUPLING_C(r)%phi_x
     COUPLING(r)%phi_y  = COUPLING_C(r)%phi_y			     COUPLING(r)%phi_y  = COUPLING_C(r)%phi_y
     COUPLING(r)%phi_z  = COUPLING_C(r)%phi_z			     COUPLING(r)%phi_z  = COUPLING_C(r)%phi_z
     COUPLING(r)%N_Floquet = COUPLING_C(r)%N_Floquet		     COUPLING(r)%N_Floquet = COUPLING_C(r)%N_Floquet
  END DO							  END DO
  								  
  ATOM_%id_system = ATOM__C%id_system				  ATOM_%id_system = ATOM__C%id_system
  ATOM_%D_BARE    = ATOM__C%D_BARE				  ATOM_%D_BARE    = ATOM__C%D_BARE
  								  
  INFO =0 							  INFO =0 

END SUBROUTINE COUPLINGINIT_C					END SUBROUTINE COUPLINGINIT_C

diff -y ./src/modes.f90 ../../Downloads/MultimodeFloquet-0.3/src/modes.f90
MODULE FEAST							MODULE FEAST
  integer     fpm(128)						  integer     fpm(128)
  real*8      Emin,Emax						  real*8      Emin,Emax
  real*8      epsout						  real*8      epsout
  integer     loop						  integer     loop
  integer     M0 ! initial guess 				  integer     M0 ! initial guess 
  integer     M1 ! total number of eigenvalues found		  integer     M1 ! total number of eigenvalues found
  integer     info_FEAST					  integer     info_FEAST
  real*8,     DIMENSION(:),   ALLOCATABLE :: E, RES ! vector 	  real*8,     DIMENSION(:),   ALLOCATABLE :: E, RES ! vector 
  complex*16, DIMENSION(:,:), ALLOCATABLE :: X      ! matrix 	  complex*16, DIMENSION(:,:), ALLOCATABLE :: X      ! matrix 
END MODULE FEAST						END MODULE FEAST

MODULE TYPES							MODULE TYPES

  TYPE :: MODE							  TYPE :: MODE
     DOUBLE PRECISION :: OMEGA					     DOUBLE PRECISION :: OMEGA
     COMPLEX*16       :: X,Y,Z					     COMPLEX*16       :: X,Y,Z
     DOUBLE PRECISION :: phi_x,phi_y,phi_z			     DOUBLE PRECISION :: phi_x,phi_y,phi_z
     INTEGER          :: N_Floquet				     INTEGER          :: N_Floquet
     COMPLEX*16, DIMENSION(:,:), ALLOCATABLE :: V		     COMPLEX*16, DIMENSION(:,:), ALLOCATABLE :: V
     COMPLEX*16, DIMENSION(:),   ALLOCATABLE :: VALUES		     COMPLEX*16, DIMENSION(:),   ALLOCATABLE :: VALUES
     INTEGER,    DIMENSION(:),   ALLOCATABLE :: ROW,COLUMN	     INTEGER,    DIMENSION(:),   ALLOCATABLE :: ROW,COLUMN
  END TYPE MODE							  END TYPE MODE
  								  
  TYPE :: ATOM							  TYPE :: ATOM
     INTEGER          :: id_system				     INTEGER          :: id_system
     INTEGER          :: D_BARE					     INTEGER          :: D_BARE
     DOUBLE PRECISION, DIMENSION(:), ALLOCATABLE :: E_BARE	     DOUBLE PRECISION, DIMENSION(:), ALLOCATABLE :: E_BARE
  END TYPE ATOM							  END TYPE ATOM

  TYPE :: HARMONIC_FACTORS					  TYPE :: HARMONIC_FACTORS
     COMPLEX*16,DIMENSION(:,:), ALLOCATABLE :: U,U_r,U_AVG	     COMPLEX*16,DIMENSION(:,:), ALLOCATABLE :: U,U_r,U_AVG
     INTEGER,   DIMENSION(:),   ALLOCATABLE :: n		     INTEGER,   DIMENSION(:),   ALLOCATABLE :: n
  END type HARMONIC_FACTORS					  END type HARMONIC_FACTORS

!!$  TYPE :: MWCOUPLING						!!$  TYPE :: MWCOUPLING
!!$     COMPLEX*16,DIMENSION(:,:),ALLOCATABLE :: TOP		!!$     COMPLEX*16,DIMENSION(:,:),ALLOCATABLE :: TOP
!!$     COMPLEX*16,DIMENSION(:,:),ALLOCATABLE :: TOP_DAGGER	!!$     COMPLEX*16,DIMENSION(:,:),ALLOCATABLE :: TOP_DAGGER
!!$     COMPLEX*16,DIMENSION(:,:),ALLOCATABLE :: DC		!!$     COMPLEX*16,DIMENSION(:,:),ALLOCATABLE :: DC
!!$     COMPLEX*16,DIMENSION(:,:),ALLOCATABLE :: DC_DAGGER	!!$     COMPLEX*16,DIMENSION(:,:),ALLOCATABLE :: DC_DAGGER
!!$     COMPLEX*16,DIMENSION(:,:),ALLOCATABLE :: MW		!!$     COMPLEX*16,DIMENSION(:,:),ALLOCATABLE :: MW
!!$     COMPLEX*16,DIMENSION(:,:),ALLOCATABLE :: MW_DAGGER	!!$     COMPLEX*16,DIMENSION(:,:),ALLOCATABLE :: MW_DAGGER
!!$     COMPLEX*16,DIMENSION(:,:),ALLOCATABLE :: RF		!!$     COMPLEX*16,DIMENSION(:,:),ALLOCATABLE :: RF
!!$     COMPLEX*16,DIMENSION(:,:),ALLOCATABLE :: RF_DAGGER	!!$     COMPLEX*16,DIMENSION(:,:),ALLOCATABLE :: RF_DAGGER
!!$  END type MWCOUPLING					!!$  END type MWCOUPLING
END MODULE TYPES						END MODULE TYPES

diff -y ./src/Modules.f90 ../../Downloads/MultimodeFloquet-0.3/src/Modules.f90
MODULE physical_constants					MODULE physical_constants
  IMPLICIT NONE							  IMPLICIT NONE
  DOUBLE PRECISION, PARAMETER :: pi           = 4.0*ATAN(1.0)	  DOUBLE PRECISION, PARAMETER :: pi           = 4.0*ATAN(1.0)
  DOUBLE PRECISION, PARAMETER :: e            = 1.602176462E-	  DOUBLE PRECISION, PARAMETER :: e            = 1.602176462E-
  DOUBLE PRECISION, PARAMETER :: h_P          = 6.62606957E-3	  DOUBLE PRECISION, PARAMETER :: h_P          = 6.62606957E-3
  DOUBLE PRECISION, PARAMETER :: hbar         = 1.054571800E-	  DOUBLE PRECISION, PARAMETER :: hbar         = 1.054571800E-
  DOUBLE PRECISION, PARAMETER :: mu_B         = 9.274009994E-	  DOUBLE PRECISION, PARAMETER :: mu_B         = 9.274009994E-
  DOUBLE PRECISION, PARAMETER :: k_B          = 1.3806488E-23	  DOUBLE PRECISION, PARAMETER :: k_B          = 1.3806488E-23
  DOUBLE PRECISION, PARAMETER :: mu_cero      = 12.566370614E	  DOUBLE PRECISION, PARAMETER :: mu_cero      = 12.566370614E
  DOUBLE PRECISION, PARAMETER :: epsilon_cero = 8.854187817E-	  DOUBLE PRECISION, PARAMETER :: epsilon_cero = 8.854187817E-
  DOUBLE PRECISION, PARAMETER :: amu          = 1.660538921E-	  DOUBLE PRECISION, PARAMETER :: amu          = 1.660538921E-
  DOUBLE PRECISION, PARAMETER :: g_t          = 9.8		  DOUBLE PRECISION, PARAMETER :: g_t          = 9.8
  DOUBLE PRECISION, PARAMETER :: SB_ct        = 5.6704E-8	  DOUBLE PRECISION, PARAMETER :: SB_ct        = 5.6704E-8
  COMPLEX*16,       PARAMETER :: J_IMAG       = DCMPLX(0.0,1.	  COMPLEX*16,       PARAMETER :: J_IMAG       = DCMPLX(0.0,1.
  DOUBLE PRECISION, PARAMETER :: speedoflight = 299792458.0	  DOUBLE PRECISION, PARAMETER :: speedoflight = 299792458.0
  DOUBLE PRECISION            :: TOTAL_TIME			  DOUBLE PRECISION            :: TOTAL_TIME
END MODULE physical_constants					END MODULE physical_constants

MODULE ARRAYS							MODULE ARRAYS

  DOUBLE PRECISION, DIMENSION(:,:), ALLOCATABLE :: Identity,j	  DOUBLE PRECISION, DIMENSION(:,:), ALLOCATABLE :: Identity,j
  COMPLEX*16,       DIMENSION(:,:), ALLOCATABLE :: HAMILTONIA	  COMPLEX*16,       DIMENSION(:,:), ALLOCATABLE :: HAMILTONIA
  COMPLEX*16,       DIMENSION(:,:), ALLOCATABLE :: H_IJ,U_ZEE	  COMPLEX*16,       DIMENSION(:,:), ALLOCATABLE :: H_IJ,U_ZEE
  COMPLEX*16,       DIMENSION(:,:), ALLOCATABLE :: H_FLOQUET_	  COMPLEX*16,       DIMENSION(:,:), ALLOCATABLE :: H_FLOQUET_
  !DOUBLE PRECISION, DIMENSION(:,:), ALLOCATABLE :: CLEBSH_GO	  !DOUBLE PRECISION, DIMENSION(:,:), ALLOCATABLE :: CLEBSH_GO
  !COMPLEX*16,       DIMENSION(:,:), ALLOCATABLE :: H_RF_DAGG	  !COMPLEX*16,       DIMENSION(:,:), ALLOCATABLE :: H_RF_DAGG
  !COMPLEX*16,       DIMENSION(:,:), ALLOCATABLE :: observabl	  !COMPLEX*16,       DIMENSION(:,:), ALLOCATABLE :: observabl
  !DOUBLE PRECISION, DIMENSION(:),   ALLOCATABLE :: W_SPACE,W	  !DOUBLE PRECISION, DIMENSION(:),   ALLOCATABLE :: W_SPACE,W
  !DOUBLE PRECISION, DIMENSION(:,:), ALLOCATABLE :: Fx,Fy,Fz,	  !DOUBLE PRECISION, DIMENSION(:,:), ALLOCATABLE :: Fx,Fy,Fz,
  !COMPLEX*16,       DIMENSION(:,:), ALLOCATABLE :: Hamiltoni	  !COMPLEX*16,       DIMENSION(:,:), ALLOCATABLE :: Hamiltoni
  !COMPLEX*16,       DIMENSION(:,:), ALLOCATABLE :: H_FLOQUET	  !COMPLEX*16,       DIMENSION(:,:), ALLOCATABLE :: H_FLOQUET
  !INTEGER,          DIMENSION(:,:), ALLOCATABLE :: F_t,H_w,H	  !INTEGER,          DIMENSION(:,:), ALLOCATABLE :: F_t,H_w,H
  !INTEGER,          DIMENSION(:),   ALLOCATABLE :: index_sta	  !INTEGER,          DIMENSION(:),   ALLOCATABLE :: index_sta
  !INTEGER                                       :: KD		  !INTEGER                                       :: KD
  !DOUBLE PRECISION, DIMENSION(3)                :: POSITION,	  !DOUBLE PRECISION, DIMENSION(3)                :: POSITION,

END MODULE ARRAYS						END MODULE ARRAYS
 								 
!!$MODULE DCRFMWFIELDS						!!$MODULE DCRFMWFIELDS
!!$ IMPLICIT NONE						!!$ IMPLICIT NONE
!!$  ! DC, RF and MW parameters					!!$  ! DC, RF and MW parameters
!!$  !! DC FIELD						!!$  !! DC FIELD
!!$  DOUBLE PRECISION B_DC_X, B_DC_Y, B_DC_Z   			!!$  DOUBLE PRECISION B_DC_X, B_DC_Y, B_DC_Z   
!!$								!!$
!!$  !! RF FIELD						!!$  !! RF FIELD
!!$  DOUBLE PRECISION  OMEGA_RF, PHI_RF_X,PHI_RF_Y,PHI_RF_Z	!!$  DOUBLE PRECISION  OMEGA_RF, PHI_RF_X,PHI_RF_Y,PHI_RF_Z
!!$  DOUBLE PRECISION  B_RF_X,B_RF_Y,B_RF_Z			!!$  DOUBLE PRECISION  B_RF_X,B_RF_Y,B_RF_Z
!!$								!!$
!!$  !! MW FIELD						!!$  !! MW FIELD
!!$  DOUBLE PRECISION  OMEGA_MW, PHI_MW_X,PHI_MW_Y,PHI_MW_Z	!!$  DOUBLE PRECISION  OMEGA_MW, PHI_MW_X,PHI_MW_Y,PHI_MW_Z
!!$  DOUBLE PRECISION  B_MW_X,B_MW_Y,B_MW_Z			!!$  DOUBLE PRECISION  B_MW_X,B_MW_Y,B_MW_Z
!!$								!!$
!!$END MODULE DCRFMWFIELDS					!!$END MODULE DCRFMWFIELDS

MODULE subinterface						MODULE subinterface
  IMPLICIT NONE							  IMPLICIT NONE
  INTERFACE							  INTERFACE
     SUBROUTINE I_and_J_representations(j_x,j_y,j_z,I_x,I_y,I	     SUBROUTINE I_and_J_representations(j_x,j_y,j_z,I_x,I_y,I
       								       
       IMPLICIT  NONE						       IMPLICIT  NONE
       DOUBLE PRECISION, DIMENSION(:,:),INTENT(INOUT) :: j_x,	       DOUBLE PRECISION, DIMENSION(:,:),INTENT(INOUT) :: j_x,
       DOUBLE PRECISION, INTENT(IN) :: L,S,I			       DOUBLE PRECISION, INTENT(IN) :: L,S,I
     END SUBROUTINE I_and_J_representations			     END SUBROUTINE I_and_J_representations

     SUBROUTINE F_representation(Fx,Fy,Fz,Ftotal_)       	     SUBROUTINE F_representation(Fx,Fy,Fz,Ftotal_)       
       								       
       IMPLICIT NONE						       IMPLICIT NONE
       DOUBLE PRECISION, DIMENSION(:,:), INTENT(OUT):: Fx,Fy,	       DOUBLE PRECISION, DIMENSION(:,:), INTENT(OUT):: Fx,Fy,
       DOUBLE PRECISION, INTENT(IN) :: Ftotal_			       DOUBLE PRECISION, INTENT(IN) :: Ftotal_
     END SUBROUTINE F_representation				     END SUBROUTINE F_representation
          							          

     SUBROUTINE SET_ATOMIC_PARAMETERS(ATOMICSPECIE,MANIFOLD,J	     SUBROUTINE SET_ATOMIC_PARAMETERS(ATOMICSPECIE,MANIFOLD,J
     !SUBROUTINE SET_ATOMIC_PARAMETERS(ATOMICSPECIE,MANIFOLD,	     !SUBROUTINE SET_ATOMIC_PARAMETERS(ATOMICSPECIE,MANIFOLD,
       ! ATOMICSPECIE: 87Rb,6Li,Cs,41K,qubit,lattice, SPIN	       ! ATOMICSPECIE: 87Rb,6Li,Cs,41K,qubit,lattice, SPIN
       ! MANIFOLD : "U" UPPER HYPERFINE MANIFOLD, "L" LOWER H	       ! MANIFOLD : "U" UPPER HYPERFINE MANIFOLD, "L" LOWER H
       ! JTOTAL   :  IF ATOMICSPECIE .EQ. SPIN THEN JTOTAL IS	       ! JTOTAL   :  IF ATOMICSPECIE .EQ. SPIN THEN JTOTAL IS
       !             IF ATOMICSPECIE .EQ. LATTICE, THEN JTOTA	       !             IF ATOMICSPECIE .EQ. LATTICE, THEN JTOTA
       USE TYPES						       USE TYPES
       IMPLICIT NONE						       IMPLICIT NONE
       CHARACTER (LEN=*),OPTIONAL, INTENT(IN) :: ATOMICSPECIE	       CHARACTER (LEN=*),OPTIONAL, INTENT(IN) :: ATOMICSPECIE
       CHARACTER (LEN=*),OPTIONAL, INTENT(IN) :: MANIFOLD  !	       CHARACTER (LEN=*),OPTIONAL, INTENT(IN) :: MANIFOLD  !
       !INTEGER,          OPTIONAL, INTENT(IN) :: JTOTAL	       !INTEGER,          OPTIONAL, INTENT(IN) :: JTOTAL
       DOUBLE PRECISION,          OPTIONAL, INTENT(IN) :: JTO	       DOUBLE PRECISION,          OPTIONAL, INTENT(IN) :: JTO
       TYPE(ATOM),OPTIONAL,INTENT(OUT) :: ID       		       TYPE(ATOM),OPTIONAL,INTENT(OUT) :: ID       
       INTEGER, INTENT(INOUT) :: INFO				       INTEGER, INTENT(INOUT) :: INFO
     END SUBROUTINE SET_ATOMIC_PARAMETERS			     END SUBROUTINE SET_ATOMIC_PARAMETERS

     SUBROUTINE MICROMOTIONFOURIERDRESSEDBASIS(ID,DRESSINGFIE	     SUBROUTINE MICROMOTIONFOURIERDRESSEDBASIS(ID,DRESSINGFIE
       ! ID        (in)    :: TYPE(ATOM) system ID		       ! ID        (in)    :: TYPE(ATOM) system ID
       ! DRESSINGFIELDS_INDICES (in) :: integer array indicat	       ! DRESSINGFIELDS_INDICES (in) :: integer array indicat
       ! MODES_NUM (in)    :: integer array indicating the nu	       ! MODES_NUM (in)    :: integer array indicating the nu
       ! FIELDS    (in)    :: Array of TYPE(MODE) of dimensio	       ! FIELDS    (in)    :: Array of TYPE(MODE) of dimensio
       ! U_FD      (out)   :: complex*16 matrix fourier decom	       ! U_FD      (out)   :: complex*16 matrix fourier decom
       ! E_DRESSED (out)   :: dressed energies			       ! E_DRESSED (out)   :: dressed energies
       ! INFO      (inout) :: error flag			       ! INFO      (inout) :: error flag
       USE TYPES						       USE TYPES

       TYPE(ATOM),                     INTENT(IN)  :: ID	       TYPE(ATOM),                     INTENT(IN)  :: ID
       INTEGER,    DIMENSION(:),       INTENT(IN)  :: DRESSIN	       INTEGER,    DIMENSION(:),       INTENT(IN)  :: DRESSIN
       INTEGER,    DIMENSION(:),       INTENT(IN)  :: MODES_N	       INTEGER,    DIMENSION(:),       INTENT(IN)  :: MODES_N
       TYPE(MODE), DIMENSION(:),       INTENT(IN)  :: FIELDS	       TYPE(MODE), DIMENSION(:),       INTENT(IN)  :: FIELDS
       COMPLEX*16, DIMENSION(:,:),     INTENT(OUT) :: U_FD	       COMPLEX*16, DIMENSION(:,:),     INTENT(OUT) :: U_FD
       DOUBLE PRECISION, DIMENSION(:), INTENT(OUT) :: E_DRESS	       DOUBLE PRECISION, DIMENSION(:), INTENT(OUT) :: E_DRESS
     END SUBROUTINE MICROMOTIONFOURIERDRESSEDBASIS		     END SUBROUTINE MICROMOTIONFOURIERDRESSEDBASIS

     SUBROUTINE MICROMOTIONDRESSEDBASIS(ID,MODES_NUM,DRESSING	     SUBROUTINE MICROMOTIONDRESSEDBASIS(ID,MODES_NUM,DRESSING
          & FIELDS,U_F_MODES,E_MULTIFLOQUET,T1,U,INFO) 		          & FIELDS,U_F_MODES,E_MULTIFLOQUET,T1,U,INFO) 
       								       
       ! ID (in)        :: TYPE(ATOM) system ID			       ! ID (in)        :: TYPE(ATOM) system ID
       ! MODES_NUM (in) :: integer array indicating the numbe	       ! MODES_NUM (in) :: integer array indicating the numbe
       ! DRESSINFIELDS_INDICES :: integer array indicating th	       ! DRESSINFIELDS_INDICES :: integer array indicating th
       ! FIELDS         :: Array of TYPE(MODES) with NM compo	       ! FIELDS         :: Array of TYPE(MODES) with NM compo
       ! U_F_MODES      :: complex*16 matrix of dimension DxD	       ! U_F_MODES      :: complex*16 matrix of dimension DxD
       ! E_MULTIFLOQUET :: dressed energies			       ! E_MULTIFLOQUET :: dressed energies
       ! T1             :: double precision, time		       ! T1             :: double precision, time
       ! U              :: complex*16 matrix of dimension D_B	       ! U              :: complex*16 matrix of dimension D_B
       ! INFO           :: error flag				       ! INFO           :: error flag
       								       
       								       
       USE TYPES						       USE TYPES
       IMPLICIT NONE						       IMPLICIT NONE
       TYPE(ATOM),                       INTENT(IN)    :: ID	       TYPE(ATOM),                       INTENT(IN)    :: ID
       INTEGER,          DIMENSION(:),   INTENT(IN)    :: MOD	       INTEGER,          DIMENSION(:),   INTENT(IN)    :: MOD
       INTEGER,          DIMENSION(:),   INTENT(IN)    :: DRE	       INTEGER,          DIMENSION(:),   INTENT(IN)    :: DRE
       COMPLEX*16,       DIMENSION(:,:), INTENT(IN)    :: U_F	       COMPLEX*16,       DIMENSION(:,:), INTENT(IN)    :: U_F
       DOUBLE PRECISION, DIMENSION(:),   INTENT(IN)    :: E_M	       DOUBLE PRECISION, DIMENSION(:),   INTENT(IN)    :: E_M
       TYPE(MODE),       DIMENSION(:),   INTENT(IN)    :: FIE	       TYPE(MODE),       DIMENSION(:),   INTENT(IN)    :: FIE
       DOUBLE PRECISION ,                INTENT(IN)    :: T1	       DOUBLE PRECISION ,                INTENT(IN)    :: T1
       COMPLEX*16,       DIMENSION(:,:), INTENT(OUT)   :: U	       COMPLEX*16,       DIMENSION(:,:), INTENT(OUT)   :: U
       INTEGER,                          INTENT(INOUT) :: INF	       INTEGER,                          INTENT(INOUT) :: INF
     END SUBROUTINE MICROMOTIONDRESSEDBASIS			     END SUBROUTINE MICROMOTIONDRESSEDBASIS
  END INTERFACE							  END INTERFACE
END MODULE subinterface						END MODULE subinterface


MODULE SUBINTERFACE_LAPACK					MODULE SUBINTERFACE_LAPACK

  IMPLICIT NONE							  IMPLICIT NONE
  PUBLIC 							  PUBLIC 
  INTERFACE							  INTERFACE
!     SUBROUTINE LAPACK_FULLEIGENVALUES(H,N,W_SPACE,INFO)	!     SUBROUTINE LAPACK_FULLEIGENVALUES(H,N,W_SPACE,INFO)
!       IMPLICIT NONE						!       IMPLICIT NONE
!       INTEGER,                        INTENT(IN)    :: N	!       INTEGER,                        INTENT(IN)    :: N
!       COMPLEX*16, DIMENSION(:,:),     INTENT(INOUT) :: H  	!       COMPLEX*16, DIMENSION(:,:),     INTENT(INOUT) :: H  
!       DOUBLE PRECISION, DIMENSION(:), INTENT(OUT)   :: W_SP	!       DOUBLE PRECISION, DIMENSION(:), INTENT(OUT)   :: W_SP
!       INTEGER,                        INTENT(INOUT) :: INFO	!       INTEGER,                        INTENT(INOUT) :: INFO
!       							!       
!     END SUBROUTINE LAPACK_FULLEIGENVALUES			!     END SUBROUTINE LAPACK_FULLEIGENVALUES
!     								!     
!     SUBROUTINE LAPACK_SELECTEIGENVALUES(H,N,W_SPACE,L1,L2,Z	!     SUBROUTINE LAPACK_SELECTEIGENVALUES(H,N,W_SPACE,L1,L2,Z
!       							!       
!       INTEGER,                        INTENT(IN)    :: N,L1	!       INTEGER,                        INTENT(IN)    :: N,L1
!       COMPLEX*16, DIMENSION(:,:),     INTENT(INOUT) :: H	!       COMPLEX*16, DIMENSION(:,:),     INTENT(INOUT) :: H
!       COMPLEX*16, DIMENSION(:,:),     INTENT(OUT)   :: Z_M	!       COMPLEX*16, DIMENSION(:,:),     INTENT(OUT)   :: Z_M
!       DOUBLE PRECISION, DIMENSION(:), INTENT(OUT)   :: W_SP	!       DOUBLE PRECISION, DIMENSION(:), INTENT(OUT)   :: W_SP
!       INTEGER,                        INTENT(OUT)   :: INFO	!       INTEGER,                        INTENT(OUT)   :: INFO
!     END SUBROUTINE LAPACK_SELECTEIGENVALUES			!     END SUBROUTINE LAPACK_SELECTEIGENVALUES

     SUBROUTINE WRITE_MATRIX(A)					     SUBROUTINE WRITE_MATRIX(A)
       DOUBLE PRECISION, DIMENSION(:,:) :: A			       DOUBLE PRECISION, DIMENSION(:,:) :: A
     END SUBROUTINE  WRITE_MATRIX				     END SUBROUTINE  WRITE_MATRIX

     SUBROUTINE WRITE_MATRIX_INT(A)				     SUBROUTINE WRITE_MATRIX_INT(A)
       INTEGER, DIMENSION(:,:) :: A				       INTEGER, DIMENSION(:,:) :: A
     END SUBROUTINE  WRITE_MATRIX_INT				     END SUBROUTINE  WRITE_MATRIX_INT
     								     
  END INTERFACE							  END INTERFACE
END MODULE SUBINTERFACE_LAPACK					END MODULE SUBINTERFACE_LAPACK


diff -y ./src/MultimodeDressedBasis_C.f90 ../../Downloads/MultimodeFloquet-0.3/src/MultimodeDressedBasis_C.f90
SUBROUTINE DRESSEDBASIS_C(D,ID,NM,MODES_NUM,FIELDS,U_FD,E_DRE	SUBROUTINE DRESSEDBASIS_C(D,ID,NM,MODES_NUM,FIELDS,U_FD,E_DRE

!!$THIS SUBROUTINES CALCULATES THE TRANSFORMATION BETWEEN THE	!!$THIS SUBROUTINES CALCULATES THE TRANSFORMATION BETWEEN THE
!!$ D                            : DIMENSION OF THE MULTIMODE	!!$ D                            : DIMENSION OF THE MULTIMODE
!!$ ID (IN)                      : TYPE OF QUATUM SYSTEM	!!$ ID (IN)                      : TYPE OF QUATUM SYSTEM
!!$ NM (IN)                      : NUMBER OF MODES == NUMBER 	!!$ NM (IN)                      : NUMBER OF MODES == NUMBER 
!!$ MODES_NUM                    : VECTOR INDICATING THE NUMB	!!$ MODES_NUM                    : VECTOR INDICATING THE NUMB
!!$ FIELDS (IN)                  : AMPLITUDE, FREQUENCY AND P	!!$ FIELDS (IN)                  : AMPLITUDE, FREQUENCY AND P
!!$ U_FD (OUT)                   : THIS IS THE TRANSFORMATION	!!$ U_FD (OUT)                   : THIS IS THE TRANSFORMATION
!!$ E_DRESSED (OUT)              : DRESSED ENERGIES		!!$ E_DRESSED (OUT)              : DRESSED ENERGIES
!!$ INFO (INOUT)                 : INFO = 0 MEANS SUCESS	!!$ INFO (INOUT)                 : INFO = 0 MEANS SUCESS
               							               

  USE TYPES_C							  USE TYPES_C
  USE MODES_4F							  USE MODES_4F
  USE TYPES							  USE TYPES

  IMPLICIT NONE							  IMPLICIT NONE
  TYPE(MODE_C), DIMENSION(NM),     INTENT(IN)    :: FIELDS	  TYPE(MODE_C), DIMENSION(NM),     INTENT(IN)    :: FIELDS
  TYPE(ATOM_C),                    INTENT(IN)    :: ID		  TYPE(ATOM_C),                    INTENT(IN)    :: ID
  INTEGER,    DIMENSION(NM),     INTENT(IN)    :: MODES_NUM	  INTEGER,    DIMENSION(NM),     INTENT(IN)    :: MODES_NUM
  COMPLEX*16, DIMENSION(D,D),       INTENT(OUT)   :: U_FD	  COMPLEX*16, DIMENSION(D,D),       INTENT(OUT)   :: U_FD
  DOUBLE PRECISION, DIMENSION(D), INTENT(OUT)   :: E_DRESSED	  DOUBLE PRECISION, DIMENSION(D), INTENT(OUT)   :: E_DRESSED
  INTEGER,                       INTENT(IN)    :: NM,D		  INTEGER,                       INTENT(IN)    :: NM,D
  INTEGER,                       INTENT(INOUT) :: INFO		  INTEGER,                       INTENT(INOUT) :: INFO

  CALL DRESSEDBASIS(D,ATOM_,NM,MODES_NUM,COUPLING,U_FD,E_DRES	  CALL DRESSEDBASIS(D,ATOM_,NM,MODES_NUM,COUPLING,U_FD,E_DRES

END SUBROUTINE DRESSEDBASIS_C					END SUBROUTINE DRESSEDBASIS_C


SUBROUTINE DRESSEDBASIS_SUBSET_C(ID,DRESSINGFLOQUETDIMENSION,	SUBROUTINE DRESSEDBASIS_SUBSET_C(ID,DRESSINGFLOQUETDIMENSION,
        & NM,DRESSINGFIELDS_INDICES,MODES_NUM,FIELDS,U_FD,E_D	        & NM,DRESSINGFIELDS_INDICES,MODES_NUM,FIELDS,U_FD,E_D

!!$THIS SUBROUTINES CALCULATES THE TRANSFORMATION BETWEEN THE	!!$THIS SUBROUTINES CALCULATES THE TRANSFORMATION BETWEEN THE
!!$								!!$
!!$ ID (IN)                      : TYPE OF QUATUM SYSTEM	!!$ ID (IN)                      : TYPE OF QUATUM SYSTEM
!!$ DRESSINGFLOQUETDIMENSION(IN) : DIMENSION OF THE DRESSED F	!!$ DRESSINGFLOQUETDIMENSION(IN) : DIMENSION OF THE DRESSED F
!!$ DRESSINGFIELDS (IN)          : NUMBER OF DRESSING FIELDS	!!$ DRESSINGFIELDS (IN)          : NUMBER OF DRESSING FIELDS
!!$ NM (IN)                      : NUMBER OF MODES == NUMBER 	!!$ NM (IN)                      : NUMBER OF MODES == NUMBER 
!!$ DRESSINGFIELDS_INDICES       : OUT OF ALL THE DRIVING FIE	!!$ DRESSINGFIELDS_INDICES       : OUT OF ALL THE DRIVING FIE
!!$ MODES_NUM                    : VECTOR INDICATING THE NUMB	!!$ MODES_NUM                    : VECTOR INDICATING THE NUMB
!!$ FIELDS (IN)                  : AMPLITUDE, FREQUENCY AND P	!!$ FIELDS (IN)                  : AMPLITUDE, FREQUENCY AND P
!!$ U_FD (OUT)                   : THIS IS THE TRANSFORMATION	!!$ U_FD (OUT)                   : THIS IS THE TRANSFORMATION
!!$ E_DRESSED (OUT)              : DRESSED ENERGIES		!!$ E_DRESSED (OUT)              : DRESSED ENERGIES
!!$ INFO (INOUT)                 : INFO = 0 MEANS SUCESS	!!$ INFO (INOUT)                 : INFO = 0 MEANS SUCESS
               							               

  USE TYPES							  USE TYPES
  USE TYPES_C							  USE TYPES_C
  USE MODES_4F							  USE MODES_4F

  IMPLICIT NONE							  IMPLICIT NONE
  TYPE(MODE_C), DIMENSION(NM),                           INTE	  TYPE(MODE_C), DIMENSION(NM),                           INTE
  TYPE(ATOM_C),                                          INTE	  TYPE(ATOM_C),                                          INTE
  INTEGER,    DIMENSION(DRESSINGFIELDS),                 INTE	  INTEGER,    DIMENSION(DRESSINGFIELDS),                 INTE
  INTEGER,    DIMENSION(NM),                             INTE	  INTEGER,    DIMENSION(NM),                             INTE
  COMPLEX*16, DIMENSION(DRESSINGFLOQUETDIMENSION,DRESSINGFLOQ	  COMPLEX*16, DIMENSION(DRESSINGFLOQUETDIMENSION,DRESSINGFLOQ
  DOUBLE PRECISION, DIMENSION(DRESSINGFLOQUETDIMENSION), INTE	  DOUBLE PRECISION, DIMENSION(DRESSINGFLOQUETDIMENSION), INTE
  INTEGER,                                               INTE	  INTEGER,                                               INTE
  INTEGER,                                               INTE	  INTEGER,                                               INTE

  INTEGER,    DIMENSION(DRESSINGFIELDS):: DRESSINGFIELDS_INDI	  INTEGER,    DIMENSION(DRESSINGFIELDS):: DRESSINGFIELDS_INDI
  DRESSINGFIELDS_INDICES_ = DRESSINGFIELDS_INDICES + 1		  DRESSINGFIELDS_INDICES_ = DRESSINGFIELDS_INDICES + 1
  CALL DRESSEDBASIS_SUBSET(ATOM_,DRESSINGFLOQUETDIMENSION,DRE	  CALL DRESSEDBASIS_SUBSET(ATOM_,DRESSINGFLOQUETDIMENSION,DRE
    & NM,DRESSINGFIELDS_INDICES_,MODES_NUM,COUPLING,U_FD,E_DR	    & NM,DRESSINGFIELDS_INDICES_,MODES_NUM,COUPLING,U_FD,E_DR


END SUBROUTINE DRESSEDBASIS_SUBSET_C				END SUBROUTINE DRESSEDBASIS_SUBSET_C
diff -y ./src/MultimodeDressedBasis.f90 ../../Downloads/MultimodeFloquet-0.3/src/MultimodeDressedBasis.f90
SUBROUTINE DRESSEDBASIS(D,ID,NM,MODES_NUM,FIELDS,U_FD,E_DRESS	SUBROUTINE DRESSEDBASIS(D,ID,NM,MODES_NUM,FIELDS,U_FD,E_DRESS

!!$THIS SUBROUTINES CALCULATES THE TRANSFORMATION BETWEEN THE	!!$THIS SUBROUTINES CALCULATES THE TRANSFORMATION BETWEEN THE
!!$ D                            : DIMENSION OF THE MULTIMODE	!!$ D                            : DIMENSION OF THE MULTIMODE
!!$ ID (IN)                      : TYPE OF QUATUM SYSTEM	!!$ ID (IN)                      : TYPE OF QUATUM SYSTEM
!!$ NM (IN)                      : NUMBER OF MODES == NUMBER 	!!$ NM (IN)                      : NUMBER OF MODES == NUMBER 
!!$ MODES_NUM                    : VECTOR INDICATING THE NUMB	!!$ MODES_NUM                    : VECTOR INDICATING THE NUMB
!!$ FIELDS (IN)                  : AMPLITUDE, FREQUENCY AND P	!!$ FIELDS (IN)                  : AMPLITUDE, FREQUENCY AND P
!!$ U_FD (OUT)                   : THIS IS THE TRANSFORMATION	!!$ U_FD (OUT)                   : THIS IS THE TRANSFORMATION
!!$ E_DRESSED (OUT)              : DRESSED ENERGIES		!!$ E_DRESSED (OUT)              : DRESSED ENERGIES
!!$ INFO (INOUT)                 : INFO = 0 MEANS SUCESS	!!$ INFO (INOUT)                 : INFO = 0 MEANS SUCESS
               							               

  USE ATOMIC_PROPERTIES						  USE ATOMIC_PROPERTIES
  USE TYPES							  USE TYPES
  USE SUBINTERFACE						  USE SUBINTERFACE
  USE SUBINTERFACE_LAPACK					  USE SUBINTERFACE_LAPACK
!  USE FLOQUETINIT_ 						!  USE FLOQUETINIT_ 
  USE ARRAYS 							  USE ARRAYS 

  IMPLICIT NONE							  IMPLICIT NONE
  TYPE(MODE), DIMENSION(NM),     INTENT(IN)    :: FIELDS	  TYPE(MODE), DIMENSION(NM),     INTENT(IN)    :: FIELDS
  TYPE(ATOM),                    INTENT(IN)    :: ID		  TYPE(ATOM),                    INTENT(IN)    :: ID
  INTEGER,    DIMENSION(NM),     INTENT(IN)    :: MODES_NUM	  INTEGER,    DIMENSION(NM),     INTENT(IN)    :: MODES_NUM
  COMPLEX*16, DIMENSION(D,D),       INTENT(OUT)   :: U_FD	  COMPLEX*16, DIMENSION(D,D),       INTENT(OUT)   :: U_FD
  DOUBLE PRECISION, DIMENSION(D), INTENT(OUT)   :: E_DRESSED	  DOUBLE PRECISION, DIMENSION(D), INTENT(OUT)   :: E_DRESSED
  INTEGER,                       INTENT(IN)    :: NM,D		  INTEGER,                       INTENT(IN)    :: NM,D
  INTEGER,                       INTENT(INOUT) :: INFO		  INTEGER,                       INTENT(INOUT) :: INFO


  INTEGER r,m,FIELD_INDEX					  INTEGER r,m,FIELD_INDEX
  !INTEGER ND_,NM_						  !INTEGER ND_,NM_
  INTEGER TOTAL_FREQUENCIES					  INTEGER TOTAL_FREQUENCIES
  !TYPE(MODE), DIMENSION(DRESSINGFIELDS) :: FIELDS_		  !TYPE(MODE), DIMENSION(DRESSINGFIELDS) :: FIELDS_
  !TYPE(MODE), DIMENSION(:),ALLOCATABLE  :: FIELDS_		  !TYPE(MODE), DIMENSION(:),ALLOCATABLE  :: FIELDS_
  !INTEGER,    DIMENSION(DRESSINGFIELDS) :: MODES_NUM_		  !INTEGER,    DIMENSION(DRESSINGFIELDS) :: MODES_NUM_

  !NM_ = DRESSINGFIELDS						  !NM_ = DRESSINGFIELDS
  !ND_ = DRESSINGFIELDS						  !ND_ = DRESSINGFIELDS


  TOTAL_FREQUENCIES = SUM(MODES_NUM,1)				  TOTAL_FREQUENCIES = SUM(MODES_NUM,1)

  CALL SETHAMILTONIANCOMPONENTS(ID,NM,TOTAL_FREQUENCIES,MODES	  CALL SETHAMILTONIANCOMPONENTS(ID,NM,TOTAL_FREQUENCIES,MODES

  !--- FIND THE MULTIMODE FLOQUET SPECTRUM 			  !--- FIND THE MULTIMODE FLOQUET SPECTRUM 
  CALL MULTIMODEFLOQUETMATRIX(ID,NM,TOTAL_FREQUENCIES,MODES_N	  CALL MULTIMODEFLOQUETMATRIX(ID,NM,TOTAL_FREQUENCIES,MODES_N
  								  
  E_DRESSED = 0.0  						  E_DRESSED = 0.0  
  CALL LAPACK_FULLEIGENVALUES(H_FLOQUET,SIZE(H_FLOQUET,1),E_D	  CALL LAPACK_FULLEIGENVALUES(H_FLOQUET,SIZE(H_FLOQUET,1),E_D

  U_FD = H_FLOQUET ! FOURIER DECOMPOSITION OF THE STATES DRES	  U_FD = H_FLOQUET ! FOURIER DECOMPOSITION OF THE STATES DRES
  DEALLOCATE(H_FLOQUET)						  DEALLOCATE(H_FLOQUET)

END SUBROUTINE DRESSEDBASIS					END SUBROUTINE DRESSEDBASIS


SUBROUTINE DRESSEDBASIS_SUBSET(ID,DRESSINGFLOQUETDIMENSION,DR	SUBROUTINE DRESSEDBASIS_SUBSET(ID,DRESSINGFLOQUETDIMENSION,DR
        & DRESSINGFIELDS_INDICES,MODES_NUM,FIELDS,U_FD,E_DRES	        & DRESSINGFIELDS_INDICES,MODES_NUM,FIELDS,U_FD,E_DRES

!!$THIS SUBROUTINES CALCULATES THE TRANSFORMATION BETWEEN THE	!!$THIS SUBROUTINES CALCULATES THE TRANSFORMATION BETWEEN THE
!!$								!!$
!!$ ID (IN)                      : TYPE OF QUATUM SYSTEM	!!$ ID (IN)                      : TYPE OF QUATUM SYSTEM
!!$ DRESSINGFLOQUETDIMENSION(IN) : DIMENSION OF THE DRESSED F	!!$ DRESSINGFLOQUETDIMENSION(IN) : DIMENSION OF THE DRESSED F
!!$ DRESSINGFIELDS (IN)          : NUMBER OF DRESSING FIELDS	!!$ DRESSINGFIELDS (IN)          : NUMBER OF DRESSING FIELDS
!!$ NM (IN)                      : NUMBER OF MODES == NUMBER 	!!$ NM (IN)                      : NUMBER OF MODES == NUMBER 
!!$ DRESSINGFIELDS_INDICES       : OUT OF ALL THE DRIVING FIE	!!$ DRESSINGFIELDS_INDICES       : OUT OF ALL THE DRIVING FIE
!!$ MODES_NUM                    : VECTOR INDICATING THE NUMB	!!$ MODES_NUM                    : VECTOR INDICATING THE NUMB
!!$ FIELDS (IN)                  : AMPLITUDE, FREQUENCY AND P	!!$ FIELDS (IN)                  : AMPLITUDE, FREQUENCY AND P
!!$ U_FD (OUT)                   : THIS IS THE TRANSFORMATION	!!$ U_FD (OUT)                   : THIS IS THE TRANSFORMATION
!!$ E_DRESSED (OUT)              : DRESSED ENERGIES		!!$ E_DRESSED (OUT)              : DRESSED ENERGIES
!!$ INFO (INOUT)                 : INFO = 0 MEANS SUCESS	!!$ INFO (INOUT)                 : INFO = 0 MEANS SUCESS
               							               

  USE ATOMIC_PROPERTIES						  USE ATOMIC_PROPERTIES
  USE TYPES							  USE TYPES
  USE SUBINTERFACE						  USE SUBINTERFACE
  USE SUBINTERFACE_LAPACK					  USE SUBINTERFACE_LAPACK
!  USE FLOQUETINIT_ 						!  USE FLOQUETINIT_ 
  USE ARRAYS 							  USE ARRAYS 

  IMPLICIT NONE							  IMPLICIT NONE
  INTEGER,                                               INTE	  INTEGER,                                               INTE
  INTEGER,                                               INTE	  INTEGER,                                               INTE
  TYPE(MODE), DIMENSION(NM),                             INTE	  TYPE(MODE), DIMENSION(NM),                             INTE
  TYPE(ATOM),                                            INTE	  TYPE(ATOM),                                            INTE
  INTEGER,    DIMENSION(DRESSINGFIELDS),                 INTE	  INTEGER,    DIMENSION(DRESSINGFIELDS),                 INTE
  INTEGER,    DIMENSION(NM),                             INTE	  INTEGER,    DIMENSION(NM),                             INTE
  COMPLEX*16, DIMENSION(DRESSINGFLOQUETDIMENSION,DRESSINGFLOQ	  COMPLEX*16, DIMENSION(DRESSINGFLOQUETDIMENSION,DRESSINGFLOQ
  DOUBLE PRECISION, DIMENSION(DRESSINGFLOQUETDIMENSION), INTE	  DOUBLE PRECISION, DIMENSION(DRESSINGFLOQUETDIMENSION), INTE
  INTEGER,                                               INTE	  INTEGER,                                               INTE


  INTEGER r,m,FIELD_INDEX					  INTEGER r,m,FIELD_INDEX
  INTEGER ND_,NM_						  INTEGER ND_,NM_
  INTEGER TOTAL_FREQUENCIES_					  INTEGER TOTAL_FREQUENCIES_
  TYPE(MODE), DIMENSION(:),ALLOCATABLE  :: FIELDS_		  TYPE(MODE), DIMENSION(:),ALLOCATABLE  :: FIELDS_
  INTEGER,    DIMENSION(DRESSINGFIELDS) :: MODES_NUM_		  INTEGER,    DIMENSION(DRESSINGFIELDS) :: MODES_NUM_


!  write(*,*)"non-SP A:", DRESSINGFIELDS_INDICES		!  write(*,*)"non-SP A:", DRESSINGFIELDS_INDICES

  DO r=1,DRESSINGFIELDS						  DO r=1,DRESSINGFIELDS
     MODES_NUM_(r)=modes_num(DRESSINGFIELDS_INDICES(r))		     MODES_NUM_(r)=modes_num(DRESSINGFIELDS_INDICES(r))
  END DO							  END DO

  TOTAL_FREQUENCIES_ = SUM(MODES_NUM_,1)			  TOTAL_FREQUENCIES_ = SUM(MODES_NUM_,1)
  ALLOCATE(FIELDS_(TOTAL_FREQUENCIES_))				  ALLOCATE(FIELDS_(TOTAL_FREQUENCIES_))
  DO m=1,TOTAL_FREQUENCIES_					  DO m=1,TOTAL_FREQUENCIES_
     ALLOCATE(FIELDS_(m)%V(ID%D_BARE,ID%D_BARE))		     ALLOCATE(FIELDS_(m)%V(ID%D_BARE,ID%D_BARE))
  END DO							  END DO
 ! write(*,*) "non-SP:",dressingfields,modes_num_,total_frequ	 ! write(*,*) "non-SP:",dressingfields,modes_num_,total_frequ


  FIELD_INDEX = 1						  FIELD_INDEX = 1
  DO r=1,DRESSINGFIELDS						  DO r=1,DRESSINGFIELDS
     DO m=1,MODES_NUM_(r)					     DO m=1,MODES_NUM_(r)
        FIELDS_(FIELD_INDEX) = FIELDS(DRESSINGFIELDS_INDICES(	        FIELDS_(FIELD_INDEX) = FIELDS(DRESSINGFIELDS_INDICES(
        FIELD_INDEX = FIELD_INDEX+1				        FIELD_INDEX = FIELD_INDEX+1
     END DO							     END DO
  END DO							  END DO

 								 
  CALL SETHAMILTONIANCOMPONENTS(ID,size(modes_num_,1),total_f	  CALL SETHAMILTONIANCOMPONENTS(ID,size(modes_num_,1),total_f

  !--- FIND THE MULTIMODE FLOQUET SPECTRUM 			  !--- FIND THE MULTIMODE FLOQUET SPECTRUM 
  !write(*,*) DRESSINGFIELDS_INDICES,total_frequencies_,id%d_	  !write(*,*) DRESSINGFIELDS_INDICES,total_frequencies_,id%d_
  !CALL WRITE_MATRIX(ABS(FIELDS_(2)%V))				  !CALL WRITE_MATRIX(ABS(FIELDS_(2)%V))
  CALL MULTIMODEFLOQUETMATRIX(ID,size(modes_num_,1),total_fre	  CALL MULTIMODEFLOQUETMATRIX(ID,size(modes_num_,1),total_fre
  !call write_matrix(abs(h_floquet))				  !call write_matrix(abs(h_floquet))
  E_DRESSED = 0.0  						  E_DRESSED = 0.0  
  CALL LAPACK_FULLEIGENVALUES(H_FLOQUET,SIZE(H_FLOQUET,1),E_D	  CALL LAPACK_FULLEIGENVALUES(H_FLOQUET,SIZE(H_FLOQUET,1),E_D
!  call write_matrix(abs(h_floquet))				!  call write_matrix(abs(h_floquet))

  U_FD = H_FLOQUET ! FOURIER DECOMPOSITION OF THE STATES DRES	  U_FD = H_FLOQUET ! FOURIER DECOMPOSITION OF THE STATES DRES
  DEALLOCATE(H_FLOQUET) 					  DEALLOCATE(H_FLOQUET) 
  DEALLOCATE(FIELDS_)						  DEALLOCATE(FIELDS_)
  								  
END SUBROUTINE DRESSEDBASIS_SUBSET				END SUBROUTINE DRESSEDBASIS_SUBSET
diff -y ./src/MultimodeDressedBasis_SP_C.f90 ../../Downloads/MultimodeFloquet-0.3/src/MultimodeDressedBasis_SP_C.f90
SUBROUTINE DRESSEDBASIS_SP_C(D,ID,NM,MODES_NUM,FIELDS,U_FD,E_	SUBROUTINE DRESSEDBASIS_SP_C(D,ID,NM,MODES_NUM,FIELDS,U_FD,E_

!!$THIS SUBROUTINES CALCULATES THE TRANSFORMATION BETWEEN THE	!!$THIS SUBROUTINES CALCULATES THE TRANSFORMATION BETWEEN THE
!!$ D                            : DIMENSION OF THE MULTIMODE	!!$ D                            : DIMENSION OF THE MULTIMODE
!!$ ID (IN)                      : TYPE OF QUATUM SYSTEM	!!$ ID (IN)                      : TYPE OF QUATUM SYSTEM
!!$ NM (IN)                      : NUMBER OF MODES == NUMBER 	!!$ NM (IN)                      : NUMBER OF MODES == NUMBER 
!!$ MODES_NUM                    : VECTOR INDICATING THE NUMB	!!$ MODES_NUM                    : VECTOR INDICATING THE NUMB
!!$ FIELDS (IN)                  : AMPLITUDE, FREQUENCY AND P	!!$ FIELDS (IN)                  : AMPLITUDE, FREQUENCY AND P
!!$ U_FD (OUT)                   : THIS IS THE TRANSFORMATION	!!$ U_FD (OUT)                   : THIS IS THE TRANSFORMATION
!!$ E_DRESSED (OUT)              : DRESSED ENERGIES		!!$ E_DRESSED (OUT)              : DRESSED ENERGIES
!!$ INFO (INOUT)                 : INFO = 0 MEANS SUCESS	!!$ INFO (INOUT)                 : INFO = 0 MEANS SUCESS
               							               

  								  
  USE TYPES_C							  USE TYPES_C
  USE TYPES							  USE TYPES
  USE MODES_4F							  USE MODES_4F
  								  
  IMPLICIT NONE							  IMPLICIT NONE
  TYPE(MODE_C),     DIMENSION(NM),  INTENT(IN)    :: FIELDS	  TYPE(MODE_C),     DIMENSION(NM),  INTENT(IN)    :: FIELDS
  TYPE(ATOM_C),                     INTENT(IN)    :: ID		  TYPE(ATOM_C),                     INTENT(IN)    :: ID
  INTEGER,          DIMENSION(NM),  INTENT(IN)    :: MODES_NU	  INTEGER,          DIMENSION(NM),  INTENT(IN)    :: MODES_NU
  COMPLEX*16,       DIMENSION(D,D), INTENT(OUT)   :: U_FD	  COMPLEX*16,       DIMENSION(D,D), INTENT(OUT)   :: U_FD
  DOUBLE PRECISION, DIMENSION(D),   INTENT(OUT)   :: E_DRESSE	  DOUBLE PRECISION, DIMENSION(D),   INTENT(OUT)   :: E_DRESSE
  INTEGER,                          INTENT(IN)    :: NM,D	  INTEGER,                          INTENT(IN)    :: NM,D
  INTEGER,                          INTENT(INOUT) :: INFO	  INTEGER,                          INTENT(INOUT) :: INFO

  CALL DRESSEDBASIS_SP(D,ATOM_,NM,MODES_NUM,COUPLING,U_FD,E_D	  CALL DRESSEDBASIS_SP(D,ATOM_,NM,MODES_NUM,COUPLING,U_FD,E_D

  								  
END SUBROUTINE DRESSEDBASIS_SP_C				END SUBROUTINE DRESSEDBASIS_SP_C


SUBROUTINE DRESSEDBASIS_SUBSET_SP_C(ID,DRESSINGFLOQUETDIMENSI	SUBROUTINE DRESSEDBASIS_SUBSET_SP_C(ID,DRESSINGFLOQUETDIMENSI
        & DRESSINGFIELDS_INDICES,MODES_NUM,FIELDS,U_FD,E_DRES	        & DRESSINGFIELDS_INDICES,MODES_NUM,FIELDS,U_FD,E_DRES

!!$THIS SUBROUTINES CALCULATES THE TRANSFORMATION BETWEEN THE	!!$THIS SUBROUTINES CALCULATES THE TRANSFORMATION BETWEEN THE
!!$								!!$
!!$ ID (IN)                      : TYPE OF QUATUM SYSTEM	!!$ ID (IN)                      : TYPE OF QUATUM SYSTEM
!!$ DRESSINGFLOQUETDIMENSION(IN) : DIMENSION OF THE DRESSED F	!!$ DRESSINGFLOQUETDIMENSION(IN) : DIMENSION OF THE DRESSED F
!!$ DRESSINGFIELDS (IN)          : NUMBER OF DRESSING FIELDS	!!$ DRESSINGFIELDS (IN)          : NUMBER OF DRESSING FIELDS
!!$ NM (IN)                      : NUMBER OF MODES == NUMBER 	!!$ NM (IN)                      : NUMBER OF MODES == NUMBER 
!!$ DRESSINGFIELDS_INDICES       : OUT OF ALL THE DRIVING FIE	!!$ DRESSINGFIELDS_INDICES       : OUT OF ALL THE DRIVING FIE
!!$ MODES_NUM                    : VECTOR INDICATING THE NUMB	!!$ MODES_NUM                    : VECTOR INDICATING THE NUMB
!!$ FIELDS (IN)                  : AMPLITUDE, FREQUENCY AND P	!!$ FIELDS (IN)                  : AMPLITUDE, FREQUENCY AND P
!!$ U_FD (OUT)                   : THIS IS THE TRANSFORMATION	!!$ U_FD (OUT)                   : THIS IS THE TRANSFORMATION
!!$ E_DRESSED (OUT)              : DRESSED ENERGIES		!!$ E_DRESSED (OUT)              : DRESSED ENERGIES
!!$ INFO (INOUT)                 : INFO = 0 MEANS SUCESS	!!$ INFO (INOUT)                 : INFO = 0 MEANS SUCESS
               							               

  USE TYPES_C							  USE TYPES_C
  USE TYPES							  USE TYPES
  USE MODES_4F							  USE MODES_4F

  IMPLICIT NONE							  IMPLICIT NONE
  INTEGER,                                               INTE	  INTEGER,                                               INTE
  INTEGER,                                               INTE	  INTEGER,                                               INTE
  TYPE(MODE_C), DIMENSION(NM),                           INTE	  TYPE(MODE_C), DIMENSION(NM),                           INTE
  TYPE(ATOM_C),                                          INTE	  TYPE(ATOM_C),                                          INTE
  INTEGER,    DIMENSION(DRESSINGFIELDS),                 INTE	  INTEGER,    DIMENSION(DRESSINGFIELDS),                 INTE
  INTEGER,    DIMENSION(NM),                             INTE	  INTEGER,    DIMENSION(NM),                             INTE
  COMPLEX*16, DIMENSION(DRESSINGFLOQUETDIMENSION,DRESSINGFLOQ	  COMPLEX*16, DIMENSION(DRESSINGFLOQUETDIMENSION,DRESSINGFLOQ
  DOUBLE PRECISION, DIMENSION(DRESSINGFLOQUETDIMENSION), INTE	  DOUBLE PRECISION, DIMENSION(DRESSINGFLOQUETDIMENSION), INTE
  INTEGER,                                               INTE	  INTEGER,                                               INTE

  INTEGER,    DIMENSION(DRESSINGFIELDS):: DRESSINGFIELDS_INDI	  INTEGER,    DIMENSION(DRESSINGFIELDS):: DRESSINGFIELDS_INDI
  DRESSINGFIELDS_INDICES_ = DRESSINGFIELDS_INDICES + 1		  DRESSINGFIELDS_INDICES_ = DRESSINGFIELDS_INDICES + 1

  CALL DRESSEDBASIS_SUBSET_SP(ATOM_,DRESSINGFLOQUETDIMENSION,	  CALL DRESSEDBASIS_SUBSET_SP(ATOM_,DRESSINGFLOQUETDIMENSION,
        & DRESSINGFIELDS_INDICES_,MODES_NUM,COUPLING,U_FD,E_D	        & DRESSINGFIELDS_INDICES_,MODES_NUM,COUPLING,U_FD,E_D
  								  
  								  
END SUBROUTINE DRESSEDBASIS_SUBSET_SP_C				END SUBROUTINE DRESSEDBASIS_SUBSET_SP_C
diff -y ./src/MultimodeDressedBasis_SP.f90 ../../Downloads/MultimodeFloquet-0.3/src/MultimodeDressedBasis_SP.f90
SUBROUTINE DRESSEDBASIS_SP(D,ID,NM,MODES_NUM,FIELDS,U_FD,E_DR	SUBROUTINE DRESSEDBASIS_SP(D,ID,NM,MODES_NUM,FIELDS,U_FD,E_DR

!!$THIS SUBROUTINES CALCULATES THE TRANSFORMATION BETWEEN THE	!!$THIS SUBROUTINES CALCULATES THE TRANSFORMATION BETWEEN THE
!!$ D                            : DIMENSION OF THE MULTIMODE	!!$ D                            : DIMENSION OF THE MULTIMODE
!!$ ID (IN)                      : TYPE OF QUATUM SYSTEM	!!$ ID (IN)                      : TYPE OF QUATUM SYSTEM
!!$ NM (IN)                      : NUMBER OF MODES == NUMBER 	!!$ NM (IN)                      : NUMBER OF MODES == NUMBER 
!!$ MODES_NUM                    : VECTOR INDICATING THE NUMB	!!$ MODES_NUM                    : VECTOR INDICATING THE NUMB
!!$ FIELDS (IN)                  : AMPLITUDE, FREQUENCY AND P	!!$ FIELDS (IN)                  : AMPLITUDE, FREQUENCY AND P
!!$ U_FD (OUT)                   : THIS IS THE TRANSFORMATION	!!$ U_FD (OUT)                   : THIS IS THE TRANSFORMATION
!!$ E_DRESSED (OUT)              : DRESSED ENERGIES		!!$ E_DRESSED (OUT)              : DRESSED ENERGIES
!!$ INFO (INOUT)                 : INFO = 0 MEANS SUCESS	!!$ INFO (INOUT)                 : INFO = 0 MEANS SUCESS
               							               

  USE ATOMIC_PROPERTIES						  USE ATOMIC_PROPERTIES
  USE TYPES							  USE TYPES
  USE SPARSE_INTERFACE						  USE SPARSE_INTERFACE
  USE SUBINTERFACE						  USE SUBINTERFACE
  USE SUBINTERFACE_LAPACK					  USE SUBINTERFACE_LAPACK
!  USE FLOQUETINIT_ 						!  USE FLOQUETINIT_ 
  USE ARRAYS 							  USE ARRAYS 

  IMPLICIT NONE							  IMPLICIT NONE
  TYPE(MODE), DIMENSION(NM),      INTENT(INOUT)    :: FIELDS	  TYPE(MODE), DIMENSION(NM),      INTENT(INOUT)    :: FIELDS
  TYPE(ATOM),                     INTENT(IN)    :: ID		  TYPE(ATOM),                     INTENT(IN)    :: ID
  INTEGER,    DIMENSION(NM),      INTENT(IN)    :: MODES_NUM	  INTEGER,    DIMENSION(NM),      INTENT(IN)    :: MODES_NUM
  COMPLEX*16, DIMENSION(D,D),     INTENT(OUT)   :: U_FD		  COMPLEX*16, DIMENSION(D,D),     INTENT(OUT)   :: U_FD
  DOUBLE PRECISION, DIMENSION(D), INTENT(OUT)   :: E_DRESSED	  DOUBLE PRECISION, DIMENSION(D), INTENT(OUT)   :: E_DRESSED
  INTEGER,                        INTENT(IN)    :: NM,D		  INTEGER,                        INTENT(IN)    :: NM,D
  INTEGER,                        INTENT(INOUT) :: INFO		  INTEGER,                        INTENT(INOUT) :: INFO


  INTEGER r,m,FIELD_INDEX					  INTEGER r,m,FIELD_INDEX
  !INTEGER ND_,NM_						  !INTEGER ND_,NM_
  INTEGER TOTAL_FREQUENCIES					  INTEGER TOTAL_FREQUENCIES

    !PARAMETERS NEEDED TO DEFINE THE SPARSE MATRIX		    !PARAMETERS NEEDED TO DEFINE THE SPARSE MATRIX
  INTEGER,    DIMENSION(:), ALLOCATABLE :: ROW_INDEX,COLUMN	  INTEGER,    DIMENSION(:), ALLOCATABLE :: ROW_INDEX,COLUMN
  COMPLEX*16, DIMENSION(:), ALLOCATABLE :: VALUES		  COMPLEX*16, DIMENSION(:), ALLOCATABLE :: VALUES
  !PARAMETERS TO DIAGONALIZE THE SPARSE MATRIX WITH MKL		  !PARAMETERS TO DIAGONALIZE THE SPARSE MATRIX WITH MKL
  DOUBLE PRECISION :: E_L,E_R					  DOUBLE PRECISION :: E_L,E_R


  TOTAL_FREQUENCIES = SUM(MODES_NUM,1)				  TOTAL_FREQUENCIES = SUM(MODES_NUM,1)



  CALL SETHAMILTONIANCOMPONENTS(ID,NM,TOTAL_FREQUENCIES,MODES	  CALL SETHAMILTONIANCOMPONENTS(ID,NM,TOTAL_FREQUENCIES,MODES

  !--- FIND THE MULTIMODE FLOQUET SPECTRUM 			  !--- FIND THE MULTIMODE FLOQUET SPECTRUM 
  CALL MULTIMODEFLOQUETMATRIX_SP(ID,NM,TOTAL_FREQUENCIES,MODE	  CALL MULTIMODEFLOQUETMATRIX_SP(ID,NM,TOTAL_FREQUENCIES,MODE

  E_L =  -2.0*MAXVAL(ABS(VALUES))				  E_L =  -2.0*MAXVAL(ABS(VALUES))
  E_R =   2.0*MAXVAL(ABS(VALUES))				  E_R =   2.0*MAXVAL(ABS(VALUES))
  E_DRESSED = 0.0						  E_DRESSED = 0.0
  U_FD = 0.0  							  U_FD = 0.0  
  CALL MKLSPARSE_FULLEIGENVALUES(D,SIZE(VALUES,1),VALUES,ROW_	  CALL MKLSPARSE_FULLEIGENVALUES(D,SIZE(VALUES,1),VALUES,ROW_

  								  
END SUBROUTINE DRESSEDBASIS_SP					END SUBROUTINE DRESSEDBASIS_SP

SUBROUTINE DRESSEDBASIS_SUBSET_SP(ID,DRESSINGFLOQUETDIMENSION	SUBROUTINE DRESSEDBASIS_SUBSET_SP(ID,DRESSINGFLOQUETDIMENSION
        & DRESSINGFIELDS_INDICES,MODES_NUM,FIELDS,U_FD,E_DRES	        & DRESSINGFIELDS_INDICES,MODES_NUM,FIELDS,U_FD,E_DRES

!!$THIS SUBROUTINES CALCULATES THE TRANSFORMATION BETWEEN THE	!!$THIS SUBROUTINES CALCULATES THE TRANSFORMATION BETWEEN THE
!!$								!!$
!!$ ID (IN)                      : TYPE OF QUATUM SYSTEM	!!$ ID (IN)                      : TYPE OF QUATUM SYSTEM
!!$ DRESSINGFLOQUETDIMENSION(IN) : DIMENSION OF THE DRESSED F	!!$ DRESSINGFLOQUETDIMENSION(IN) : DIMENSION OF THE DRESSED F
!!$ DRESSINGFIELDS (IN)          : NUMBER OF DRESSING FIELDS	!!$ DRESSINGFIELDS (IN)          : NUMBER OF DRESSING FIELDS
!!$ NM (IN)                      : NUMBER OF MODES == NUMBER 	!!$ NM (IN)                      : NUMBER OF MODES == NUMBER 
!!$ DRESSINGFIELDS_INDICES       : OUT OF ALL THE DRIVING FIE	!!$ DRESSINGFIELDS_INDICES       : OUT OF ALL THE DRIVING FIE
!!$ MODES_NUM                    : VECTOR INDICATING THE NUMB	!!$ MODES_NUM                    : VECTOR INDICATING THE NUMB
!!$ FIELDS (IN)                  : AMPLITUDE, FREQUENCY AND P	!!$ FIELDS (IN)                  : AMPLITUDE, FREQUENCY AND P
!!$ U_FD (OUT)                   : THIS IS THE TRANSFORMATION	!!$ U_FD (OUT)                   : THIS IS THE TRANSFORMATION
!!$ E_DRESSED (OUT)              : DRESSED ENERGIES		!!$ E_DRESSED (OUT)              : DRESSED ENERGIES
!!$ INFO (INOUT)                 : INFO = 0 MEANS SUCESS	!!$ INFO (INOUT)                 : INFO = 0 MEANS SUCESS
               							               

  USE ATOMIC_PROPERTIES						  USE ATOMIC_PROPERTIES
  USE TYPES							  USE TYPES
  USE SPARSE_INTERFACE						  USE SPARSE_INTERFACE
  USE SUBINTERFACE						  USE SUBINTERFACE
  USE SUBINTERFACE_LAPACK					  USE SUBINTERFACE_LAPACK
!  USE FLOQUETINIT_ 						!  USE FLOQUETINIT_ 
  USE ARRAYS 							  USE ARRAYS 

  IMPLICIT NONE							  IMPLICIT NONE
  INTEGER,                                               INTE	  INTEGER,                                               INTE
  INTEGER,                                               INTE	  INTEGER,                                               INTE
  TYPE(MODE), DIMENSION(NM),                             INTE	  TYPE(MODE), DIMENSION(NM),                             INTE
  TYPE(ATOM),                                            INTE	  TYPE(ATOM),                                            INTE
  INTEGER,    DIMENSION(DRESSINGFIELDS),                 INTE	  INTEGER,    DIMENSION(DRESSINGFIELDS),                 INTE
  INTEGER,    DIMENSION(NM),                             INTE	  INTEGER,    DIMENSION(NM),                             INTE
  COMPLEX*16, DIMENSION(DRESSINGFLOQUETDIMENSION,DRESSINGFLOQ	  COMPLEX*16, DIMENSION(DRESSINGFLOQUETDIMENSION,DRESSINGFLOQ
  DOUBLE PRECISION, DIMENSION(DRESSINGFLOQUETDIMENSION), INTE	  DOUBLE PRECISION, DIMENSION(DRESSINGFLOQUETDIMENSION), INTE
  INTEGER,                                               INTE	  INTEGER,                                               INTE


  INTEGER r,m,FIELD_INDEX					  INTEGER r,m,FIELD_INDEX
  INTEGER ND_,NM_						  INTEGER ND_,NM_
  INTEGER TOTAL_FREQUENCIES_					  INTEGER TOTAL_FREQUENCIES_
  TYPE(MODE), DIMENSION(:),ALLOCATABLE  :: FIELDS_		  TYPE(MODE), DIMENSION(:),ALLOCATABLE  :: FIELDS_
  INTEGER,    DIMENSION(DRESSINGFIELDS) :: MODES_NUM_		  INTEGER,    DIMENSION(DRESSINGFIELDS) :: MODES_NUM_


    !PARAMETERS NEEDED TO DEFINE THE SPARSE MATRIX		    !PARAMETERS NEEDED TO DEFINE THE SPARSE MATRIX
  INTEGER,    DIMENSION(:), ALLOCATABLE :: ROW_INDEX,COLUMN	  INTEGER,    DIMENSION(:), ALLOCATABLE :: ROW_INDEX,COLUMN
  COMPLEX*16, DIMENSION(:), ALLOCATABLE :: VALUES		  COMPLEX*16, DIMENSION(:), ALLOCATABLE :: VALUES
  !PARAMETERS TO DIAGONALIZE THE SPARSE MATRIX WITH MKL		  !PARAMETERS TO DIAGONALIZE THE SPARSE MATRIX WITH MKL
  DOUBLE PRECISION :: E_L,E_R					  DOUBLE PRECISION :: E_L,E_R

!  write(*,*)"SP A:", DRESSINGFIELDS_INDICES			!  write(*,*)"SP A:", DRESSINGFIELDS_INDICES
  DO r=1,DRESSINGFIELDS						  DO r=1,DRESSINGFIELDS
     MODES_NUM_(r)=modes_num(DRESSINGFIELDS_INDICES(r))		     MODES_NUM_(r)=modes_num(DRESSINGFIELDS_INDICES(r))
  END DO							  END DO

  TOTAL_FREQUENCIES_ = SUM(MODES_NUM_,1)			  TOTAL_FREQUENCIES_ = SUM(MODES_NUM_,1)
  ALLOCATE(FIELDS_(TOTAL_FREQUENCIES_))				  ALLOCATE(FIELDS_(TOTAL_FREQUENCIES_))
  DO m=1,TOTAL_FREQUENCIES_					  DO m=1,TOTAL_FREQUENCIES_
     ALLOCATE(FIELDS_(m)%V(ID%D_BARE,ID%D_BARE))		     ALLOCATE(FIELDS_(m)%V(ID%D_BARE,ID%D_BARE))
  END DO							  END DO
 ! write(*,*) "SP:",dressingfields,modes_num_,total_frequenci	 ! write(*,*) "SP:",dressingfields,modes_num_,total_frequenci


  FIELD_INDEX = 1						  FIELD_INDEX = 1
  DO r=1,DRESSINGFIELDS						  DO r=1,DRESSINGFIELDS
     DO m=1,MODES_NUM_(r)					     DO m=1,MODES_NUM_(r)
        FIELDS_(FIELD_INDEX) = FIELDS(DRESSINGFIELDS_INDICES(	        FIELDS_(FIELD_INDEX) = FIELDS(DRESSINGFIELDS_INDICES(
        FIELD_INDEX = FIELD_INDEX+1				        FIELD_INDEX = FIELD_INDEX+1
     END DO							     END DO
  END DO							  END DO

 								 
  CALL SETHAMILTONIANCOMPONENTS(ID,size(modes_num_,1),total_f	  CALL SETHAMILTONIANCOMPONENTS(ID,size(modes_num_,1),total_f

  !--- FIND THE MULTIMODE FLOQUET SPECTRUM 			  !--- FIND THE MULTIMODE FLOQUET SPECTRUM 
  CALL MULTIMODEFLOQUETMATRIX_SP(ID,SIZE(MODES_NUM_,1),total_	  CALL MULTIMODEFLOQUETMATRIX_SP(ID,SIZE(MODES_NUM_,1),total_
!  write(*,*) real(Values)					!  write(*,*) real(Values)
!  write(*,*) size(values,1), size(row_index,1), size(column,	!  write(*,*) size(values,1), size(row_index,1), size(column,
  E_L =  -4.0*MAXVAL(ABS(VALUES))				  E_L =  -4.0*MAXVAL(ABS(VALUES))
  E_R =   4.0*MAXVAL(ABS(VALUES))				  E_R =   4.0*MAXVAL(ABS(VALUES))
  E_DRESSED = 0.0						  E_DRESSED = 0.0
  U_FD = 0.0							  U_FD = 0.0
!  write(*,*) "Bounds:",E_L,E_R,DRESSINGFLOQUETDIMENSION,SIZE	!  write(*,*) "Bounds:",E_L,E_R,DRESSINGFLOQUETDIMENSION,SIZE
  CALL MKLSPARSE_FULLEIGENVALUES(DRESSINGFLOQUETDIMENSION,SIZ	  CALL MKLSPARSE_FULLEIGENVALUES(DRESSINGFLOQUETDIMENSION,SIZ
 								 
  DEALLOCATE(FIELDS_)						  DEALLOCATE(FIELDS_)
  								  
END SUBROUTINE DRESSEDBASIS_SUBSET_SP				END SUBROUTINE DRESSEDBASIS_SUBSET_SP
diff -y ./src/MultimodeFloquet.h ../../Downloads/MultimodeFloquet-0.3/src/MultimodeFloquet.h
extern "C" int h_floquet_size;					extern "C" int h_floquet_size;

struct mode_c{							struct mode_c{
  double omega;							  double omega;
  dcmplx x,y,z;							  dcmplx x,y,z;
  double phi_x,phi_y,phi_z;					  double phi_x,phi_y,phi_z;
  int N_Floquet;						  int N_Floquet;
};								};

struct atom_c{							struct atom_c{
  int id_system;						  int id_system;
  int d_bare;							  int d_bare;
};								};

/*								/*
void floquetinit_c_(atom_c * id_c , int *lenght_name, char *a	void floquetinit_c_(atom_c * id_c , int *lenght_name, char *a
  floquetinit_c__(id_c,atomicspecie,info);			  floquetinit_c__(id_c,atomicspecie,info);
}								}
void floquetinit_c_(atom_c * id_c , int *lenght_name, char *a	void floquetinit_c_(atom_c * id_c , int *lenght_name, char *a

}								}
void floquetinit_c_(atom_c * id_c , int *lenght_name, char *a	void floquetinit_c_(atom_c * id_c , int *lenght_name, char *a

}								}
*/								*/
extern "C" {							extern "C" {
  // GENERAL INIT SUBROUTINE					  // GENERAL INIT SUBROUTINE
  void floquetinit_old_c_(int *length_name, char *atomicspeci	  void floquetinit_old_c_(int *length_name, char *atomicspeci
  //void floquetinit_c_(int *length_name, char *atomicspecie,	  //void floquetinit_c_(int *length_name, char *atomicspecie,
  //void floquetinit_c_(atom_c *id_c, int *length_name, char 	  //void floquetinit_c_(atom_c *id_c, int *length_name, char 
  void floquetinit_qubit_c_(atom_c *id, int *lenght_name, cha	  void floquetinit_qubit_c_(atom_c *id, int *lenght_name, cha
  //void floquetinit_qubit_c_(atom_c *id,  int * info);		  //void floquetinit_qubit_c_(atom_c *id,  int * info);
  void floquetinit_spin_c_(atom_c *id, int *lenght_name, char	  void floquetinit_spin_c_(atom_c *id, int *lenght_name, char
  void floquetinit_alkali_c_(atom_c *id, int *lenght_name, ch	  void floquetinit_alkali_c_(atom_c *id, int *lenght_name, ch
       								       
  // SET HAMILTONIAN OF SPIN-LIKE MODELS			  // SET HAMILTONIAN OF SPIN-LIKE MODELS
  void  sethamiltoniancomponents_c_(atom_c *id,int * nm, int 	  void  sethamiltoniancomponents_c_(atom_c *id,int * nm, int 
  								  
  								  
  // BUILDING FLOQUET MATRIX OF GENERIC MODEL			  // BUILDING FLOQUET MATRIX OF GENERIC MODEL
  void    multimodefloquetmatrix_c_(atom_c *id,int * nm, int 	  void    multimodefloquetmatrix_c_(atom_c *id,int * nm, int 
  void multimodefloquetmatrix_sp_c_(atom_c *id,int * nm, int 	  void multimodefloquetmatrix_sp_c_(atom_c *id,int * nm, int 
  								  
  								  
  // CALCULATE THE SPECTRUM OF THE FLOQUET HAMILTONIAN		  // CALCULATE THE SPECTRUM OF THE FLOQUET HAMILTONIAN
  void   lapack_fulleigenvalues_c_(dcmplx * u_f,int * h_floqu	  void   lapack_fulleigenvalues_c_(dcmplx * u_f,int * h_floqu
  void mklsparse_fulleigenvalues_c_(int * h_floquet_size,doub	  void mklsparse_fulleigenvalues_c_(int * h_floquet_size,doub

  //void matmul_c_(int *op_lenght, char * op, dcmplx * a, int |	  void matmul_c_(int *op_lenght, char * op, dcmplx * a, int *
  void matmul_c_(int * op, dcmplx * a, int * ra, int * ca, dc <
  								  
  								  
  // CONTSRUCTION OF THE TIME-EVOLUTION OPERATOR		  // CONTSRUCTION OF THE TIME-EVOLUTION OPERATOR
  void         multimodetransitionavg_c_(int * h_floquet_size	  void         multimodetransitionavg_c_(int * h_floquet_size
  void multimodefloquettransformation_c_(int * h_floquet_size	  void multimodefloquettransformation_c_(int * h_floquet_size
  void multimodemicromotion_c_(atom_c *id,int * h_floquet_siz	  void multimodemicromotion_c_(atom_c *id,int * h_floquet_siz
  void multimodetimeevolutionoperator_c_(int * h_floquet_size	  void multimodetimeevolutionoperator_c_(int * h_floquet_size
  								  
    								    
  // DEFINITION OF DRESSED BASIS				  // DEFINITION OF DRESSED BASIS
  void            dressedbasis_c_(int * h_floquet_size,atom_c	  void            dressedbasis_c_(int * h_floquet_size,atom_c
  void  dressedbasis_subset_c_(atom_c *id , int * dressingflo	  void  dressedbasis_subset_c_(atom_c *id , int * dressingflo
  void  dressedbasis_subset_sp_c_(atom_c * id, int * dressing	  void  dressedbasis_subset_sp_c_(atom_c * id, int * dressing
  void  dressedbasis_sp_c_(int h_floquet_size, atom_c *id, in	  void  dressedbasis_sp_c_(int h_floquet_size, atom_c *id, in
  void micromotionfourierdressedbasis_c_(atom_c *id , int * d	  void micromotionfourierdressedbasis_c_(atom_c *id , int * d
  void micromotiondressedbasis_c_(atom_c *id , int * modes_nu	  void micromotiondressedbasis_c_(atom_c *id , int * modes_nu

  								  
  // UTILITY FUNCTION: EXTRACT GLOBAL VARIABLES WITH SCOPE ON	  // UTILITY FUNCTION: EXTRACT GLOBAL VARIABLES WITH SCOPE ON
  //                   H_FLOQUET : MULTIMODE FLOQUET HAMILTON	  //                   H_FLOQUET : MULTIMODE FLOQUET HAMILTON
  //                   VALUES, ROW,COLUMN: SPARSE REPRESETNAT	  //                   VALUES, ROW,COLUMN: SPARSE REPRESETNAT
  //                   VALUES, ROW_INDEX, COLUMN: SPARSE REPR	  //                   VALUES, ROW_INDEX, COLUMN: SPARSE REPR
  								  
  								  
  // UTILITY FUNCTIONS: WRITE MATRICES ON THE SCREEN		  // UTILITY FUNCTIONS: WRITE MATRICES ON THE SCREEN
  void write_matrix_c_(double *A,int * A_dim);			  void write_matrix_c_(double *A,int * A_dim);
  void rec_write_matrix_c_(double *A,int * A_dim1, int * A_di	  void rec_write_matrix_c_(double *A,int * A_dim1, int * A_di
  								  
  								  
  // UTILITY FUNCTION: MATRIX MULTIPLICATION WITH LAPACK	  // UTILITY FUNCTION: MATRIX MULTIPLICATION WITH LAPACK
  								  
} 								} 


void floquetinit_c(char *name,char *manifold,int *jtotal,atom	void floquetinit_c(char *name,char *manifold,int *jtotal,atom
  								  
  int length_name;						  int length_name;
  								  
  length_name = strlen(name);					  length_name = strlen(name);
  //  floquetinit_c_(&length_name,name,manifold,jtotal,id,inf	  //  floquetinit_c_(&length_name,name,manifold,jtotal,id,inf

}								}
void floquetinit_c(atom_c * id, char *name,int *info){		void floquetinit_c(atom_c * id, char *name,int *info){
  								  
  int length_name;						  int length_name;
  								  
  length_name = strlen(name);					  length_name = strlen(name);
  //printf("me\n");						  //printf("me\n");
  floquetinit_qubit_c_(id,&length_name,name,info);		  floquetinit_qubit_c_(id,&length_name,name,info);

}								}
void floquetinit_c(atom_c * id,char *name,char *manifold,int 	void floquetinit_c(atom_c * id,char *name,char *manifold,int 
  								  
  int length_name,length_name2;					  int length_name,length_name2;
  								  
  length_name = strlen(name);					  length_name = strlen(name);
  length_name2 = strlen(manifold);				  length_name2 = strlen(manifold);
  floquetinit_alkali_c_(id,&length_name,name,&length_name2,ma	  floquetinit_alkali_c_(id,&length_name,name,&length_name2,ma

}								}
 								 
void floquetinit_c(atom_c *id, char *name, double  *jtotal,in	void floquetinit_c(atom_c *id, char *name, double  *jtotal,in
  								  
  int length_name;						  int length_name;
  								  
  length_name = strlen(name);					  length_name = strlen(name);
  floquetinit_spin_c_(id,&length_name,name,jtotal,info);	  floquetinit_spin_c_(id,&length_name,name,jtotal,info);

}								}

void floquetinit_old_c(char *name,char *manifold,int *jtotal,	void floquetinit_old_c(char *name,char *manifold,int *jtotal,
  								  
  int length_name;						  int length_name;
  								  
  length_name = strlen(name);					  length_name = strlen(name);
  floquetinit_old_c_(&length_name,name,manifold,jtotal,id,inf	  floquetinit_old_c_(&length_name,name,manifold,jtotal,id,inf

}								}
/*							      |
void matmul_c(const char * op, dcmplx * a, int * ra, int * ca |	void matmul_c(char * op, dcmplx * a, int * ra, int * ca, dcmp
  int length_name;						  int length_name;
  								  
  length_name = strlen(op);					  length_name = strlen(op);
  matmul_c_(&length_name,op, a, ra, ca, b, rb, cb, c, info);	  matmul_c_(&length_name,op, a, ra, ca, b, rb, cb, c, info);
}							      <
*/							      <
void matmul_c(int * op , dcmplx * a, int * ra, int * ca, dcmp <
  //int length_name;					      <
  							      <
  // length_name = strlen(op);				      <
  printf("%i\n",*op);					      <
  matmul_c_(op, a, ra, ca, b, rb, cb, c, info);		      <
}								}
diff -y ./src/MultimodeFloquetTE_C.f90 ../../Downloads/MultimodeFloquet-0.3/src/MultimodeFloquetTE_C.f90
SUBROUTINE MULTIMODETIMEEVOLUTIONOPERATOR_C(D,NM,MODES_NUM,U_	SUBROUTINE MULTIMODETIMEEVOLUTIONOPERATOR_C(D,NM,MODES_NUM,U_

  ! TIME EVOLUTION OPERATOR OF A MULTIMODE DRESSED SYSTEM. TH	  ! TIME EVOLUTION OPERATOR OF A MULTIMODE DRESSED SYSTEM. TH
  ! MULTIMODE FLOQUET HAMILTONIAN				  ! MULTIMODE FLOQUET HAMILTONIAN
  ! U : MATRIX OF AMPLITUED OF PROBABILITIES FOR TRANSITIONS 	  ! U : MATRIX OF AMPLITUED OF PROBABILITIES FOR TRANSITIONS 
!!$  D              (IN)   : DIMENSION OF THE EXTENDED HILBER	!!$  D              (IN)   : DIMENSION OF THE EXTENDED HILBER
!!$  NM             (IN)   : NUMBER OF MODES            	!!$  NM             (IN)   : NUMBER OF MODES            
!!$  MODES_NUM      (IN)   : VECTOR (NM) INDICATING THE NUMBE	!!$  MODES_NUM      (IN)   : VECTOR (NM) INDICATING THE NUMBE
!!$  U_F_MODES      (IN)   : TRANSFORMATION, DIMENSOON (D,D) 	!!$  U_F_MODES      (IN)   : TRANSFORMATION, DIMENSOON (D,D) 
!!$  E_MULTIFLOQUET (IN)   : MULTIMODE FLOQUET SPECTRUM		!!$  E_MULTIFLOQUET (IN)   : MULTIMODE FLOQUET SPECTRUM
!!$  D_BARE         (IN)   : DIMENSION OF THE BARE HILBERT SP	!!$  D_BARE         (IN)   : DIMENSION OF THE BARE HILBERT SP
!!$  FIELD          (IN)   : STRUCTURE DESCRIBING THE COUPLIN	!!$  FIELD          (IN)   : STRUCTURE DESCRIBING THE COUPLIN
!!$  T1             (IN)   : INITIAL TIME			!!$  T1             (IN)   : INITIAL TIME
!!$  T2             (IN)   : FINAL TIME				!!$  T2             (IN)   : FINAL TIME
!!$  U              (OUT)  : TRANFORMATION BETWEEN THE EXTEND	!!$  U              (OUT)  : TRANFORMATION BETWEEN THE EXTEND
!!$  INFO           (INOUT): (POSSIBLE) ERROR FLAG		!!$  INFO           (INOUT): (POSSIBLE) ERROR FLAG

  USE TYPES_C							  USE TYPES_C
  USE TYPES							  USE TYPES
  USE MODES_4F							  USE MODES_4F


  IMPLICIT NONE							  IMPLICIT NONE
  INTEGER,                                    INTENT(IN)    :	  INTEGER,                                    INTENT(IN)    :
  INTEGER,                                    INTENT(INOUT) :	  INTEGER,                                    INTENT(INOUT) :
  INTEGER,          DIMENSION(NM),            INTENT(IN)    :	  INTEGER,          DIMENSION(NM),            INTENT(IN)    :
  TYPE(MODE_C),     DIMENSION(NM),            INTENT(IN)    :	  TYPE(MODE_C),     DIMENSION(NM),            INTENT(IN)    :
  DOUBLE PRECISION,                           INTENT(IN)    :	  DOUBLE PRECISION,                           INTENT(IN)    :
  DOUBLE PRECISION, DIMENSION(D),             INTENT(IN)    :	  DOUBLE PRECISION, DIMENSION(D),             INTENT(IN)    :
  COMPLEX*16,       DIMENSION(D,D),           INTENT(IN)    :	  COMPLEX*16,       DIMENSION(D,D),           INTENT(IN)    :
  COMPLEX*16,       DIMENSION(D_BARE,D_BARE), INTENT(OUT)   :	  COMPLEX*16,       DIMENSION(D_BARE,D_BARE), INTENT(OUT)   :

  CALL MULTIMODETIMEEVOLUTINOPERATOR(D,NM,MODES_NUM,U_F_MODES	  CALL MULTIMODETIMEEVOLUTINOPERATOR(D,NM,MODES_NUM,U_F_MODES

END SUBROUTINE MULTIMODETIMEEVOLUTIONOPERATOR_C			END SUBROUTINE MULTIMODETIMEEVOLUTIONOPERATOR_C

SUBROUTINE MULTIMODETIMEEVOLUTINOPERATOR_RESTRICTED_C(D,NF,U_	SUBROUTINE MULTIMODETIMEEVOLUTINOPERATOR_RESTRICTED_C(D,NF,U_

  ! TIME EVOLUTION OPERATOR OF A MULTIMODE DRESSED SYSTEM. TH	  ! TIME EVOLUTION OPERATOR OF A MULTIMODE DRESSED SYSTEM. TH
  ! MULTIMODE FLOQUET HAMILTONIAN				  ! MULTIMODE FLOQUET HAMILTONIAN
  ! U : MATRIX OF AMPLITUED OF PROBABILITIES FOR TRANSITIONS 	  ! U : MATRIX OF AMPLITUED OF PROBABILITIES FOR TRANSITIONS 
  !								  !
  ! BUT THE SUM OVER FLOQUET EIGENVALUES IS RESTRICTED TO THO	  ! BUT THE SUM OVER FLOQUET EIGENVALUES IS RESTRICTED TO THO
  ! THE SUBROUTINE HAS BEEN DESIGNED FOR 87Rb driven by RF+MW	  ! THE SUBROUTINE HAS BEEN DESIGNED FOR 87Rb driven by RF+MW
  ! D: THE DIMENSOIN OF THE MULTIMODE FLOQUET IS NOW DEFINED 	  ! D: THE DIMENSOIN OF THE MULTIMODE FLOQUET IS NOW DEFINED 
  ! the point of this is to make a comparison with MULTIMODET	  ! the point of this is to make a comparison with MULTIMODET
  ! MULTIMODETIMEEVOLUTIONOPERATOR SHOULD WORK FOR ANY ATOM/F	  ! MULTIMODETIMEEVOLUTIONOPERATOR SHOULD WORK FOR ANY ATOM/F
  ! MULTIMODETIMEEVOLUTIONOPEATOR_RESTRICTED IS DIFFICULT TO 	  ! MULTIMODETIMEEVOLUTIONOPEATOR_RESTRICTED IS DIFFICULT TO 
  ! STATES							  ! STATES

!!$  D              (IN)   : DIMENSION OF THE EXTENDED HILBER	!!$  D              (IN)   : DIMENSION OF THE EXTENDED HILBER
!!$  NM             (IN)   : NUMBER OF MODES            	!!$  NM             (IN)   : NUMBER OF MODES            
!!$  MODES_NUM      (IN)   : VECTOR (NM) INDICATING THE NUMBE	!!$  MODES_NUM      (IN)   : VECTOR (NM) INDICATING THE NUMBE
!!$  U_F_MODES      (IN)   : TRANSFORMATION, DIMENSOON (D,D) 	!!$  U_F_MODES      (IN)   : TRANSFORMATION, DIMENSOON (D,D) 
!!$  E_MULTIFLOQUET (IN)   : MULTIMODE FLOQUET SPECTRUM		!!$  E_MULTIFLOQUET (IN)   : MULTIMODE FLOQUET SPECTRUM
!!$  D_BARE         (IN)   : DIMENSION OF THE BARE HILBERT SP	!!$  D_BARE         (IN)   : DIMENSION OF THE BARE HILBERT SP
!!$  FIELD          (IN)   : STRUCTURE DESCRIBING THE COUPLIN	!!$  FIELD          (IN)   : STRUCTURE DESCRIBING THE COUPLIN
!!$  T1             (IN)   : INITIAL TIME			!!$  T1             (IN)   : INITIAL TIME
!!$  T2             (IN)   : FINAL TIME				!!$  T2             (IN)   : FINAL TIME
!!$  U              (OUT)  : TRANFORMATION BETWEEN THE EXTEND	!!$  U              (OUT)  : TRANFORMATION BETWEEN THE EXTEND
!!$  INFO           (INOUT): (POSSIBLE) ERROR FLAG		!!$  INFO           (INOUT): (POSSIBLE) ERROR FLAG

  								  
  USE TYPES_C							  USE TYPES_C
  USE TYPES							  USE TYPES
  USE MODES_4F							  USE MODES_4F
  !USE SUBINTERFACE_LAPACK					  !USE SUBINTERFACE_LAPACK


  IMPLICIT NONE							  IMPLICIT NONE
  INTEGER,                                    INTENT(IN)    :	  INTEGER,                                    INTENT(IN)    :
  INTEGER,                                    INTENT(INOUT) :	  INTEGER,                                    INTENT(INOUT) :
  TYPE(MODE_C),       DIMENSION(NF),     INTENT(IN)    :: FIE	  TYPE(MODE_C),       DIMENSION(NF),     INTENT(IN)    :: FIE
  DOUBLE PRECISION,                           INTENT(IN)    :	  DOUBLE PRECISION,                           INTENT(IN)    :
  DOUBLE PRECISION, DIMENSION(D),             INTENT(IN)    :	  DOUBLE PRECISION, DIMENSION(D),             INTENT(IN)    :
  COMPLEX*16,       DIMENSION(D,D),           INTENT(IN)    :	  COMPLEX*16,       DIMENSION(D,D),           INTENT(IN)    :
  COMPLEX*16,       DIMENSION(D_BARE,D_BARE), INTENT(OUT)   :	  COMPLEX*16,       DIMENSION(D_BARE,D_BARE), INTENT(OUT)   :

  CALL MULTIMODETIMEEVOLUTINOPERATOR_RESTRICTED(D,NF,U_F_MODE	  CALL MULTIMODETIMEEVOLUTINOPERATOR_RESTRICTED(D,NF,U_F_MODE


END SUBROUTINE MULTIMODETIMEEVOLUTINOPERATOR_RESTRICTED_C	END SUBROUTINE MULTIMODETIMEEVOLUTINOPERATOR_RESTRICTED_C




diff -y ./src/MultimodeFloquetTE_DRIVER_C.f90 ../../Downloads/MultimodeFloquet-0.3/src/MultimodeFloquetTE_DRIVER_C.f90
SUBROUTINE TIMEEVOLUTIONOPERATOR_C(ID,D_BARE,NM,MODES_NUM,FIE	SUBROUTINE TIMEEVOLUTIONOPERATOR_C(ID,D_BARE,NM,MODES_NUM,FIE
  ! TIME EVOLUTION OPERATOR OF A MULTIMODE DRESSED SYSTEM. TH	  ! TIME EVOLUTION OPERATOR OF A MULTIMODE DRESSED SYSTEM. TH
  ! MULTIMODE FLOQUET HAMILTONIAN				  ! MULTIMODE FLOQUET HAMILTONIAN
  ! U : MATRIX OF AMPLITUED OF PROBABILITIES FOR TRANSITIONS 	  ! U : MATRIX OF AMPLITUED OF PROBABILITIES FOR TRANSITIONS 
!!$  NM             (IN)   : NUMBER OF MODES            	!!$  NM             (IN)   : NUMBER OF MODES            
!!$  MODES_NUM      (IN)   : VECTOR (NM) INDICATING THE NUMBE	!!$  MODES_NUM      (IN)   : VECTOR (NM) INDICATING THE NUMBE
!!$  D_BARE         (IN)   : DIMENSION OF THE BARE HILBERT SP	!!$  D_BARE         (IN)   : DIMENSION OF THE BARE HILBERT SP
!!$  FIELD          (IN)   : STRUCTURE DESCRIBING THE COUPLIN	!!$  FIELD          (IN)   : STRUCTURE DESCRIBING THE COUPLIN
!!$  T1             (IN)   : INITIAL TIME			!!$  T1             (IN)   : INITIAL TIME
!!$  T2             (IN)   : FINAL TIME				!!$  T2             (IN)   : FINAL TIME
!!$  U              (OUT)  : TRANFORMATION BETWEEN THE EXTEND	!!$  U              (OUT)  : TRANFORMATION BETWEEN THE EXTEND
!!$  INFO           (INOUT): (POSSIBLE) ERROR FLAG		!!$  INFO           (INOUT): (POSSIBLE) ERROR FLAG
    								    
    USE TYPES_C							    USE TYPES_C
    USE TYPES							    USE TYPES
    USE MODES_4F						    USE MODES_4F

    								    
    IMPLICIT NONE						    IMPLICIT NONE
    TYPE(ATOM_C) ,                              INTENT(IN)   	    TYPE(ATOM_C) ,                              INTENT(IN)   
    INTEGER,                                    INTENT(IN)   	    INTEGER,                                    INTENT(IN)   
    INTEGER,                                    INTENT(IN)   	    INTEGER,                                    INTENT(IN)   
    INTEGER,          DIMENSION(NM),            INTENT(IN)   	    INTEGER,          DIMENSION(NM),            INTENT(IN)   
    TYPE(MODE_C),      DIMENSION(NM),            INTENT(IN)  	    TYPE(MODE_C),      DIMENSION(NM),            INTENT(IN)  
    DOUBLE PRECISION,                           INTENT(IN)   	    DOUBLE PRECISION,                           INTENT(IN)   
    DOUBLE PRECISION,                           INTENT(IN)   	    DOUBLE PRECISION,                           INTENT(IN)   
    COMPLEX*16,       DIMENSION(D_BARE,D_BARE), INTENT(OUT)  	    COMPLEX*16,       DIMENSION(D_BARE,D_BARE), INTENT(OUT)  
    INTEGER,                                    INTENT(INOUT)	    INTEGER,                                    INTENT(INOUT)
    								    
    CALL TIMEEVOLUTIONOPERATOR(ATOM_,D_BARE,NM,MODES_NUM,COUP	    CALL TIMEEVOLUTIONOPERATOR(ATOM_,D_BARE,NM,MODES_NUM,COUP
    								    
END SUBROUTINE TIMEEVOLUTIONOPERATOR_C				END SUBROUTINE TIMEEVOLUTIONOPERATOR_C

diff -y ./src/MultimodeFloquetTE_DRIVER.f90 ../../Downloads/MultimodeFloquet-0.3/src/MultimodeFloquetTE_DRIVER.f90
SUBROUTINE TIMEEVOLUTIONOPERATOR(ID,D_BARE,NM,MODES_NUM,FIELD	SUBROUTINE TIMEEVOLUTIONOPERATOR(ID,D_BARE,NM,MODES_NUM,FIELD
  ! TIME EVOLUTION OPERATOR OF A MULTIMODE DRESSED SYSTEM. TH	  ! TIME EVOLUTION OPERATOR OF A MULTIMODE DRESSED SYSTEM. TH
  ! MULTIMODE FLOQUET HAMILTONIAN				  ! MULTIMODE FLOQUET HAMILTONIAN
  ! U : MATRIX OF AMPLITUED OF PROBABILITIES FOR TRANSITIONS 	  ! U : MATRIX OF AMPLITUED OF PROBABILITIES FOR TRANSITIONS 
!!$  NM             (IN)   : NUMBER OF MODES            	!!$  NM             (IN)   : NUMBER OF MODES            
!!$  MODES_NUM      (IN)   : VECTOR (NM) INDICATING THE NUMBE	!!$  MODES_NUM      (IN)   : VECTOR (NM) INDICATING THE NUMBE
!!$  D_BARE         (IN)   : DIMENSION OF THE BARE HILBERT SP	!!$  D_BARE         (IN)   : DIMENSION OF THE BARE HILBERT SP
!!$  FIELD          (IN)   : STRUCTURE DESCRIBING THE COUPLIN	!!$  FIELD          (IN)   : STRUCTURE DESCRIBING THE COUPLIN
!!$  T1             (IN)   : INITIAL TIME			!!$  T1             (IN)   : INITIAL TIME
!!$  T2             (IN)   : FINAL TIME				!!$  T2             (IN)   : FINAL TIME
!!$  U              (OUT)  : TRANFORMATION BETWEEN THE EXTEND	!!$  U              (OUT)  : TRANFORMATION BETWEEN THE EXTEND
!!$  INFO           (INOUT): (POSSIBLE) ERROR FLAG		!!$  INFO           (INOUT): (POSSIBLE) ERROR FLAG
    								    
    USE ATOMIC_PROPERTIES					    USE ATOMIC_PROPERTIES
    USE TYPES							    USE TYPES
    USE SUBINTERFACE						    USE SUBINTERFACE
    USE SUBINTERFACE_LAPACK					    USE SUBINTERFACE_LAPACK
!    USE FLOQUETINIT_ 						!    USE FLOQUETINIT_ 
    USE ARRAYS 							    USE ARRAYS 

    								    
    IMPLICIT NONE						    IMPLICIT NONE
    TYPE(ATOM) ,                                INTENT(IN)   	    TYPE(ATOM) ,                                INTENT(IN)   
    INTEGER,                                    INTENT(IN)   	    INTEGER,                                    INTENT(IN)   
    INTEGER,                                    INTENT(IN)   	    INTEGER,                                    INTENT(IN)   
    INTEGER,          DIMENSION(NM),            INTENT(IN)   	    INTEGER,          DIMENSION(NM),            INTENT(IN)   
    TYPE(MODE),       DIMENSION(NM),            INTENT(IN)   	    TYPE(MODE),       DIMENSION(NM),            INTENT(IN)   
    DOUBLE PRECISION,                           INTENT(IN)   	    DOUBLE PRECISION,                           INTENT(IN)   
    DOUBLE PRECISION,                           INTENT(IN)   	    DOUBLE PRECISION,                           INTENT(IN)   
    COMPLEX*16,       DIMENSION(D_BARE,D_BARE), INTENT(OUT)  	    COMPLEX*16,       DIMENSION(D_BARE,D_BARE), INTENT(OUT)  
    INTEGER,                                    INTENT(INOUT)	    INTEGER,                                    INTENT(INOUT)
    								    
    INTEGER :: TOTAL_FREQUENCIES				    INTEGER :: TOTAL_FREQUENCIES
    DOUBLE PRECISION, DIMENSION(:), ALLOCATABLE :: E_FLOQUET	    DOUBLE PRECISION, DIMENSION(:), ALLOCATABLE :: E_FLOQUET
    COMPLEX*16, DIMENSION(:,:), ALLOCATABLE :: U_F		    COMPLEX*16, DIMENSION(:,:), ALLOCATABLE :: U_F
    								    
    								    
    TOTAL_FREQUENCIES = SUM(MODES_NUM,1)			    TOTAL_FREQUENCIES = SUM(MODES_NUM,1)

    								    
    IF(ID%id_system .NE. 6) CALL SETHAMILTONIANCOMPONENTS(ID,	    IF(ID%id_system .NE. 6) CALL SETHAMILTONIANCOMPONENTS(ID,
    !if id%id_system == 6, then the system is not a spin and 	    !if id%id_system == 6, then the system is not a spin and 
    								    
    !---- FIND THE MULTIMODE FLOQUET SPECTRUM 			    !---- FIND THE MULTIMODE FLOQUET SPECTRUM 
    CALL MULTIMODEFLOQUETMATRIX(ID,size(modes_num,1),total_fr	    CALL MULTIMODEFLOQUETMATRIX(ID,size(modes_num,1),total_fr
    !write(*,*) A*field(3)%omega/hbar,h_floquet(1,1)		    !write(*,*) A*field(3)%omega/hbar,h_floquet(1,1)

    								    
    ALLOCATE(E_FLOQUET(SIZE(H_FLOQUET,1)))			    ALLOCATE(E_FLOQUET(SIZE(H_FLOQUET,1)))
    ALLOCATE(U_F(SIZE(H_FLOQUET,1),SIZE(H_FLOQUET,1)))		    ALLOCATE(U_F(SIZE(H_FLOQUET,1),SIZE(H_FLOQUET,1)))
    E_FLOQUET = 0.0  						    E_FLOQUET = 0.0  
    !CALL WRITE_MATRIX(ABS(H_FLOQUET))				    !CALL WRITE_MATRIX(ABS(H_FLOQUET))
    CALL LAPACK_FULLEIGENVALUES(H_FLOQUET,SIZE(H_FLOQUET,1),E	    CALL LAPACK_FULLEIGENVALUES(H_FLOQUET,SIZE(H_FLOQUET,1),E
    U_F = H_FLOQUET ! FOURIER DECOMPOSITION OF THE STATES DRE	    U_F = H_FLOQUET ! FOURIER DECOMPOSITION OF THE STATES DRE
    !CALL WRITE_MATRIX(ABS(H_FLOQUET))				    !CALL WRITE_MATRIX(ABS(H_FLOQUET))
    DEALLOCATE(H_FLOQUET)					    DEALLOCATE(H_FLOQUET)
    !write(*,*) E_FLOQUET					    !write(*,*) E_FLOQUET
    !--- EVALUATE TIME-EVOLUTION OPERATOR IN THE BARE BASIS	    !--- EVALUATE TIME-EVOLUTION OPERATOR IN THE BARE BASIS
    CALL MULTIMODETIMEEVOLUTINOPERATOR(SIZE(U_F,1),SIZE(MODES	    CALL MULTIMODETIMEEVOLUTINOPERATOR(SIZE(U_F,1),SIZE(MODES
!    WRITE(*,*) (FIELD(3)%OMEGA)/(2*pi),T2,abs(U)**2		!    WRITE(*,*) (FIELD(3)%OMEGA)/(2*pi),T2,abs(U)**2

    DEALLOCATE(E_FLOQUET)					    DEALLOCATE(E_FLOQUET)
    DEALLOCATE(U_F)						    DEALLOCATE(U_F)
  								  

    								    
END SUBROUTINE TIMEEVOLUTIONOPERATOR				END SUBROUTINE TIMEEVOLUTIONOPERATOR

diff -y ./src/MultimodeFloquetTE.f90 ../../Downloads/MultimodeFloquet-0.3/src/MultimodeFloquetTE.f90
SUBROUTINE MULTIMODETIMEEVOLUTINOPERATOR(D,NM,MODES_NUM,U_F_M	SUBROUTINE MULTIMODETIMEEVOLUTINOPERATOR(D,NM,MODES_NUM,U_F_M

  ! TIME EVOLUTION OPERATOR OF A MULTIMODE DRESSED SYSTEM. TH	  ! TIME EVOLUTION OPERATOR OF A MULTIMODE DRESSED SYSTEM. TH
  ! MULTIMODE FLOQUET HAMILTONIAN				  ! MULTIMODE FLOQUET HAMILTONIAN
  ! U : MATRIX OF AMPLITUED OF PROBABILITIES FOR TRANSITIONS 	  ! U : MATRIX OF AMPLITUED OF PROBABILITIES FOR TRANSITIONS 
!!$  D              (IN)   : DIMENSION OF THE EXTENDED HILBER	!!$  D              (IN)   : DIMENSION OF THE EXTENDED HILBER
!!$  NM             (IN)   : NUMBER OF MODES            	!!$  NM             (IN)   : NUMBER OF MODES            
!!$  MODES_NUM      (IN)   : VECTOR (NM) INDICATING THE NUMBE	!!$  MODES_NUM      (IN)   : VECTOR (NM) INDICATING THE NUMBE
!!$  U_F_MODES      (IN)   : TRANSFORMATION, DIMENSOON (D,D) 	!!$  U_F_MODES      (IN)   : TRANSFORMATION, DIMENSOON (D,D) 
!!$  E_MULTIFLOQUET (IN)   : MULTIMODE FLOQUET SPECTRUM		!!$  E_MULTIFLOQUET (IN)   : MULTIMODE FLOQUET SPECTRUM
!!$  D_BARE         (IN)   : DIMENSION OF THE BARE HILBERT SP	!!$  D_BARE         (IN)   : DIMENSION OF THE BARE HILBERT SP
!!$  FIELD          (IN)   : STRUCTURE DESCRIBING THE COUPLIN	!!$  FIELD          (IN)   : STRUCTURE DESCRIBING THE COUPLIN
!!$  T1             (IN)   : INITIAL TIME			!!$  T1             (IN)   : INITIAL TIME
!!$  T2             (IN)   : FINAL TIME				!!$  T2             (IN)   : FINAL TIME
!!$  U              (OUT)  : TRANFORMATION BETWEEN THE EXTEND	!!$  U              (OUT)  : TRANFORMATION BETWEEN THE EXTEND
!!$  INFO           (INOUT): (POSSIBLE) ERROR FLAG		!!$  INFO           (INOUT): (POSSIBLE) ERROR FLAG

  USE TYPES							  USE TYPES
  USE SUBINTERFACE_LAPACK					  USE SUBINTERFACE_LAPACK


  IMPLICIT NONE							  IMPLICIT NONE
  INTEGER,                                    INTENT(IN)    :	  INTEGER,                                    INTENT(IN)    :
  INTEGER,                                    INTENT(INOUT) :	  INTEGER,                                    INTENT(INOUT) :
  INTEGER,          DIMENSION(NM),            INTENT(IN)    :	  INTEGER,          DIMENSION(NM),            INTENT(IN)    :
  TYPE(MODE),       DIMENSION(NM),            INTENT(IN)    :	  TYPE(MODE),       DIMENSION(NM),            INTENT(IN)    :
  DOUBLE PRECISION,                           INTENT(IN)    :	  DOUBLE PRECISION,                           INTENT(IN)    :
  DOUBLE PRECISION, DIMENSION(D),             INTENT(IN)    :	  DOUBLE PRECISION, DIMENSION(D),             INTENT(IN)    :
  COMPLEX*16,       DIMENSION(D,D),           INTENT(IN)    :	  COMPLEX*16,       DIMENSION(D,D),           INTENT(IN)    :
  COMPLEX*16,       DIMENSION(D_BARE,D_BARE), INTENT(OUT)   :	  COMPLEX*16,       DIMENSION(D_BARE,D_BARE), INTENT(OUT)   :

  COMPLEX*16, DIMENSION(D,D) :: U_DIAGONAL			  COMPLEX*16, DIMENSION(D,D) :: U_DIAGONAL
  COMPLEX*16, DIMENSION(D_BARE,D) :: U_AUX			  COMPLEX*16, DIMENSION(D_BARE,D) :: U_AUX

  INTEGER :: MULTIMODE_HARMONICS, n,i,j,m,index0,index1,FIELD	  INTEGER :: MULTIMODE_HARMONICS, n,i,j,m,index0,index1,FIELD
  DOUBLE PRECISION, DIMENSION(NM) :: OMEGA_VEC			  DOUBLE PRECISION, DIMENSION(NM) :: OMEGA_VEC
  INTEGER, DIMENSION(NM) :: N_FLOQUET				  INTEGER, DIMENSION(NM) :: N_FLOQUET
  TYPE(HARMONIC_FACTORS), DIMENSION(:),ALLOCATABLE:: U_MODES_	  TYPE(HARMONIC_FACTORS), DIMENSION(:),ALLOCATABLE:: U_MODES_
  DOUBLE PRECISION :: PHASE					  DOUBLE PRECISION :: PHASE

!  write(*,*) size(U_F_MODES)					!  write(*,*) size(U_F_MODES)
  MULTIMODE_HARMONICS   = D/D_BARE				  MULTIMODE_HARMONICS   = D/D_BARE

  N_FLOQUET = 0							  N_FLOQUET = 0
  OMEGA_VEC = 0							  OMEGA_VEC = 0

  DO n=2,NM							  DO n=2,NM
     FIELD_INDEX  = 2+SUM(MODES_NUM(2:n-1))			     FIELD_INDEX  = 2+SUM(MODES_NUM(2:n-1))
     N_FLOQUET(n) = FIELD(FIELD_INDEX)%N_Floquet		     N_FLOQUET(n) = FIELD(FIELD_INDEX)%N_Floquet
     OMEGA_VEC(n) = FIELD(FIELD_INDEX)%OMEGA 			     OMEGA_VEC(n) = FIELD(FIELD_INDEX)%OMEGA 
!     write(*,*) n,N_FLOQUET(n),field_index,modes_num(n)	!     write(*,*) n,N_FLOQUET(n),field_index,modes_num(n)
     IF(modes_num(n).GT.N_FLOQUET(n)+1) THEN			     IF(modes_num(n).GT.N_FLOQUET(n)+1) THEN
        WRITE(*,*) "TO BUILD THE EXTENDED HAMILTONIAN THE NUM	        WRITE(*,*) "TO BUILD THE EXTENDED HAMILTONIAN THE NUM
        WRITE(*,*) "LARGER THAN THE NUMBER OF FIELD MODES"	        WRITE(*,*) "LARGER THAN THE NUMBER OF FIELD MODES"
        INFO = -10						        INFO = -10
     END IF							     END IF
  END DO							  END DO

  ALLOCATE(U_MODES_n(MULTIMODE_HARMONICS))			  ALLOCATE(U_MODES_n(MULTIMODE_HARMONICS))

  DO n=1,MULTIMODE_HARMONICS					  DO n=1,MULTIMODE_HARMONICS
     ALLOCATE(U_MODES_n(n)%U(D_BARE,D))				     ALLOCATE(U_MODES_n(n)%U(D_BARE,D))
     U_MODES_n(n)%U = 0.0					     U_MODES_n(n)%U = 0.0
     ALLOCATE(U_MODES_n(n)%n(NM))				     ALLOCATE(U_MODES_n(n)%n(NM))
     U_MODES_n(n)%n = 0.0					     U_MODES_n(n)%n = 0.0
  END DO							  END DO

  DO i=0,MULTIMODE_HARMONICS-1					  DO i=0,MULTIMODE_HARMONICS-1
     U_MODES_n(i+1)%n = 0					     U_MODES_n(i+1)%n = 0
     index0 = i							     index0 = i
     DO j=2,NM							     DO j=2,NM
        U_MODES_n(i+1)%n(j)= -N_FLOQUET(j) + MOD(index0,(2*N_	        U_MODES_n(i+1)%n(j)= -N_FLOQUET(j) + MOD(index0,(2*N_
        index0 = INT(index0/(2*N_FLOQUET(j)+1))        		        index0 = INT(index0/(2*N_FLOQUET(j)+1))        
     END DO							     END DO
  END DO							  END DO

  i  = 1							  i  = 1
  DO index1=1,MULTIMODE_HARMONICS				  DO index1=1,MULTIMODE_HARMONICS
     DO n=1,D							     DO n=1,D
        j = n							        j = n
        i = 1 + (index1-1)*D_BARE 				        i = 1 + (index1-1)*D_BARE 
        DO m=1,D_BARE						        DO m=1,D_BARE
           U_MODES_n(index1)%U(m,n) = U_F_MODES(i,j)		           U_MODES_n(index1)%U(m,n) = U_F_MODES(i,j)
           i = i + 1           					           i = i + 1           
        END DO							        END DO
     END DO							     END DO
!     write(*,*) u_modes_n(index1)%U				!     write(*,*) u_modes_n(index1)%U
  END DO							  END DO

  index0 = (MULTIMODE_HARMONICS -1)/2 + 1			  index0 = (MULTIMODE_HARMONICS -1)/2 + 1
  U_AUX  =  U_MODES_n(index0)%U					  U_AUX  =  U_MODES_n(index0)%U


  U_DIAGONAL = 0.0						  U_DIAGONAL = 0.0
  DO i=1,D							  DO i=1,D
     U_DIAGONAL(i,i) = EXP(-DCMPLX(0.0,1.0)*E_MULTIFLOQUET(i)	     U_DIAGONAL(i,i) = EXP(-DCMPLX(0.0,1.0)*E_MULTIFLOQUET(i)
!     write(*,*) D,i,U_DIAGONAL(i,i),E_MULTIFLOQUET(i)!*(T2-T	!     write(*,*) D,i,U_DIAGONAL(i,i),E_MULTIFLOQUET(i)!*(T2-T
  END DO							  END DO

  DO index1=1,MULTIMODE_HARMONICS				  DO index1=1,MULTIMODE_HARMONICS
     U_MODES_n(index1)%U = MATMUL(U_MODES_n(index1)%U,U_DIAGO	     U_MODES_n(index1)%U = MATMUL(U_MODES_n(index1)%U,U_DIAGO
  END DO							  END DO

  U = 0.0							  U = 0.0
  DO index1=1,MULTIMODE_HARMONICS				  DO index1=1,MULTIMODE_HARMONICS
     PHASE = DOT_PRODUCT(U_MODES_n(index1)%n,omega_vec)*T2	     PHASE = DOT_PRODUCT(U_MODES_n(index1)%n,omega_vec)*T2
     U = U +  MATMUL(U_MODES_n(index1)%U,TRANSPOSE(CONJG(U_AU	     U = U +  MATMUL(U_MODES_n(index1)%U,TRANSPOSE(CONJG(U_AU
  END DO							  END DO
 ! write(*,*) abs(U)**2						 ! write(*,*) abs(U)**2
END SUBROUTINE MULTIMODETIMEEVOLUTINOPERATOR			END SUBROUTINE MULTIMODETIMEEVOLUTINOPERATOR

SUBROUTINE MULTIMODETIMEEVOLUTINOPERATOR_RESTRICTED(D,NF,U_F_	SUBROUTINE MULTIMODETIMEEVOLUTINOPERATOR_RESTRICTED(D,NF,U_F_

  ! TIME EVOLUTION OPERATOR OF A MULTIMODE DRESSED SYSTEM. TH	  ! TIME EVOLUTION OPERATOR OF A MULTIMODE DRESSED SYSTEM. TH
  ! MULTIMODE FLOQUET HAMILTONIAN				  ! MULTIMODE FLOQUET HAMILTONIAN
  ! U : MATRIX OF AMPLITUED OF PROBABILITIES FOR TRANSITIONS 	  ! U : MATRIX OF AMPLITUED OF PROBABILITIES FOR TRANSITIONS 
  !								  !
  ! BUT THE SUM OVER FLOQUET EIGENVALUES IS RESTRICTED TO THO	  ! BUT THE SUM OVER FLOQUET EIGENVALUES IS RESTRICTED TO THO
  ! THE SUBROUTINE HAS BEEN DESIGNED FOR 87Rb driven by RF+MW	  ! THE SUBROUTINE HAS BEEN DESIGNED FOR 87Rb driven by RF+MW
  ! D: THE DIMENSOIN OF THE MULTIMODE FLOQUET IS NOW DEFINED 	  ! D: THE DIMENSOIN OF THE MULTIMODE FLOQUET IS NOW DEFINED 
  ! the point of this is to make a comparison with MULTIMODET	  ! the point of this is to make a comparison with MULTIMODET
  ! MULTIMODETIMEEVOLUTIONOPERATOR SHOULD WORK FOR ANY ATOM/F	  ! MULTIMODETIMEEVOLUTIONOPERATOR SHOULD WORK FOR ANY ATOM/F
  ! MULTIMODETIMEEVOLUTIONOPEATOR_RESTRICTED IS DIFFICULT TO 	  ! MULTIMODETIMEEVOLUTIONOPEATOR_RESTRICTED IS DIFFICULT TO 
  ! STATES							  ! STATES

!!$  D              (IN)   : DIMENSION OF THE EXTENDED HILBER	!!$  D              (IN)   : DIMENSION OF THE EXTENDED HILBER
!!$  NM             (IN)   : NUMBER OF MODES            	!!$  NM             (IN)   : NUMBER OF MODES            
!!$  MODES_NUM      (IN)   : VECTOR (NM) INDICATING THE NUMBE	!!$  MODES_NUM      (IN)   : VECTOR (NM) INDICATING THE NUMBE
!!$  U_F_MODES      (IN)   : TRANSFORMATION, DIMENSOON (D,D) 	!!$  U_F_MODES      (IN)   : TRANSFORMATION, DIMENSOON (D,D) 
!!$  E_MULTIFLOQUET (IN)   : MULTIMODE FLOQUET SPECTRUM		!!$  E_MULTIFLOQUET (IN)   : MULTIMODE FLOQUET SPECTRUM
!!$  D_BARE         (IN)   : DIMENSION OF THE BARE HILBERT SP	!!$  D_BARE         (IN)   : DIMENSION OF THE BARE HILBERT SP
!!$  FIELD          (IN)   : STRUCTURE DESCRIBING THE COUPLIN	!!$  FIELD          (IN)   : STRUCTURE DESCRIBING THE COUPLIN
!!$  T1             (IN)   : INITIAL TIME			!!$  T1             (IN)   : INITIAL TIME
!!$  T2             (IN)   : FINAL TIME				!!$  T2             (IN)   : FINAL TIME
!!$  U              (OUT)  : TRANFORMATION BETWEEN THE EXTEND	!!$  U              (OUT)  : TRANFORMATION BETWEEN THE EXTEND
!!$  INFO           (INOUT): (POSSIBLE) ERROR FLAG		!!$  INFO           (INOUT): (POSSIBLE) ERROR FLAG


  USE TYPES							  USE TYPES
  USE SUBINTERFACE_LAPACK					  USE SUBINTERFACE_LAPACK


  IMPLICIT NONE							  IMPLICIT NONE
  INTEGER,                                    INTENT(IN)    :	  INTEGER,                                    INTENT(IN)    :
  INTEGER,                                    INTENT(INOUT) :	  INTEGER,                                    INTENT(INOUT) :
  TYPE(MODE),       DIMENSION(NF),     INTENT(IN)    :: FIELD	  TYPE(MODE),       DIMENSION(NF),     INTENT(IN)    :: FIELD
  DOUBLE PRECISION,                           INTENT(IN)    :	  DOUBLE PRECISION,                           INTENT(IN)    :
  DOUBLE PRECISION, DIMENSION(D),             INTENT(IN)    :	  DOUBLE PRECISION, DIMENSION(D),             INTENT(IN)    :
  COMPLEX*16,       DIMENSION(D,D),           INTENT(IN)    :	  COMPLEX*16,       DIMENSION(D,D),           INTENT(IN)    :
  COMPLEX*16,       DIMENSION(D_BARE,D_BARE), INTENT(OUT)   :	  COMPLEX*16,       DIMENSION(D_BARE,D_BARE), INTENT(OUT)   :

  COMPLEX*16, DIMENSION(:,:),ALLOCATABLE :: U_DIAGONAL		  COMPLEX*16, DIMENSION(:,:),ALLOCATABLE :: U_DIAGONAL
  COMPLEX*16, DIMENSION(:,:),ALLOCATABLE :: U_AUX		  COMPLEX*16, DIMENSION(:,:),ALLOCATABLE :: U_AUX

  INTEGER :: MULTIMODE_HARMONICS, n,i,j,m,index0,index1,D_r,i	  INTEGER :: MULTIMODE_HARMONICS, n,i,j,m,index0,index1,D_r,i
  DOUBLE PRECISION, DIMENSION(NF) :: OMEGA_VEC			  DOUBLE PRECISION, DIMENSION(NF) :: OMEGA_VEC
  TYPE(HARMONIC_FACTORS), DIMENSION(:),ALLOCATABLE:: U_MODES_	  TYPE(HARMONIC_FACTORS), DIMENSION(:),ALLOCATABLE:: U_MODES_
  DOUBLE PRECISION :: PHASE					  DOUBLE PRECISION :: PHASE
  DOUBLE PRECISION :: A,HBAR					  DOUBLE PRECISION :: A,HBAR

  MULTIMODE_HARMONICS   = D/D_BARE				  MULTIMODE_HARMONICS   = D/D_BARE
  IF(NF.GT.2) THEN						  IF(NF.GT.2) THEN
     D_r                   = (2*FIELD(3)%N_FLOQUET - 2)*(2*(F	     D_r                   = (2*FIELD(3)%N_FLOQUET - 2)*(2*(F
  END IF							  END IF
  Fup                   = 2					  Fup                   = 2
  Fdown                 = 1					  Fdown                 = 1
  hbar                  = 1.054E-34 				  hbar                  = 1.054E-34 
  A                     = 2.0*4.0*ATAN(1.0)*hbar*3.417341E9	  A                     = 2.0*4.0*ATAN(1.0)*hbar*3.417341E9

  DO i=1,NF							  DO i=1,NF
     OMEGA_VEC(i) = FIELD(i)%OMEGA				     OMEGA_VEC(i) = FIELD(i)%OMEGA
  END DO							  END DO

  ALLOCATE(U_MODES_n(MULTIMODE_HARMONICS))			  ALLOCATE(U_MODES_n(MULTIMODE_HARMONICS))

  DO n=1,MULTIMODE_HARMONICS					  DO n=1,MULTIMODE_HARMONICS
     ALLOCATE(U_MODES_n(n)%U(D_BARE,D))				     ALLOCATE(U_MODES_n(n)%U(D_BARE,D))
     U_MODES_n(n)%U = 0.0					     U_MODES_n(n)%U = 0.0
     ALLOCATE(U_MODES_n(n)%U_r(D_BARE,D_r))			     ALLOCATE(U_MODES_n(n)%U_r(D_BARE,D_r))
     U_MODES_n(n)%U_r = 0.0					     U_MODES_n(n)%U_r = 0.0
     ALLOCATE(U_MODES_n(n)%n(NF))				     ALLOCATE(U_MODES_n(n)%n(NF))
     U_MODES_n(n)%n = 0.0					     U_MODES_n(n)%n = 0.0
  END DO							  END DO

  DO i=0,MULTIMODE_HARMONICS-1					  DO i=0,MULTIMODE_HARMONICS-1
     U_MODES_n(i+1)%n = 0					     U_MODES_n(i+1)%n = 0
     index0 = i							     index0 = i
     DO j=2,NF							     DO j=2,NF
        U_MODES_n(i+1)%n(j)= -FIELD(j)%N_FLOQUET + MOD(index0	        U_MODES_n(i+1)%n(j)= -FIELD(j)%N_FLOQUET + MOD(index0
        index0 = INT(index0/(2*FIELD(j)%N_FLOQUET+1))		        index0 = INT(index0/(2*FIELD(j)%N_FLOQUET+1))
     END DO							     END DO
  END DO							  END DO

  i  = 1							  i  = 1
  DO index1=1,MULTIMODE_HARMONICS				  DO index1=1,MULTIMODE_HARMONICS
     DO n=1,D							     DO n=1,D
        j = n							        j = n
        i = 1 + (index1-1)*D_BARE 				        i = 1 + (index1-1)*D_BARE 
        DO m=1,D_BARE						        DO m=1,D_BARE
           U_MODES_n(index1)%U(m,n) = U_F_MODES(i,j)		           U_MODES_n(index1)%U(m,n) = U_F_MODES(i,j)
           i = i + 1           					           i = i + 1           
        END DO							        END DO
     END DO							     END DO
  END DO							  END DO

  index0 = (MULTIMODE_HARMONICS -1)/2 + 1			  index0 = (MULTIMODE_HARMONICS -1)/2 + 1


  !HOW MANY FLOQUET MODES AND WHICH ONES ARE WE GOING TO USE?	  !HOW MANY FLOQUET MODES AND WHICH ONES ARE WE GOING TO USE?
  !								  !
  ! D_r  = (2*FIELD(3)%N_FLOQUET - 2)*(2*(FIELD(2)%N_FLOQUET-	  ! D_r  = (2*FIELD(3)%N_FLOQUET - 2)*(2*(FIELD(2)%N_FLOQUET-

  ! (2*FIELD(3)%N_FLOQUET - 2)       : number of mw manifolds	  ! (2*FIELD(3)%N_FLOQUET - 2)       : number of mw manifolds
  ! (2*(FIELD(2)%N_FLOQUET - 2) - 1) : number of complete (i.	  ! (2*(FIELD(2)%N_FLOQUET - 2) - 1) : number of complete (i.
  ! Rb87%D_bare                : number of bare states		  ! Rb87%D_bare                : number of bare states

  !WITHIN EACH MW MANIFOLD, WE KEEP FLOQUETS MODES WITH INDIC	  !WITHIN EACH MW MANIFOLD, WE KEEP FLOQUETS MODES WITH INDIC
  ! I \IN  I_0+1, I_0 +  (2*(FIELD(2)%N_FLOQUET - 2) - 1)*Rb8	  ! I \IN  I_0+1, I_0 +  (2*(FIELD(2)%N_FLOQUET - 2) - 1)*Rb8
  ! WITH 							  ! WITH 
  ! I_0 = 3*(2*Fdown+2*Fup+2)+1					  ! I_0 = 3*(2*Fdown+2*Fup+2)+1
  ! and the starting index for each manifold is			  ! and the starting index for each manifold is
  ! (2*FIELD(2)%N_FLOQUET+1)*(2*Fdown+1)+(m)*(2*FIELD(2)%N_FL	  ! (2*FIELD(2)%N_FLOQUET+1)*(2*Fdown+1)+(m)*(2*FIELD(2)%N_FL
  ! with m the manifold number, but we keep manifolds m=1,(2*	  ! with m the manifold number, but we keep manifolds m=1,(2*


  ALLOCATE(U_DIAGONAL(D_r,D_r))					  ALLOCATE(U_DIAGONAL(D_r,D_r))
  ALLOCATE(U_AUX(D_bare,D_r))					  ALLOCATE(U_AUX(D_bare,D_r))


  n  = 1							  n  = 1
  U_DIAGONAL = 0.0						  U_DIAGONAL = 0.0
  DO i=1,(2*FIELD(3)%N_FLOQUET - 2)				  DO i=1,(2*FIELD(3)%N_FLOQUET - 2)
     I_0 = (2*FIELD(2)%N_FLOQUET+1)*(2*Fdown+1) + i*(2*FIELD(	     I_0 = (2*FIELD(2)%N_FLOQUET+1)*(2*Fdown+1) + i*(2*FIELD(
     DO j=1,(2*(FIELD(2)%N_FLOQUET-2)-1)*D_bare			     DO j=1,(2*(FIELD(2)%N_FLOQUET-2)-1)*D_bare

        i_r = I_0 + 3*(2*Fdown+2*Fup+2)+1 + j 			        i_r = I_0 + 3*(2*Fdown+2*Fup+2)+1 + j 
        U_DIAGONAL(n,n) = EXP(-DCMPLX(0.0,1.0)*E_MULTIFLOQUET	        U_DIAGONAL(n,n) = EXP(-DCMPLX(0.0,1.0)*E_MULTIFLOQUET
        n = n + 1						        n = n + 1
     END DO							     END DO
  END DO							  END DO

  DO index1=1,MULTIMODE_HARMONICS				  DO index1=1,MULTIMODE_HARMONICS
     n = 1							     n = 1
     DO i=1,(2*FIELD(3)%N_FLOQUET - 2)				     DO i=1,(2*FIELD(3)%N_FLOQUET - 2)
        I_0 = (2*FIELD(2)%N_FLOQUET+1)*(2*Fdown+1) + i*(2*FIE	        I_0 = (2*FIELD(2)%N_FLOQUET+1)*(2*Fdown+1) + i*(2*FIE
        DO j=1,(2*(FIELD(2)%N_FLOQUET-2)-1)*D_bare        	        DO j=1,(2*(FIELD(2)%N_FLOQUET-2)-1)*D_bare        
           i_r = I_0 + 3*(2*Fdown+2*Fup+2)+1 + j 		           i_r = I_0 + 3*(2*Fdown+2*Fup+2)+1 + j 
           U_MODES_n(index1)%U_r(:,n) = U_MODES_n(index1)%U(:	           U_MODES_n(index1)%U_r(:,n) = U_MODES_n(index1)%U(:
           n = n+1						           n = n+1
        END DO							        END DO
     END DO							     END DO
  END DO							  END DO

  index0 = (MULTIMODE_HARMONICS -1)/2 + 1			  index0 = (MULTIMODE_HARMONICS -1)/2 + 1
  U_AUX  =  U_MODES_n(index0)%U_r				  U_AUX  =  U_MODES_n(index0)%U_r


  DO index1=1,MULTIMODE_HARMONICS				  DO index1=1,MULTIMODE_HARMONICS
     U_MODES_n(index1)%U_r = MATMUL(U_MODES_n(index1)%U_r,U_D	     U_MODES_n(index1)%U_r = MATMUL(U_MODES_n(index1)%U_r,U_D
  END DO							  END DO

  U = 0.0							  U = 0.0
  DO index1=1,MULTIMODE_HARMONICS				  DO index1=1,MULTIMODE_HARMONICS
     PHASE = DOT_PRODUCT(U_MODES_n(index1)%n,omega_vec)*T2	     PHASE = DOT_PRODUCT(U_MODES_n(index1)%n,omega_vec)*T2
     U = U +  MATMUL(U_MODES_n(index1)%U_r,TRANSPOSE(CONJG(U_	     U = U +  MATMUL(U_MODES_n(index1)%U_r,TRANSPOSE(CONJG(U_
  END DO							  END DO


END SUBROUTINE MULTIMODETIMEEVOLUTINOPERATOR_RESTRICTED		END SUBROUTINE MULTIMODETIMEEVOLUTINOPERATOR_RESTRICTED




diff -y ./src/MultimodeHamiltonian_C.f90 ../../Downloads/MultimodeFloquet-0.3/src/MultimodeHamiltonian_C.f90
SUBROUTINE MULTIMODEFLOQUETMATRIX_C(ATOM__C,NM,NF,MODES_NUM,F	SUBROUTINE MULTIMODEFLOQUETMATRIX_C(ATOM__C,NM,NF,MODES_NUM,F
  !ID,size(modes_num,1),total_frequencies,MODES_NUM,FIELDS,IN	  !ID,size(modes_num,1),total_frequencies,MODES_NUM,FIELDS,IN
  !  USE FLOQUET						  !  USE FLOQUET
  !ATOM_C type atom, -> dimension of the bare Hilbert space	  !ATOM_C type atom, -> dimension of the bare Hilbert space
  !NM -> number of modes					  !NM -> number of modes
  !NF -> Number of Fields					  !NF -> Number of Fields
  !MODES_NUM -> number of harmonics of each mode		  !MODES_NUM -> number of harmonics of each mode
  !FIELD_C -> Field couplings					  !FIELD_C -> Field couplings
  !INFO								  !INFO

  USE ARRAYS							  USE ARRAYS
  USE TYPES_C							  USE TYPES_C
  USE MODES_4F							  USE MODES_4F

  IMPLICIT NONE							  IMPLICIT NONE
  INTEGER,                     INTENT(IN)    :: NM,NF		  INTEGER,                     INTENT(IN)    :: NM,NF
  INTEGER,                     INTENT(INOUT) :: INFO		  INTEGER,                     INTENT(INOUT) :: INFO
  INTEGER,      DIMENSION(NM), INTENT(IN)    :: MODES_NUM	  INTEGER,      DIMENSION(NM), INTENT(IN)    :: MODES_NUM
  TYPE(MODE_C), DIMENSION(NF), INTENT(IN)    :: FIELD_C		  TYPE(MODE_C), DIMENSION(NF), INTENT(IN)    :: FIELD_C
  TYPE(ATOM_C),                INTENT(IN)    :: ATOM__C      	  TYPE(ATOM_C),                INTENT(IN)    :: ATOM__C      

!  write(*,*) "C WRAPPER:", info,NM,NF,MODES_NUM		!  write(*,*) "C WRAPPER:", info,NM,NF,MODES_NUM
  IF (INFO.EQ.0) THEN						  IF (INFO.EQ.0) THEN
 !    write(*,*) "C wrapper"					 !    write(*,*) "C wrapper"
     if(info.eq.0) CALL MULTIMODEFLOQUETMATRIX(ATOM_,NM,NF,MO	     if(info.eq.0) CALL MULTIMODEFLOQUETMATRIX(ATOM_,NM,NF,MO
     H_FLOQUET_SIZE = SIZE(H_FLOQUET,1)				     H_FLOQUET_SIZE = SIZE(H_FLOQUET,1)
!     write(*,*) "C wrapper"					!     write(*,*) "C wrapper"
     !write(*,*) h_floquet_size,size(H_floquet,1),coupling(1)	     !write(*,*) h_floquet_size,size(H_floquet,1),coupling(1)
     !CALL WRITE_MATRIX(H_FLOQUET)				     !CALL WRITE_MATRIX(H_FLOQUET)
  ELSE								  ELSE
     WRITE(*,*) "THERE IS AN ERROR UPSTREAM :INFO.NE.0", INFO	     WRITE(*,*) "THERE IS AN ERROR UPSTREAM :INFO.NE.0", INFO
  END IF							  END IF
END SUBROUTINE MULTIMODEFLOQUETMATRIX_C				END SUBROUTINE MULTIMODEFLOQUETMATRIX_C

diff -y ./src/MultimodeHamiltonian.f90 ../../Downloads/MultimodeFloquet-0.3/src/MultimodeHamiltonian.f90
SUBROUTINE MULTIMODEFLOQUETMATRIX(ATOM_,NM,NF,MODES_NUM,FIELD	SUBROUTINE MULTIMODEFLOQUETMATRIX(ATOM_,NM,NF,MODES_NUM,FIELD
  !ID,size(modes_num,1),total_frequencies,MODES_NUM,FIELDS,IN	  !ID,size(modes_num,1),total_frequencies,MODES_NUM,FIELDS,IN
  !  USE FLOQUET						  !  USE FLOQUET
  !ATOM_ type atom, -> dimension of the bare Hilbert space	  !ATOM_ type atom, -> dimension of the bare Hilbert space
  !NM -> number of modes					  !NM -> number of modes
  !NF -> Number of Fields					  !NF -> Number of Fields
  !MODES_NUM -> number of harmonics of each mode		  !MODES_NUM -> number of harmonics of each mode
  !FIELD -> Field couplings					  !FIELD -> Field couplings
  !INFO								  !INFO


  USE ARRAYS							  USE ARRAYS
  USE ATOMIC_PROPERTIES						  USE ATOMIC_PROPERTIES
  USE TYPES							  USE TYPES
  USE SUBINTERFACE_LAPACK					  USE SUBINTERFACE_LAPACK

  IMPLICIT NONE							  IMPLICIT NONE
  INTEGER,                  INTENT(IN)    :: NM,NF		  INTEGER,                  INTENT(IN)    :: NM,NF
  INTEGER,                  INTENT(INOUT) :: INFO		  INTEGER,                  INTENT(INOUT) :: INFO
  INTEGER,   DIMENSION(NM), INTENT(IN)    :: MODES_NUM		  INTEGER,   DIMENSION(NM), INTENT(IN)    :: MODES_NUM
  TYPE(MODE),DIMENSION(NF), INTENT(IN)    :: FIELD		  TYPE(MODE),DIMENSION(NF), INTENT(IN)    :: FIELD
  TYPE(ATOM),               INTENT(IN)    :: ATOM_           	  TYPE(ATOM),               INTENT(IN)    :: ATOM_           

  INTEGER m,n,D,r,o,D_OLD,index_aux				  INTEGER m,n,D,r,o,D_OLD,index_aux
  COMPLEX*16, DIMENSION(:,:), ALLOCATABLE :: H_TEMP,H_STATIC,	  COMPLEX*16, DIMENSION(:,:), ALLOCATABLE :: H_TEMP,H_STATIC,
  DOUBLE PRECISION, DIMENSION(:),ALLOCATABLE :: E_DRESSED	  DOUBLE PRECISION, DIMENSION(:),ALLOCATABLE :: E_DRESSED
  INTEGER index_l_lower,index_l_upper,index_r_lower,index_r_u	  INTEGER index_l_lower,index_l_upper,index_r_lower,index_r_u

  INTEGER, DIMENSION(NM) :: N_FLOQUET				  INTEGER, DIMENSION(NM) :: N_FLOQUET

!  write(*,*) "# Creating the multimode hamiltonian for a", I	!  write(*,*) "# Creating the multimode hamiltonian for a", I
!  write(*,*) "# with ", NM," modes and ", NF, "frequencies"	!  write(*,*) "# with ", NM," modes and ", NF, "frequencies"
  								  
  INFO      = 0							  INFO      = 0
  N_FLOQUET = 0							  N_FLOQUET = 0
  !write(*,*) "# FORTRAN MULTIMODEFLOQUETMATRIX SAYS:",nm 	  !write(*,*) "# FORTRAN MULTIMODEFLOQUETMATRIX SAYS:",nm 
  DO n=2,NM							  DO n=2,NM
     FIELD_INDEX = 2+SUM(MODES_NUM(2:n-1))			     FIELD_INDEX = 2+SUM(MODES_NUM(2:n-1))
     N_FLOQUET(n)=FIELD(FIELD_INDEX)%N_Floquet			     N_FLOQUET(n)=FIELD(FIELD_INDEX)%N_Floquet
 !    write(*,*) n,N_FLOQUET(n),field_index,modes_num(n),NM,N	 !    write(*,*) n,N_FLOQUET(n),field_index,modes_num(n),NM,N
     IF(modes_num(n).GT.N_FLOQUET(n)+1) THEN			     IF(modes_num(n).GT.N_FLOQUET(n)+1) THEN
        WRITE(*,*) "# TO BUILD THE EXTENDED HAMILTONIAN THE N	        WRITE(*,*) "# TO BUILD THE EXTENDED HAMILTONIAN THE N
        WRITE(*,*) "# LARGER THAN THE NUMBER OF FIELD MODES"	        WRITE(*,*) "# LARGER THAN THE NUMBER OF FIELD MODES"
        INFO = -10						        INFO = -10
     END IF							     END IF
  END DO							  END DO
!  write(*,*) "# Floquet modes:", N_FLOQUET			!  write(*,*) "# Floquet modes:", N_FLOQUET

  IF(INFO.EQ.0) THEN						  IF(INFO.EQ.0) THEN
     D_OLD    = 1						     D_OLD    = 1
     D        = ATOM_%D_BARE					     D        = ATOM_%D_BARE
     !write(*,*) D,info						     !write(*,*) D,info
     ALLOCATE(H_FLOQUET_COPY(D,D))				     ALLOCATE(H_FLOQUET_COPY(D,D))
     H_FLOQUET_COPY = 0.0     					     H_FLOQUET_COPY = 0.0     
     H_FLOQUET_COPY = FIELD(1)%V  ! STATIC HAMILTONIAN		     H_FLOQUET_COPY = FIELD(1)%V  ! STATIC HAMILTONIAN

     FIELD_INDEX = 2 !?						     FIELD_INDEX = 2 !?

     DO n=2,NM  ! RUN OVER EACH FREQUENCY			     DO n=2,NM  ! RUN OVER EACH FREQUENCY


        ! D : UPDATED AT THE ENDO OF THE LOOP. DIMENSION OF T	        ! D : UPDATED AT THE ENDO OF THE LOOP. DIMENSION OF T
        ALLOCATE(H_STATIC(SIZE(H_FLOQUET_COPY,1),SIZE(H_FLOQU	        ALLOCATE(H_STATIC(SIZE(H_FLOQUET_COPY,1),SIZE(H_FLOQU
        H_STATIC  = H_FLOQUET_COPY  				        H_STATIC  = H_FLOQUET_COPY  
        DEALLOCATE(H_FLOQUET_COPY)				        DEALLOCATE(H_FLOQUET_COPY)

        ALLOCATE(IDENTITY(D,D))					        ALLOCATE(IDENTITY(D,D))
        IDENTITY  = 0.0						        IDENTITY  = 0.0
        DO m= 1,D 						        DO m= 1,D 
           IDENTITY(m,m) = 1.0					           IDENTITY(m,m) = 1.0
        END DO							        END DO

        ALLOCATE(COUPLING(D,D))					        ALLOCATE(COUPLING(D,D))
        ALLOCATE(H_FLOQUET_ROW(D,D*(2*N_FLOQUET(n)))) ! a row	        ALLOCATE(H_FLOQUET_ROW(D,D*(2*N_FLOQUET(n)))) ! a row
        H_FLOQUET_ROW = 0.0					        H_FLOQUET_ROW = 0.0
        COUPLING  = 0.0						        COUPLING  = 0.0

        !        IF(NF.NE.NM) THEN				        !        IF(NF.NE.NM) THEN
        FIELD_INDEX =2+SUM(MODES_NUM(2:n-1))			        FIELD_INDEX =2+SUM(MODES_NUM(2:n-1))
        DO o=1,MODES_NUM(n) ! loop to define the blocks of  H	        DO o=1,MODES_NUM(n) ! loop to define the blocks of  H

           DO r=1,(2*N_Floquet(n-1)+1)!,(2*N_Floquet(n-1)+1)	           DO r=1,(2*N_Floquet(n-1)+1)!,(2*N_Floquet(n-1)+1)

              index_l_lower = ATOM_%D_BARE*(r - 1) + 1		              index_l_lower = ATOM_%D_BARE*(r - 1) + 1
              index_l_upper = ATOM_%D_BARE*(r - 1) + ATOM_%D_	              index_l_upper = ATOM_%D_BARE*(r - 1) + ATOM_%D_
              index_r_lower = index_l_lower			              index_r_lower = index_l_lower
              index_r_upper = index_l_upper			              index_r_upper = index_l_upper
              COUPLING(index_l_lower:index_l_upper, index_r_l	              COUPLING(index_l_lower:index_l_upper, index_r_l
                   &     FIELD(FIELD_INDEX)%V  ! COUPLING MAT	                   &     FIELD(FIELD_INDEX)%V  ! COUPLING MAT
!              write(*,*) r,field_index				!              write(*,*) r,field_index
           END DO						           END DO
           H_FLOQUET_ROW(1:D,(o-1)*D+1:o*D) = COUPLING/2.0	           H_FLOQUET_ROW(1:D,(o-1)*D+1:o*D) = COUPLING/2.0
           FIELD_INDEX = FIELD_INDEX + 1			           FIELD_INDEX = FIELD_INDEX + 1
           !CALL WRITE_MATRIX(ABS(H_FLOQUET_ROW))		           !CALL WRITE_MATRIX(ABS(H_FLOQUET_ROW))
        END DO							        END DO
        FIELD_INDEX =2+SUM(MODES_NUM(2:n-1))			        FIELD_INDEX =2+SUM(MODES_NUM(2:n-1))

!        write(*,*) n,N_FLOQUET(n),field_index,field(field_in	!        write(*,*) n,N_FLOQUET(n),field_index,field(field_in
        !        write(*,*) n,FIELD_INDEX,N_Floquet(n),FIELD(	        !        write(*,*) n,FIELD_INDEX,N_Floquet(n),FIELD(
        D_OLD = D						        D_OLD = D
        D     = D*(2*N_FLOQUET(n)+1)				        D     = D*(2*N_FLOQUET(n)+1)
        ALLOCATE(H_FLOQUET(D,D))				        ALLOCATE(H_FLOQUET(D,D))
        H_FLOQUET = 0.0						        H_FLOQUET = 0.0
        DO m=-N_floquet(n),N_Floquet(n)				        DO m=-N_floquet(n),N_Floquet(n)

           index_r_lower = (m+N_Floquet(n))*D_OLD + 1		           index_r_lower = (m+N_Floquet(n))*D_OLD + 1
           index_r_upper = index_r_lower + D_OLD - 1		           index_r_upper = index_r_lower + D_OLD - 1

           index_aux = 2*N_floquet(n)*D_OLD - D_OLD*(m+N_Floq	           index_aux = 2*N_floquet(n)*D_OLD - D_OLD*(m+N_Floq
           index_l_lower = index_r_lower + D_OLD 		           index_l_lower = index_r_lower + D_OLD 
           index_l_upper = index_l_lower + index_aux - 1	           index_l_upper = index_l_lower + index_aux - 1
           !     WRITE(*,*) m,index_r_lower,index_r_upper,ind	           !     WRITE(*,*) m,index_r_lower,index_r_upper,ind
           IF(m.LT.N_Floquet(n)) THEN				           IF(m.LT.N_Floquet(n)) THEN
              H_FLOQUET(index_r_lower:index_r_upper,index_l_l	              H_FLOQUET(index_r_lower:index_r_upper,index_l_l
              H_FLOQUET(index_l_lower:index_l_upper,index_r_l	              H_FLOQUET(index_l_lower:index_l_upper,index_r_l
                   & TRANSPOSE(CONJG(H_FLOQUET_ROW(1:D_OLD,1:	                   & TRANSPOSE(CONJG(H_FLOQUET_ROW(1:D_OLD,1:
           END IF						           END IF
           H_FLOQUET(index_r_lower:index_r_upper,index_r_lowe	           H_FLOQUET(index_r_lower:index_r_upper,index_r_lowe
 !          write(*,*) m,n,m*FIELD(FIELD_INDEX)%OMEGA,field_i	 !          write(*,*) m,n,m*FIELD(FIELD_INDEX)%OMEGA,field_i
        END DO							        END DO
        !END IF							        !END IF
!!$        ELSE IF(NF.EQ.NM) THEN				!!$        ELSE IF(NF.EQ.NM) THEN
!!$								!!$
!!$           DO r=1,(2*N_Floquet(n-1)+1)			!!$           DO r=1,(2*N_Floquet(n-1)+1)
!!$        							!!$        
!!$              index_l_lower = ATOM_%D_BARE*(r - 1) + 1	!!$              index_l_lower = ATOM_%D_BARE*(r - 1) + 1
!!$              index_l_upper = ATOM_%D_BARE*(r - 1) + ATOM_	!!$              index_l_upper = ATOM_%D_BARE*(r - 1) + ATOM_
!!$              index_r_lower = index_l_lower			!!$              index_r_lower = index_l_lower
!!$              index_r_upper = index_l_upper			!!$              index_r_upper = index_l_upper
!!$!              COUPLING(index_l_lower:index_l_upper, index	!!$!              COUPLING(index_l_lower:index_l_upper, index
!!$!                   &     FIELD(n)%V  ! COUPLING MATRIX OF	!!$!                   &     FIELD(n)%V  ! COUPLING MATRIX OF
!!$              !       write(*,*) n,r,index_l_lower,index_l	!!$              !       write(*,*) n,r,index_l_lower,index_l
!!$           END DO						!!$           END DO
!!$  								!!$  
!!$           DO m=-N_floquet(n),N_Floquet(n)			!!$           DO m=-N_floquet(n),N_Floquet(n)
!!$              						!!$              
!!$              index_l_lower = (m + N_Floquet(n)    )*SIZE(	!!$              index_l_lower = (m + N_Floquet(n)    )*SIZE(
!!$              index_l_upper = index_l_lower + SIZE(COUPLIN	!!$              index_l_upper = index_l_lower + SIZE(COUPLIN
!!$              index_r_lower =  index_l_lower			!!$              index_r_lower =  index_l_lower
!!$              index_r_upper =  index_l_upper			!!$              index_r_upper =  index_l_upper
!!$              H_FLOQUET(index_l_lower:index_l_upper, index	!!$              H_FLOQUET(index_l_lower:index_l_upper, index
!!$                   &  1.0*H_STATIC + 1.0*m*FIELD(n)%OMEGA*	!!$                   &  1.0*H_STATIC + 1.0*m*FIELD(n)%OMEGA*
!!$              !        call write_matrix(ABS(H_STATIC))	!!$              !        call write_matrix(ABS(H_STATIC))
!!$              !call write_matrix(ABS(H_FLOQUET(index_l_low	!!$              !call write_matrix(ABS(H_FLOQUET(index_l_low
!!$              !        write(*,*) n,m,hbar,FIELD(n)%OMEGA,	!!$              !        write(*,*) n,m,hbar,FIELD(n)%OMEGA,
!!$              IF(m.LT.N_floquet(n)) THEN			!!$              IF(m.LT.N_floquet(n)) THEN
!!$                 						!!$                 
!!$                 index_l_lower =  (m + N_Floquet(n) + 1)*S	!!$                 index_l_lower =  (m + N_Floquet(n) + 1)*S
!!$                 index_l_upper =  index_l_lower + SIZE(COU	!!$                 index_l_upper =  index_l_lower + SIZE(COU
!!$                 index_r_lower =  (m + N_Floquet(n)    )*S	!!$                 index_r_lower =  (m + N_Floquet(n)    )*S
!!$                 index_r_upper =  index_r_lower + SIZE(COU	!!$                 index_r_upper =  index_r_lower + SIZE(COU
!!$                 H_FLOQUET(index_l_lower:index_l_upper, in	!!$                 H_FLOQUET(index_l_lower:index_l_upper, in
!!$                      &     0.5*COUPLING			!!$                      &     0.5*COUPLING
!!$                 !           write(*,*) index_l_lower,inde	!!$                 !           write(*,*) index_l_lower,inde
!!$                 						!!$                 
!!$                 index_l_lower =  (m + N_Floquet(n)    )*S	!!$                 index_l_lower =  (m + N_Floquet(n)    )*S
!!$                 index_l_upper =  index_r_lower + SIZE(COU	!!$                 index_l_upper =  index_r_lower + SIZE(COU
!!$                 index_r_lower =  (m + N_Floquet(n) + 1)*S	!!$                 index_r_lower =  (m + N_Floquet(n) + 1)*S
!!$                 index_r_upper =  index_l_lower + SIZE(COU	!!$                 index_r_upper =  index_l_lower + SIZE(COU
!!$                 H_FLOQUET(index_l_lower:index_l_upper, in	!!$                 H_FLOQUET(index_l_lower:index_l_upper, in
!!$                      &     0.5*TRANSPOSE(CONJG(COUPLING))	!!$                      &     0.5*TRANSPOSE(CONJG(COUPLING))
!!$              END IF						!!$              END IF
!!$              						!!$              
!!$           END DO						!!$           END DO
        !        END IF						        !        END IF

        DEALLOCATE(IDENTITY)					        DEALLOCATE(IDENTITY)
        DEALLOCATE(COUPLING)					        DEALLOCATE(COUPLING)
        DEALLOCATE(H_FLOQUET_ROW)				        DEALLOCATE(H_FLOQUET_ROW)

        IF(n.LT.NM) THEN					        IF(n.LT.NM) THEN
           ALLOCATE(H_FLOQUET_COPY(D,D))			           ALLOCATE(H_FLOQUET_COPY(D,D))
           H_FLOQUET_COPY = H_FLOQUET				           H_FLOQUET_COPY = H_FLOQUET
           DEALLOCATE(H_FLOQUET)				           DEALLOCATE(H_FLOQUET)
           DEALLOCATE(H_STATIC)					           DEALLOCATE(H_STATIC)
        END IF							        END IF

     END DO							     END DO
!     write(*,*) "# Dimension of the matrix:", size(H_FLOQUET	!     write(*,*) "# Dimension of the matrix:", size(H_FLOQUET

!     CALL WRITE_MATRIX(real(H_FLOQUET))			!     CALL WRITE_MATRIX(real(H_FLOQUET))
  ELSE								  ELSE

  END IF							  END IF
END SUBROUTINE MULTIMODEFLOQUETMATRIX				END SUBROUTINE MULTIMODEFLOQUETMATRIX

diff -y ./src/MultimodeHamiltonian_SP_C.f90 ../../Downloads/MultimodeFloquet-0.3/src/MultimodeHamiltonian_SP_C.f90
SUBROUTINE MULTIMODEFLOQUETMATRIX_SP_C(ATOM__C,NM,NF,MODES_NU	SUBROUTINE MULTIMODEFLOQUETMATRIX_SP_C(ATOM__C,NM,NF,MODES_NU
! THIS SUBROUTINE BUILDS THE MULTIMODE FLOQUET MATRIX		! THIS SUBROUTINE BUILDS THE MULTIMODE FLOQUET MATRIX

!ATOM_      (IN)    : type of quantum system			!ATOM_      (IN)    : type of quantum system
!NM         (IN)    : number of modes				!NM         (IN)    : number of modes
!NF         (IN)    : number of driving fields			!NF         (IN)    : number of driving fields
!MODES_NUM  (IN)    : vector indicating the number of harmoni	!MODES_NUM  (IN)    : vector indicating the number of harmoni
!FIELDS_C     (IN)    : Fields					!FIELDS_C     (IN)    : Fields

! THE FOLLOWING VARIABLES ARE DECLARED AS GLOBAL ALLOCATABLE 	! THE FOLLOWING VARIABLES ARE DECLARED AS GLOBAL ALLOCATABLE 

!VALUES_    (OUT)   : Hamiltonian values			!VALUES_    (OUT)   : Hamiltonian values
!ROW_INDEX_ (OUT)   : vector indicating the row position of v	!ROW_INDEX_ (OUT)   : vector indicating the row position of v
!COLUMN_    (OUT)   : vector indicating the column position o	!COLUMN_    (OUT)   : vector indicating the column position o
!INFO       (INOUT) : error flag. INFO=0 means there is no er	!INFO       (INOUT) : error flag. INFO=0 means there is no er

  USE TYPES_C             !(modes.f90)				  USE TYPES_C             !(modes.f90)
  USE MERGINGARRAYS     !(utils.f90)				  USE MERGINGARRAYS     !(utils.f90)
  USE SPARSE_INTERFACE  !(sparse_utils.f90)			  USE SPARSE_INTERFACE  !(sparse_utils.f90)
  USE MODES_4F          ! DEFINED IN modes_C.f90, declares at	  USE MODES_4F          ! DEFINED IN modes_C.f90, declares at
  								  
  IMPLICIT NONE							  IMPLICIT NONE
  INTEGER                  ,            INTENT(IN)    :: NM,N	  INTEGER                  ,            INTENT(IN)    :: NM,N
  TYPE(MODE_C), DIMENSION(NF),          INTENT(INout) :: FIEL	  TYPE(MODE_C), DIMENSION(NF),          INTENT(INout) :: FIEL
  TYPE(ATOM_C),                         INTENT(IN)    :: ATOM	  TYPE(ATOM_C),                         INTENT(IN)    :: ATOM
  INTEGER,    DIMENSION(NM),            INTENT(IN)    :: MODE	  INTEGER,    DIMENSION(NM),            INTENT(IN)    :: MODE
  INTEGER,                              INTENT(INOUT) :: INFO	  INTEGER,                              INTENT(INOUT) :: INFO
  								  
!  COMPLEX*16, DIMENSION(:), ALLOCATABLE  :: VALUES__		!  COMPLEX*16, DIMENSION(:), ALLOCATABLE  :: VALUES__
!  INTEGER,    DIMENSION(:), ALLOCATABLE  :: COLUMN__		!  INTEGER,    DIMENSION(:), ALLOCATABLE  :: COLUMN__
!  INTEGER,    DIMENSION(:), ALLOCATABLE  :: ROW_INDEX__	!  INTEGER,    DIMENSION(:), ALLOCATABLE  :: ROW_INDEX__
  !INTEGER,                              INTENT(OUT)   :: SP	  !INTEGER,                              INTENT(OUT)   :: SP
 								 
!    write(*,*) 'FORTRAN FLOQUETMATRIX_SP SAYS',NM,NF,MODES_N	!    write(*,*) 'FORTRAN FLOQUETMATRIX_SP SAYS',NM,NF,MODES_N
  IF (INFO.EQ.0) THEN      					  IF (INFO.EQ.0) THEN      
    CALL MULTIMODEFLOQUETMATRIX_SP(ATOM_,NM,NF,MODES_NUM,COUP	    CALL MULTIMODEFLOQUETMATRIX_SP(ATOM_,NM,NF,MODES_NUM,COUP
!    WRITE(*,*) "FORTRAN MULTIMODEHAMILTONAISPC SAYS: SIZE(VA	!    WRITE(*,*) "FORTRAN MULTIMODEHAMILTONAISPC SAYS: SIZE(VA
    H_FLOQUET_SIZE = SIZE(ROW_INDEX__,1)-1			    H_FLOQUET_SIZE = SIZE(ROW_INDEX__,1)-1
  END IF							  END IF

END SUBROUTINE MULTIMODEFLOQUETMATRIX_SP_C ! _SP  sparse pack	END SUBROUTINE MULTIMODEFLOQUETMATRIX_SP_C ! _SP  sparse pack

diff -y ./src/MultimodeHamiltonian_SP.f90 ../../Downloads/MultimodeFloquet-0.3/src/MultimodeHamiltonian_SP.f90
SUBROUTINE MULTIMODEFLOQUETMATRIX_SP(ATOM__,NM,NF,MODES_NUM,F	SUBROUTINE MULTIMODEFLOQUETMATRIX_SP(ATOM__,NM,NF,MODES_NUM,F

  !ATOM_      (IN)    : type of quantum system			  !ATOM_      (IN)    : type of quantum system
  !NM         (IN)    : number of modes				  !NM         (IN)    : number of modes
  !NF         (IN)    : number of driving fields		  !NF         (IN)    : number of driving fields
  !MODES_NUM  (IN)    : vector indicating the number of harmo	  !MODES_NUM  (IN)    : vector indicating the number of harmo
  !FIELDS     (IN)    : Fields					  !FIELDS     (IN)    : Fields
  !VALUES_    (OUT)   : Hamiltonian values			  !VALUES_    (OUT)   : Hamiltonian values
  !ROW_INDEX_ (OUT)   : if INFO = 6 vector indicating the row	  !ROW_INDEX_ (OUT)   : if INFO = 6 vector indicating the row
  !ROW_INDEX_ (OUT)   : IF INFO = 0 vector indicating the row	  !ROW_INDEX_ (OUT)   : IF INFO = 0 vector indicating the row
  !COLUMN_    (OUT)   : vector indicating the column position	  !COLUMN_    (OUT)   : vector indicating the column position
  !INFO       (INOUT) : error flag. INFO=0 means there is no 	  !INFO       (INOUT) : error flag. INFO=0 means there is no 

  USE TYPES         !(modes.f90)				  USE TYPES         !(modes.f90)
  USE MERGINGARRAYS !(utils.f90)				  USE MERGINGARRAYS !(utils.f90)

  IMPLICIT NONE							  IMPLICIT NONE
  INTEGER                  ,            INTENT(IN)    :: NM,N	  INTEGER                  ,            INTENT(IN)    :: NM,N
  TYPE(MODE), DIMENSION(NF),            INTENT(INOUT) :: FIEL	  TYPE(MODE), DIMENSION(NF),            INTENT(INOUT) :: FIEL
  TYPE(ATOM),                           INTENT(IN)    :: ATOM	  TYPE(ATOM),                           INTENT(IN)    :: ATOM
  INTEGER,    DIMENSION(NM),            INTENT(IN)    :: MODE	  INTEGER,    DIMENSION(NM),            INTENT(IN)    :: MODE
  INTEGER,                              INTENT(INOUT) :: INFO	  INTEGER,                              INTENT(INOUT) :: INFO
  COMPLEX*16, DIMENSION(:), ALLOCATABLE,INTENT(OUT)   :: VALU	  COMPLEX*16, DIMENSION(:), ALLOCATABLE,INTENT(OUT)   :: VALU
  INTEGER,    DIMENSION(:), ALLOCATABLE,INTENT(OUT)   :: COLU	  INTEGER,    DIMENSION(:), ALLOCATABLE,INTENT(OUT)   :: COLU
  INTEGER,    DIMENSION(:), ALLOCATABLE,INTENT(OUT)   :: ROW_	  INTEGER,    DIMENSION(:), ALLOCATABLE,INTENT(OUT)   :: ROW_


  COMPLEX*16,       DIMENSION(:,:), ALLOCATABLE :: V_AUX	  COMPLEX*16,       DIMENSION(:,:), ALLOCATABLE :: V_AUX
  COMPLEX*16,       DIMENSION(:),   ALLOCATABLE :: VALUES,ARR	  COMPLEX*16,       DIMENSION(:),   ALLOCATABLE :: VALUES,ARR
  INTEGER,          DIMENSION(:),   ALLOCATABLE :: ROW,COLUMN	  INTEGER,          DIMENSION(:),   ALLOCATABLE :: ROW,COLUMN
  INTEGER,          DIMENSION(NM)               :: N_FLOQUET	  INTEGER,          DIMENSION(NM)               :: N_FLOQUET
  DOUBLE PRECISION, DIMENSION(NM)               :: OMEGA	  DOUBLE PRECISION, DIMENSION(NM)               :: OMEGA

  INTEGER     :: D_MULTIFLOQUET					  INTEGER     :: D_MULTIFLOQUET
  INTEGER     :: m,r,c,index,D,counter, N_MODES,values_dim,D_	  INTEGER     :: m,r,c,index,D,counter, N_MODES,values_dim,D_
  CHARACTER*1 :: UPLO						  CHARACTER*1 :: UPLO

  ! ----- ----- ----- ----- ----- ----- ----- ----- ----- ---	  ! ----- ----- ----- ----- ----- ----- ----- ----- ----- ---
  ! ----- PARAMETERS REQUIRED TO TEST THE DIAGONALIZATION ROU	  ! ----- PARAMETERS REQUIRED TO TEST THE DIAGONALIZATION ROU
  ! ----- ----- ----- ----- ----- ----- ----- ----- ----- ---	  ! ----- ----- ----- ----- ----- ----- ----- ----- ----- ---
  !COMPLEX*16,      DIMENSION(:,:),ALLOCATABLE :: U_F		  !COMPLEX*16,      DIMENSION(:,:),ALLOCATABLE :: U_F
  !DOUBLE PRECISION,DIMENSION(:),ALLOCATABLE :: E_FLOQUET	  !DOUBLE PRECISION,DIMENSION(:),ALLOCATABLE :: E_FLOQUET
  !DOUBLE PRECISION :: E_L,E_R					  !DOUBLE PRECISION :: E_L,E_R
  ! ----- ----- ----- ----- ----- ----- ----- ----- ----- ---	  ! ----- ----- ----- ----- ----- ----- ----- ----- ----- ---
  ! ----- ----- ----- ----- ----- ----- ----- ----- ----- ---	  ! ----- ----- ----- ----- ----- ----- ----- ----- ----- ---

  N_MODES = NM							  N_MODES = NM
  D_bare  = ATOM__%D_BARE					  D_bare  = ATOM__%D_BARE

  INFO       = 0						  INFO       = 0
  N_FLOQUET  = 0						  N_FLOQUET  = 0

  !write(*,*) N_MODES,D_BARE,INFO,N_FLOQUET			  !write(*,*) N_MODES,D_BARE,INFO,N_FLOQUET
  ALLOCATE(VALUES(D_bare*D_bare))				  ALLOCATE(VALUES(D_bare*D_bare))
  ALLOCATE(ROW(D_bare*D_bare))					  ALLOCATE(ROW(D_bare*D_bare))
  ALLOCATE(COLUMN(D_bare*D_bare))				  ALLOCATE(COLUMN(D_bare*D_bare))

  !DEFINITION OF THE MATRICES: BY HAND  			  !DEFINITION OF THE MATRICES: BY HAND  
  D_MULTIFLOQUET = SIZE(FIELDS(1)%V,1)				  D_MULTIFLOQUET = SIZE(FIELDS(1)%V,1)
  DO r=2,NM							  DO r=2,NM
     FIELD_INDEX  = 2+SUM(MODES_NUM(2:r-1))			     FIELD_INDEX  = 2+SUM(MODES_NUM(2:r-1))
     N_FLOQUET(r) = FIELDS(FIELD_INDEX)%N_Floquet		     N_FLOQUET(r) = FIELDS(FIELD_INDEX)%N_Floquet
     OMEGA(r)     = FIELDS(FIELD_INDEX)%OMEGA			     OMEGA(r)     = FIELDS(FIELD_INDEX)%OMEGA
     !WRITE(*,*) r,N_FLOQUET(r),field_index,modes_num(r),NM,N	     !WRITE(*,*) r,N_FLOQUET(r),field_index,modes_num(r),NM,N
     IF(MODES_NUM(r).GT.N_FLOQUET(r)+1) THEN			     IF(MODES_NUM(r).GT.N_FLOQUET(r)+1) THEN
        WRITE(*,*) "TO BUILD THE EXTENDED HAMILTONIAN THE NUM	        WRITE(*,*) "TO BUILD THE EXTENDED HAMILTONIAN THE NUM
        WRITE(*,*) "LARGER THAN THE NUMBER OF FIELD MODES"	        WRITE(*,*) "LARGER THAN THE NUMBER OF FIELD MODES"
        WRITE(*,*) "IN MODE ",r, "WE HAVE"			        WRITE(*,*) "IN MODE ",r, "WE HAVE"
        WRITE(*,*) "FLOQUET MANIFOLDS =", N_FLOQUET(r)		        WRITE(*,*) "FLOQUET MANIFOLDS =", N_FLOQUET(r)
        WRITE(*,*) "NUMBER OF MODES   =",MODES_NUM(r)		        WRITE(*,*) "NUMBER OF MODES   =",MODES_NUM(r)
        INFO = -10						        INFO = -10
     END IF							     END IF
     D_MULTIFLOQUET = D_MULTIFLOQUET*(2*N_FLOQUET(r)+1)		     D_MULTIFLOQUET = D_MULTIFLOQUET*(2*N_FLOQUET(r)+1)
  END DO							  END DO
  !write(*,*) D_MULTIFLOQUET					  !write(*,*) D_MULTIFLOQUET
  ! IF(COUPLINGALLOCATED .EQV. .TRUE. ) THEN			  ! IF(COUPLINGALLOCATED .EQV. .TRUE. ) THEN
  !    DO r=1,NF						  !    DO r=1,NF
  !       DEALLOCATE(FIELDS(r)%VALUES)				  !       DEALLOCATE(FIELDS(r)%VALUES)
  !       DEALLOCATE(FIELDS(r)%COLUMN)				  !       DEALLOCATE(FIELDS(r)%COLUMN)
  !       DEALLOCATE(FIELDS(r)%ROW)				  !       DEALLOCATE(FIELDS(r)%ROW)
  !!       DEALLOCATE(FIELDS(r)%V)				  !!       DEALLOCATE(FIELDS(r)%V)
  !    END DO							  !    END DO
  !    !DEALLOCATE(ATOM_%E_BARE)				  !    !DEALLOCATE(ATOM_%E_BARE)
  ! END IF							  ! END IF

  IF(INFO.GE.0) THEN						  IF(INFO.GE.0) THEN
     ! COORDINATE PACKING OF EACH FIELD				     ! COORDINATE PACKING OF EACH FIELD

     DO m=1,NF							     DO m=1,NF
        CALL COORDINATEPACKING(D_bare,FIELDS(m)%V,VALUES,ROW,	        CALL COORDINATEPACKING(D_bare,FIELDS(m)%V,VALUES,ROW,
        ALLOCATE(FIELDS(m)%VALUES(index))			        ALLOCATE(FIELDS(m)%VALUES(index))
        IF(m.eq.1) FIELDS(m)%VALUES = VALUES(1:index)		        IF(m.eq.1) FIELDS(m)%VALUES = VALUES(1:index)
        IF(m.ne.1) FIELDS(m)%VALUES = VALUES(1:index)/2.0	        IF(m.ne.1) FIELDS(m)%VALUES = VALUES(1:index)/2.0
        !write(*,*) ABS(fields(m)%values)			        !write(*,*) ABS(fields(m)%values)
!        write(*,*) m,fields(m)%omega, index			!        write(*,*) m,fields(m)%omega, index
        ALLOCATE(FIELDS(m)%ROW(index))				        ALLOCATE(FIELDS(m)%ROW(index))
        FIELDS(m)%ROW = ROW(1:index)				        FIELDS(m)%ROW = ROW(1:index)
!        WRITE(*,*)m, FIELDS(m)%ROW				!        WRITE(*,*)m, FIELDS(m)%ROW
        ALLOCATE(FIELDS(m)%COLUMN(index))			        ALLOCATE(FIELDS(m)%COLUMN(index))
        FIELDS(m)%COLUMN = COLUMN(1:index)			        FIELDS(m)%COLUMN = COLUMN(1:index)
!        WRITE(*,*)m, FIELDS(m)%COLUMN				!        WRITE(*,*)m, FIELDS(m)%COLUMN
     END DO							     END DO

     ! WE HAVE TO REDEFINE VALUES,ROW,COLUMN FOR m > 2 BECAUS	     ! WE HAVE TO REDEFINE VALUES,ROW,COLUMN FOR m > 2 BECAUS
     ! HAMILTONIAN, THEY ARE REPEATED IN DIAGONAL MATRICES OF	     ! HAMILTONIAN, THEY ARE REPEATED IN DIAGONAL MATRICES OF

     D = 1							     D = 1
     D_BARE = ATOM__%D_BARE					     D_BARE = ATOM__%D_BARE
     index = 1							     index = 1
     FIELD_INDEX = 2+MODES_NUM(2)				     FIELD_INDEX = 2+MODES_NUM(2)
     DO m=3,NM							     DO m=3,NM

        D = D*(2*N_FLOQUET(m-1)+1)                  		        D = D*(2*N_FLOQUET(m-1)+1)                  
        FIELD_INDEX = 2+SUM(MODES_NUM(2:m-1))			        FIELD_INDEX = 2+SUM(MODES_NUM(2:m-1))
        !write(*,*) field_index,m				        !write(*,*) field_index,m

        DO r=1,MODES_NUM(m)					        DO r=1,MODES_NUM(m)

           DEALLOCATE(VALUES)					           DEALLOCATE(VALUES)
           DEALLOCATE(ROW)					           DEALLOCATE(ROW)
           DEALLOCATE(COLUMN)					           DEALLOCATE(COLUMN)
           ALLOCATE(    VALUES(SIZE(FIELDS(FIELD_INDEX)%VALUE	           ALLOCATE(    VALUES(SIZE(FIELDS(FIELD_INDEX)%VALUE
           ALLOCATE(       ROW(SIZE(FIELDS(FIELD_INDEX)%VALUE	           ALLOCATE(       ROW(SIZE(FIELDS(FIELD_INDEX)%VALUE
           ALLOCATE(    COLUMN(SIZE(FIELDS(FIELD_INDEX)%VALUE	           ALLOCATE(    COLUMN(SIZE(FIELDS(FIELD_INDEX)%VALUE
           ALLOCATE(ARRAYI_AUX(SIZE(FIELDS(FIELD_INDEX)%VALUE	           ALLOCATE(ARRAYI_AUX(SIZE(FIELDS(FIELD_INDEX)%VALUE
           VALUES = FIELDS(FIELD_INDEX)%VALUES			           VALUES = FIELDS(FIELD_INDEX)%VALUES
           ROW    = FIELDS(FIELD_INDEX)%ROW			           ROW    = FIELDS(FIELD_INDEX)%ROW
           COLUMN = FIELDS(FIELD_INDEX)%COLUMN			           COLUMN = FIELDS(FIELD_INDEX)%COLUMN
!           write(*,*) size(column,1)				!           write(*,*) size(column,1)
           !WRITE(*,*) m,r,row,real(values),D!SIZE(FIELDS(FIE	           !WRITE(*,*) m,r,row,real(values),D!SIZE(FIELDS(FIE
           DO c=2,D ! it starts in 2, because 1 is explicitly	           DO c=2,D ! it starts in 2, because 1 is explicitly
              CALL APPENDARRAYS(VALUES,FIELDS(FIELD_INDEX)%VA	              CALL APPENDARRAYS(VALUES,FIELDS(FIELD_INDEX)%VA
              ARRAYI_AUX = FIELDS(FIELD_INDEX)%ROW + (c-1)*D_	              ARRAYI_AUX = FIELDS(FIELD_INDEX)%ROW + (c-1)*D_
              CALL APPENDARRAYSI(ROW,ARRAYI_AUX,INFO)		              CALL APPENDARRAYSI(ROW,ARRAYI_AUX,INFO)
              ARRAYI_AUX =  FIELDS(FIELD_INDEX)%COLUMN + (c-1	              ARRAYI_AUX =  FIELDS(FIELD_INDEX)%COLUMN + (c-1
              CALL APPENDARRAYSI(COLUMN,ARRAYI_AUX,INFO)	              CALL APPENDARRAYSI(COLUMN,ARRAYI_AUX,INFO)
              !WRITE(*,*) m,r,c,D,2*N_FLOQUET(m-1)+1,SIZE(VAL	              !WRITE(*,*) m,r,c,D,2*N_FLOQUET(m-1)+1,SIZE(VAL
              !           write(*,*) c,real(values)		              !           write(*,*) c,real(values)
              !           write(*,*) row			              !           write(*,*) row
              !write(*,*) "C:",c,column				              !write(*,*) "C:",c,column
              !write(*,*)					              !write(*,*)
           END DO						           END DO
           !        WRITE(*,*) m,r, SIZE(VALUES,1),field_inde	           !        WRITE(*,*) m,r, SIZE(VALUES,1),field_inde
           !        write(*,*) REAL(VALUES)			           !        write(*,*) REAL(VALUES)
           !        WRITE(*,*) ROW				           !        WRITE(*,*) ROW
           !        WRITE(*,*) COLUMN				           !        WRITE(*,*) COLUMN
           DEALLOCATE(FIELDS(FIELD_INDEX)%VALUES)		           DEALLOCATE(FIELDS(FIELD_INDEX)%VALUES)
           DEALLOCATE(FIELDS(FIELD_INDEX)%ROW)			           DEALLOCATE(FIELDS(FIELD_INDEX)%ROW)
           DEALLOCATE(FIELDS(FIELD_INDEX)%COLUMN)		           DEALLOCATE(FIELDS(FIELD_INDEX)%COLUMN)
           DEALLOCATE(ARRAYI_AUX)				           DEALLOCATE(ARRAYI_AUX)
           ALLOCATE(FIELDS(FIELD_INDEX)%VALUES(SIZE(VALUES,1)	           ALLOCATE(FIELDS(FIELD_INDEX)%VALUES(SIZE(VALUES,1)
           ALLOCATE(   FIELDS(FIELD_INDEX)%ROW(SIZE(VALUES,1)	           ALLOCATE(   FIELDS(FIELD_INDEX)%ROW(SIZE(VALUES,1)
           ALLOCATE(FIELDS(FIELD_INDEX)%COLUMN(SIZE(VALUES,1)	           ALLOCATE(FIELDS(FIELD_INDEX)%COLUMN(SIZE(VALUES,1)
           FIELDS(FIELD_INDEX)%VALUES = VALUES			           FIELDS(FIELD_INDEX)%VALUES = VALUES
           FIELDS(FIELD_INDEX)%ROW    = ROW			           FIELDS(FIELD_INDEX)%ROW    = ROW
           FIELDS(FIELD_INDEX)%COLUMN = COLUMN			           FIELDS(FIELD_INDEX)%COLUMN = COLUMN
           FIELD_INDEX = FIELD_INDEX + 1			           FIELD_INDEX = FIELD_INDEX + 1
        END DO							        END DO
        !     DO r=1,SIZE(VALUES,1)				        !     DO r=1,SIZE(VALUES,1)
        !        WRITE(*,*) r,ROW(r),COLUMN(r),REAL(VALUES(r)	        !        WRITE(*,*) r,ROW(r),COLUMN(r),REAL(VALUES(r)
        !     END DO						        !     END DO
        D_BARE = D_BARE*D					        D_BARE = D_BARE*D
     END DO							     END DO
     DEALLOCATE(VALUES)						     DEALLOCATE(VALUES)
     DEALLOCATE(ROW)						     DEALLOCATE(ROW)
     DEALLOCATE(COLUMN)						     DEALLOCATE(COLUMN)


     ! BUILDING THE COORDINATE PACKING OF THE MULTIMODE HAMIL	     ! BUILDING THE COORDINATE PACKING OF THE MULTIMODE HAMIL
     D_BARE = ATOM__%D_BARE					     D_BARE = ATOM__%D_BARE
     D = D_bare							     D = D_bare
     values_dim = 0  						     values_dim = 0  
     ALLOCATE(VALUES_OLD(SIZE(FIELDS(1)%VALUES,1)))		     ALLOCATE(VALUES_OLD(SIZE(FIELDS(1)%VALUES,1)))
     ALLOCATE(ROW_OLD(SIZE(FIELDS(1)%VALUES,1)))		     ALLOCATE(ROW_OLD(SIZE(FIELDS(1)%VALUES,1)))
     ALLOCATE(COLUMN_OLD(SIZE(FIELDS(1)%VALUES,1)))		     ALLOCATE(COLUMN_OLD(SIZE(FIELDS(1)%VALUES,1)))
     ALLOCATE(VALUES(SIZE(FIELDS(1)%VALUES)))			     ALLOCATE(VALUES(SIZE(FIELDS(1)%VALUES)))
     ALLOCATE(ROW(SIZE(FIELDS(1)%VALUES)))			     ALLOCATE(ROW(SIZE(FIELDS(1)%VALUES)))
     ALLOCATE(COLUMN(SIZE(FIELDS(1)%VALUES)))			     ALLOCATE(COLUMN(SIZE(FIELDS(1)%VALUES)))
     								     
     VALUES     = FIELDS(1)%VALUES				     VALUES     = FIELDS(1)%VALUES
     ROW        = FIELDS(1)%ROW					     ROW        = FIELDS(1)%ROW
     COLUMN     = FIELDS(1)%COLUMN				     COLUMN     = FIELDS(1)%COLUMN
     VALUES_OLD = FIELDS(1)%VALUES				     VALUES_OLD = FIELDS(1)%VALUES
     ROW_OLD    = FIELDS(1)%ROW					     ROW_OLD    = FIELDS(1)%ROW
     COLUMN_OLD = FIELDS(1)%COLUMN  				     COLUMN_OLD = FIELDS(1)%COLUMN  

     FIELD_INDEX = 2						     FIELD_INDEX = 2
     DO m=2,NM							     DO m=2,NM
        ALLOCATE(ARRAYI_AUX(SIZE(FIELDS(m)%ROW,1)))		        ALLOCATE(ARRAYI_AUX(SIZE(FIELDS(m)%ROW,1)))
        ALLOCATE(VALUES_OLD_(SIZE(VALUES_OLD,1)))		        ALLOCATE(VALUES_OLD_(SIZE(VALUES_OLD,1)))
        VALUES_OLD_ = VALUES_OLD				        VALUES_OLD_ = VALUES_OLD

        DO c = 1,2*N_FLOQUET(m) + 1 !THIS LOOP DEFINES THE DI	        DO c = 1,2*N_FLOQUET(m) + 1 !THIS LOOP DEFINES THE DI
           DO t=1,SIZE(VALUES_OLD,1)				           DO t=1,SIZE(VALUES_OLD,1)
              IF(COLUMN_OLD(t).EQ.ROW_OLD(t)) VALUES_OLD_(t) 	              IF(COLUMN_OLD(t).EQ.ROW_OLD(t)) VALUES_OLD_(t) 
           END DO						           END DO
           IF(c.NE.1) THEN					           IF(c.NE.1) THEN
              CALL APPENDARRAYS(VALUES,VALUES_OLD_,INFO)	              CALL APPENDARRAYS(VALUES,VALUES_OLD_,INFO)
              CALL APPENDARRAYSI(COLUMN,COLUMN_OLD+(c-1)*D,IN	              CALL APPENDARRAYSI(COLUMN,COLUMN_OLD+(c-1)*D,IN
              CALL APPENDARRAYSI(ROW,ROW_OLD+(c-1)*D,INFO)	              CALL APPENDARRAYSI(ROW,ROW_OLD+(c-1)*D,INFO)
           ELSE							           ELSE
              VALUES = VALUES_OLD_				              VALUES = VALUES_OLD_
           END IF						           END IF
        END DO							        END DO
        !     WRITE(*,*) REAL(VALUES)				        !     WRITE(*,*) REAL(VALUES)
        !     WRITE(*,*) ROW					        !     WRITE(*,*) ROW
        DO c=1,MODES_NUM(m) !NOW WE POPULATE AS MANY UPPER AN	        DO c=1,MODES_NUM(m) !NOW WE POPULATE AS MANY UPPER AN
           DO r = 1,2*N_FLOQUET(m) + 1 - c           		           DO r = 1,2*N_FLOQUET(m) + 1 - c           
              CALL APPENDARRAYS(VALUES,FIELDS(FIELD_INDEX)%VA	              CALL APPENDARRAYS(VALUES,FIELDS(FIELD_INDEX)%VA
              CALL APPENDARRAYS(VALUES,CONJG(FIELDS(FIELD_IND	              CALL APPENDARRAYS(VALUES,CONJG(FIELDS(FIELD_IND

              ARRAYI_AUX =  FIELDS(FIELD_INDEX)%COLUMN + (r-1	              ARRAYI_AUX =  FIELDS(FIELD_INDEX)%COLUMN + (r-1
              CALL APPENDARRAYSI(COLUMN,ARRAYI_AUX,INFO)     	              CALL APPENDARRAYSI(COLUMN,ARRAYI_AUX,INFO)     
              ARRAYI_AUX =  FIELDS(FIELD_INDEX)%ROW + (r-1)*D	              ARRAYI_AUX =  FIELDS(FIELD_INDEX)%ROW + (r-1)*D
              CALL APPENDARRAYSI(COLUMN,ARRAYI_AUX,INFO)     	              CALL APPENDARRAYSI(COLUMN,ARRAYI_AUX,INFO)     

              ARRAYI_AUX =  FIELDS(FIELD_INDEX)%ROW + (r-1)*D	              ARRAYI_AUX =  FIELDS(FIELD_INDEX)%ROW + (r-1)*D
              CALL APPENDARRAYSI(ROW,ARRAYI_AUX,INFO)		              CALL APPENDARRAYSI(ROW,ARRAYI_AUX,INFO)
              ARRAYI_AUX =  FIELDS(FIELD_INDEX)%COLUMN + (r-1	              ARRAYI_AUX =  FIELDS(FIELD_INDEX)%COLUMN + (r-1
              CALL APPENDARRAYSI(ROW,ARRAYI_AUX,INFO)		              CALL APPENDARRAYSI(ROW,ARRAYI_AUX,INFO)

           END DO						           END DO
           FIELD_INDEX = FIELD_INDEX + 1			           FIELD_INDEX = FIELD_INDEX + 1
        END DO							        END DO
        !     WRITE(*,*) REAL(VALUES)				        !     WRITE(*,*) REAL(VALUES)
        !     WRITE(*,*) ROW					        !     WRITE(*,*) ROW

        D = D*(2*N_FLOQUET(m)+1)				        D = D*(2*N_FLOQUET(m)+1)
        DEALLOCATE(VALUES_OLD_)					        DEALLOCATE(VALUES_OLD_)
        DEALLOCATE(VALUES_OLD)					        DEALLOCATE(VALUES_OLD)
        DEALLOCATE(ROW_OLD)					        DEALLOCATE(ROW_OLD)
        DEALLOCATE(COLUMN_OLD)					        DEALLOCATE(COLUMN_OLD)
        DEALLOCATE(ARRAYI_AUX)					        DEALLOCATE(ARRAYI_AUX)

        ALLOCATE(VALUES_OLD(SIZE(VALUES,1)))			        ALLOCATE(VALUES_OLD(SIZE(VALUES,1)))
        ALLOCATE(ROW_OLD(SIZE(VALUES,1)))			        ALLOCATE(ROW_OLD(SIZE(VALUES,1)))
        ALLOCATE(COLUMN_OLD(SIZE(VALUES,1)))			        ALLOCATE(COLUMN_OLD(SIZE(VALUES,1)))
        VALUES_OLD = VALUES					        VALUES_OLD = VALUES
        ROW_OLD    = ROW					        ROW_OLD    = ROW
        COLUMN_OLD = COLUMN					        COLUMN_OLD = COLUMN
     END DO							     END DO

     DEALLOCATE(VALUES_OLD)					     DEALLOCATE(VALUES_OLD)
     DEALLOCATE(ROW_OLD)					     DEALLOCATE(ROW_OLD)
     DEALLOCATE(COLUMN_OLD)					     DEALLOCATE(COLUMN_OLD)

     IF(info.eq.6) THEN						     IF(info.eq.6) THEN
        VALUES_    = VALUES					        VALUES_    = VALUES
        ROW_INDEX_ = ROW					        ROW_INDEX_ = ROW
        COLUMN_    = COLUMN					        COLUMN_    = COLUMN
     ELSE							     ELSE



     ! BUILDING THE VARIATION CRS PACKING OF THE MULTIMODE HA	     ! BUILDING THE VARIATION CRS PACKING OF THE MULTIMODE HA

     !  DO r=1,size(VALUES,1)					     !  DO r=1,size(VALUES,1)
     !     WRITE(*,*) r,ROW(r),COLUMN(r),REAL(VALUES(r))	     !     WRITE(*,*) r,ROW(r),COLUMN(r),REAL(VALUES(r))
     !  END DO							     !  END DO
     !    WRITE(*,*) SIZE(VALUES,1)				     !    WRITE(*,*) SIZE(VALUES,1)
     !    WRITE(*,*) REAL(VALUES)				     !    WRITE(*,*) REAL(VALUES)
!     WRITE(*,*) ROW						!     WRITE(*,*) ROW
     !WRITE(*,*) COLUMN						     !WRITE(*,*) COLUMN
!     WRITE(*,*) 						!     WRITE(*,*) 

        ALLOCATE(INDEX_ORDERROW(SIZE(ROW,1)))			        ALLOCATE(INDEX_ORDERROW(SIZE(ROW,1)))
        CALL QUICK_SORT_INTEGERS(ROW,INDEX_ORDERROW,SIZE(ROW,	        CALL QUICK_SORT_INTEGERS(ROW,INDEX_ORDERROW,SIZE(ROW,
        ROW    = ROW(INDEX_ORDERROW)				        ROW    = ROW(INDEX_ORDERROW)
        COLUMN = COLUMN(INDEX_ORDERROW)				        COLUMN = COLUMN(INDEX_ORDERROW)
        VALUES = VALUES(INDEX_ORDERROW)				        VALUES = VALUES(INDEX_ORDERROW)
        							        
        !     write(*,*) index_orderrow				        !     write(*,*) index_orderrow
        !     write(*,*)					        !     write(*,*)
        !     write(*,*) row					        !     write(*,*) row
        !WRITE(*,*)						        !WRITE(*,*)
        !WRITE(*,*)						        !WRITE(*,*)
        !     WRITE(*,*) size(values,1), size(column,1), size	        !     WRITE(*,*) size(values,1), size(column,1), size
        !     WRITE(*,*) D_MULTIFLOQUET				        !     WRITE(*,*) D_MULTIFLOQUET
        							        
        							        
        ALLOCATE(ROW_INDEX(D_MULTIFLOQUET+1))			        ALLOCATE(ROW_INDEX(D_MULTIFLOQUET+1))
        !ALLOCATE(ROW_INDEX(SIZE(VALUES,1)+1))			        !ALLOCATE(ROW_INDEX(SIZE(VALUES,1)+1))
        ROW_INDEX = -1						        ROW_INDEX = -1
        ROW_INDEX(D_MULTIFLOQUET+1) = SIZE(VALUES,1)+1		        ROW_INDEX(D_MULTIFLOQUET+1) = SIZE(VALUES,1)+1
        !ROW_INDEX(SIZE(VALUES,1)+1) = SIZE(VALUES,1)+1		        !ROW_INDEX(SIZE(VALUES,1)+1) = SIZE(VALUES,1)+1
        							        
        counter = 1						        counter = 1
        							        
        D = 1							        D = 1
        ROW_INDEX(1)=1						        ROW_INDEX(1)=1
        DO r = 2,SIZE(ROW,1)					        DO r = 2,SIZE(ROW,1)
           IF(ROW(r).EQ.ROW(r-1)) THEN				           IF(ROW(r).EQ.ROW(r-1)) THEN
              counter = counter +1    				              counter = counter +1    
              !           write(*,*) r,row(r), counter,D	              !           write(*,*) r,row(r), counter,D
           ELSE							           ELSE
              D = D + counter					              D = D + counter
              ROW_INDEX(ROW(r)) =D				              ROW_INDEX(ROW(r)) =D
              !if(row(r).eq.2) write(*,*)"m3",r,ROW_INDEX(ROW	              !if(row(r).eq.2) write(*,*)"m3",r,ROW_INDEX(ROW
              counter = 1					              counter = 1
           END IF						           END IF
        END DO							        END DO
        !     write(*,*) row_index(1:10)			        !     write(*,*) row_index(1:10)
        !  WRITE(*,*) D_MULTIFLOQUET,nf				        !  WRITE(*,*) D_MULTIFLOQUET,nf
        !E_L = -60.0						        !E_L = -60.0
        !E_R =  60.0						        !E_R =  60.0
        !ALLOCATE(E_FLOQUET(D_MULTIFLOQUET))			        !ALLOCATE(E_FLOQUET(D_MULTIFLOQUET))
        !ALLOCATE(U_F(D_MULTIFLOQUET,D_MULTIFLOQUET))		        !ALLOCATE(U_F(D_MULTIFLOQUET,D_MULTIFLOQUET))
        !CALL MKLSPARSE_FULLEIGENVALUES(D_MULTIFLOQUET,SIZE(V	        !CALL MKLSPARSE_FULLEIGENVALUES(D_MULTIFLOQUET,SIZE(V
        !write(*,*) E_FLOQUET					        !write(*,*) E_FLOQUET
        							        
        ALLOCATE(VALUES_(SIZE(VALUES,1)))			        ALLOCATE(VALUES_(SIZE(VALUES,1)))
        ALLOCATE(ROW_INDEX_(SIZE(ROW_INDEX,1)))			        ALLOCATE(ROW_INDEX_(SIZE(ROW_INDEX,1)))
        ALLOCATE(COLUMN_(SIZE(COLUMN,1)))			        ALLOCATE(COLUMN_(SIZE(COLUMN,1)))
        							        
        VALUES_    = VALUES					        VALUES_    = VALUES
        ROW_INDEX_ = ROW_INDEX					        ROW_INDEX_ = ROW_INDEX
        COLUMN_    = COLUMN					        COLUMN_    = COLUMN
        							        
        DO m=1,NF						        DO m=1,NF
           DEALLOCATE(FIELDS(m)%VALUES)				           DEALLOCATE(FIELDS(m)%VALUES)
           DEALLOCATE(FIELDS(m)%ROW)				           DEALLOCATE(FIELDS(m)%ROW)
           DEALLOCATE(FIELDS(m)%COLUMN)				           DEALLOCATE(FIELDS(m)%COLUMN)
        END DO							        END DO
        							        
        							        
        DEALLOCATE(VALUES)					        DEALLOCATE(VALUES)
        DEALLOCATE(ROW)						        DEALLOCATE(ROW)
        DEALLOCATE(COLUMN)					        DEALLOCATE(COLUMN)
        DEALLOCATE(ROW_INDEX)					        DEALLOCATE(ROW_INDEX)
     END IF							     END IF
  END IF							  END IF
     !  write(*,*) column_(3080:3200)				     !  write(*,*) column_(3080:3200)
END SUBROUTINE MULTIMODEFLOQUETMATRIX_SP ! _SP  sparse packin	END SUBROUTINE MULTIMODEFLOQUETMATRIX_SP ! _SP  sparse packin

diff -y ./src/MultimodeMicroMotion_C.f90 ../../Downloads/MultimodeFloquet-0.3/src/MultimodeMicroMotion_C.f90
SUBROUTINE MULTIMODEFLOQUETTRANSFORMATION_C(D,NM,MODES_NUM,U_	SUBROUTINE MULTIMODEFLOQUETTRANSFORMATION_C(D,NM,MODES_NUM,U_

  ! TIME-DEPENDENT TRANSFORMATION BETWEEN THE EXTENDED BARE B	  ! TIME-DEPENDENT TRANSFORMATION BETWEEN THE EXTENDED BARE B
  ! U(T1) = sum_ U^n exp(i n omega T1)				  ! U(T1) = sum_ U^n exp(i n omega T1)
  ! 								  ! 
!!$  D              (IN)   : DIMENSION OF THE EXTENDED HILBER	!!$  D              (IN)   : DIMENSION OF THE EXTENDED HILBER
!!$  NM             (IN)   : NUMBER OF MODES            	!!$  NM             (IN)   : NUMBER OF MODES            
!!$  MODES_NUM      (IN)   : VECTOR (NM) INDICATING THE NUMBE	!!$  MODES_NUM      (IN)   : VECTOR (NM) INDICATING THE NUMBE
!!$  U_F_MODES      (IN)   : TRANSFORMATION, DIMENSOON (D,D) 	!!$  U_F_MODES      (IN)   : TRANSFORMATION, DIMENSOON (D,D) 
!!$  E_MULTIFLOQUET (IN)   : MULTIMODE FLOQUET SPECTRUM		!!$  E_MULTIFLOQUET (IN)   : MULTIMODE FLOQUET SPECTRUM
!!$  D_BARE         (IN)   : DIMENSION OF THE BARE HILBERT SP	!!$  D_BARE         (IN)   : DIMENSION OF THE BARE HILBERT SP
!!$  FIELD          (IN)   : STRUCTURE DESCRIBING THE COUPLIN	!!$  FIELD          (IN)   : STRUCTURE DESCRIBING THE COUPLIN
!!$  T1             (IN)   : TIME. THE BARE 2 DRESSED TRANSFO	!!$  T1             (IN)   : TIME. THE BARE 2 DRESSED TRANSFO
!!$  U              (OUT)  : TRANFORMATION BETWEEN THE EXTEND	!!$  U              (OUT)  : TRANFORMATION BETWEEN THE EXTEND
!!$  INFO           (INOUT): (POSSIBLE) ERROR FLAG		!!$  INFO           (INOUT): (POSSIBLE) ERROR FLAG
 								 
  USE TYPES_C							  USE TYPES_C
  USE TYPES							  USE TYPES
  USE MODES_4F							  USE MODES_4F
  USE SUBINTERFACE_LAPACK					  USE SUBINTERFACE_LAPACK

  IMPLICIT NONE							  IMPLICIT NONE
  INTEGER,                                    INTENT(IN)    :	  INTEGER,                                    INTENT(IN)    :
  INTEGER,                                    INTENT(INOUT) :	  INTEGER,                                    INTENT(INOUT) :
  INTEGER,          DIMENSION(NM),            INTENT(IN)    :	  INTEGER,          DIMENSION(NM),            INTENT(IN)    :
  TYPE(MODE_C),     DIMENSION(NM),            INTENT(IN)    :	  TYPE(MODE_C),     DIMENSION(NM),            INTENT(IN)    :
  DOUBLE PRECISION,                           INTENT(IN)    :	  DOUBLE PRECISION,                           INTENT(IN)    :
  DOUBLE PRECISION, DIMENSION(D),             INTENT(IN)    :	  DOUBLE PRECISION, DIMENSION(D),             INTENT(IN)    :
  COMPLEX*16,       DIMENSION(D,D),           INTENT(IN)    :	  COMPLEX*16,       DIMENSION(D,D),           INTENT(IN)    :
  COMPLEX*16,       DIMENSION(D_BARE,D),      INTENT(OUT)   :	  COMPLEX*16,       DIMENSION(D_BARE,D),      INTENT(OUT)   :

  INTEGER INDEX0						  INTEGER INDEX0
  								  
  !WRITE(*,*) "ME"						  !WRITE(*,*) "ME"
  CALL MULTIMODEFLOQUETTRANSFORMATION(D,NM,MODES_NUM,U_F_MODE	  CALL MULTIMODEFLOQUETTRANSFORMATION(D,NM,MODES_NUM,U_F_MODE
  INDEX0 = D_BARE*COUPLING(2)%N_FLOQUET				  INDEX0 = D_BARE*COUPLING(2)%N_FLOQUET
  !write(*,*) D,NM,MODES_NUM					  !write(*,*) D,NM,MODES_NUM
!  write(*,*)U_F_MODES						!  write(*,*)U_F_MODES
  !write(*,*)E_MULTIFLOQUET					  !write(*,*)E_MULTIFLOQUET
  !write(*,*)D_BARE,T1						  !write(*,*)D_BARE,T1
 ! write(*,*)U,INFO						 ! write(*,*)U,INFO
  !CALL WRITE_MATRIX(ABS(U(1:D_BARE,INDEX0+1:INDEX0+D_BARE)))	  !CALL WRITE_MATRIX(ABS(U(1:D_BARE,INDEX0+1:INDEX0+D_BARE)))
  								  

END SUBROUTINE MULTIMODEFLOQUETTRANSFORMATION_C			END SUBROUTINE MULTIMODEFLOQUETTRANSFORMATION_C

SUBROUTINE MULTIMODEMICROMOTION_C(ID_C,D,NM,MODES_NUM,U_F_MOD	SUBROUTINE MULTIMODEMICROMOTION_C(ID_C,D,NM,MODES_NUM,U_F_MOD

  ! TIME-DEPENDENT TRANSFORMATION BETWEEN THE EXTENDED BARE B	  ! TIME-DEPENDENT TRANSFORMATION BETWEEN THE EXTENDED BARE B
  ! U(T1) = sum_ U^n exp(i n omega T1)				  ! U(T1) = sum_ U^n exp(i n omega T1)
  ! 								  ! 
!!$  D              (IN)   : DIMENSION OF THE EXTENDED HILBER	!!$  D              (IN)   : DIMENSION OF THE EXTENDED HILBER
!!$  NM             (IN)   : NUMBER OF MODES            	!!$  NM             (IN)   : NUMBER OF MODES            
!!$  MODES_NUM      (IN)   : VECTOR (NM) INDICATING THE NUMBE	!!$  MODES_NUM      (IN)   : VECTOR (NM) INDICATING THE NUMBE
!!$  U_F_MODES      (IN)   : TRANSFORMATION, DIMENSOON (D,D) 	!!$  U_F_MODES      (IN)   : TRANSFORMATION, DIMENSOON (D,D) 
!!$  E_MULTIFLOQUET (IN)   : MULTIMODE FLOQUET SPECTRUM		!!$  E_MULTIFLOQUET (IN)   : MULTIMODE FLOQUET SPECTRUM
!!$  D_BARE         (IN)   : DIMENSION OF THE BARE HILBERT SP	!!$  D_BARE         (IN)   : DIMENSION OF THE BARE HILBERT SP
!!$  FIELD          (IN)   : STRUCTURE DESCRIBING THE COUPLIN	!!$  FIELD          (IN)   : STRUCTURE DESCRIBING THE COUPLIN
!!$  T1             (IN)   : TIME. THE BARE 2 DRESSED TRANSFO	!!$  T1             (IN)   : TIME. THE BARE 2 DRESSED TRANSFO
!!$  U              (OUT)  : TRANFORMATION BETWEEN THE EXTEND	!!$  U              (OUT)  : TRANFORMATION BETWEEN THE EXTEND
!!$  INFO           (INOUT): (POSSIBLE) ERROR FLAG		!!$  INFO           (INOUT): (POSSIBLE) ERROR FLAG
 								 
  USE TYPES_C							  USE TYPES_C
  USE TYPES							  USE TYPES
  USE MODES_4F							  USE MODES_4F
  USE SUBINTERFACE_LAPACK					  USE SUBINTERFACE_LAPACK

  IMPLICIT NONE							  IMPLICIT NONE
  TYPE(ATOM_C),                               INTENT(IN)   ::	  TYPE(ATOM_C),                               INTENT(IN)   ::
  INTEGER,                                    INTENT(IN)    :	  INTEGER,                                    INTENT(IN)    :
  INTEGER,                                    INTENT(INOUT) :	  INTEGER,                                    INTENT(INOUT) :
  INTEGER,          DIMENSION(NM),            INTENT(IN)    :	  INTEGER,          DIMENSION(NM),            INTENT(IN)    :
  TYPE(MODE_C),     DIMENSION(NM),            INTENT(IN)    :	  TYPE(MODE_C),     DIMENSION(NM),            INTENT(IN)    :
  DOUBLE PRECISION,                           INTENT(IN)    :	  DOUBLE PRECISION,                           INTENT(IN)    :
  DOUBLE PRECISION, DIMENSION(D),             INTENT(IN)    :	  DOUBLE PRECISION, DIMENSION(D),             INTENT(IN)    :
  COMPLEX*16,       DIMENSION(D,D),           INTENT(IN)    :	  COMPLEX*16,       DIMENSION(D,D),           INTENT(IN)    :
  COMPLEX*16,       DIMENSION(D_BARE,D_BARE), INTENT(OUT)   :	  COMPLEX*16,       DIMENSION(D_BARE,D_BARE), INTENT(OUT)   :

!  COMPLEX*16,       DIMENSION(D_BARE,D),      INTENT(OUT)   	!  COMPLEX*16,       DIMENSION(D_BARE,D),      INTENT(OUT)   

  INTEGER INDEX0						  INTEGER INDEX0
  								  

  !WRITE(*,*) "ME"						  !WRITE(*,*) "ME"
  CALL MULTIMODEMICROMOTION(ATOM_,D,NM,MODES_NUM,U_F_MODES,E_	  CALL MULTIMODEMICROMOTION(ATOM_,D,NM,MODES_NUM,U_F_MODES,E_

  								  
  								  
END SUBROUTINE MULTIMODEMICROMOTION_C				END SUBROUTINE MULTIMODEMICROMOTION_C

diff -y ./src/MultimodeMicroMotionDressedBasis_C.f90 ../../Downloads/MultimodeFloquet-0.3/src/MultimodeMicroMotionDressedBasis_C.f90
MODULE PASSING2C						MODULE PASSING2C
  INTERFACE							  INTERFACE
     SUBROUTINE MICROMOTIONFOURIERDRESSEDBASIS_C(ID,DRESSINGF	     SUBROUTINE MICROMOTIONFOURIERDRESSEDBASIS_C(ID,DRESSINGF
       ! ID        (in)    :: TYPE(ATOM) system ID		       ! ID        (in)    :: TYPE(ATOM) system ID
       ! DRESSINGFIELDS_INDICES (in) :: integer array indicat	       ! DRESSINGFIELDS_INDICES (in) :: integer array indicat
       ! MODES_NUM (in)    :: integer array indicating the nu	       ! MODES_NUM (in)    :: integer array indicating the nu
       ! FIELDS    (in)    :: Array of TYPE(MODE) of dimensio	       ! FIELDS    (in)    :: Array of TYPE(MODE) of dimensio
       ! U_FD      (out)   :: complex*16 matrix fourier decom	       ! U_FD      (out)   :: complex*16 matrix fourier decom
       ! E_DRESSED (out)   :: dressed energies			       ! E_DRESSED (out)   :: dressed energies
       ! INFO      (inout) :: error flag			       ! INFO      (inout) :: error flag
       !USE TYPES_C						       !USE TYPES_C
       !USE SUBINTERFACE					       !USE SUBINTERFACE
       !USE MODES_4F						       !USE MODES_4F
       USE TYPES						       USE TYPES
       !IMPLICIT NONE						       !IMPLICIT NONE
       								       
       TYPE(ATOM),                     INTENT(IN)  :: ID	       TYPE(ATOM),                     INTENT(IN)  :: ID
       INTEGER,    DIMENSION(:),       INTENT(IN)  :: DRESSIN	       INTEGER,    DIMENSION(:),       INTENT(IN)  :: DRESSIN
       INTEGER,    DIMENSION(:),       INTENT(IN)  :: MODES_N	       INTEGER,    DIMENSION(:),       INTENT(IN)  :: MODES_N
       TYPE(MODE), DIMENSION(:),       INTENT(IN)  :: FIELDS	       TYPE(MODE), DIMENSION(:),       INTENT(IN)  :: FIELDS
       !  COMPLEX*16, DIMENSION(:,:),     ALLOCATABLE, INTENT	       !  COMPLEX*16, DIMENSION(:,:),     ALLOCATABLE, INTENT
       !  DOUBLE PRECISION, DIMENSION(:), ALLOCATABLE, INTENT	       !  DOUBLE PRECISION, DIMENSION(:), ALLOCATABLE, INTENT
       INTEGER, INTENT(INOUT) :: INFO				       INTEGER, INTENT(INOUT) :: INFO
     END SUBROUTINE MICROMOTIONFOURIERDRESSEDBASIS_C		     END SUBROUTINE MICROMOTIONFOURIERDRESSEDBASIS_C
  END INTERFACE							  END INTERFACE
END MODULE PASSING2C						END MODULE PASSING2C

SUBROUTINE MICROMOTIONFOURIERDRESSEDBASIS_C(ID,DRESSINGFIELDS	SUBROUTINE MICROMOTIONFOURIERDRESSEDBASIS_C(ID,DRESSINGFIELDS
! ID        (in)    :: TYPE(ATOM) system ID			! ID        (in)    :: TYPE(ATOM) system ID
! DRESSINGFIELDS_INDICES (in) :: integer array indicating the	! DRESSINGFIELDS_INDICES (in) :: integer array indicating the
! MODES_NUM (in)    :: integer array indicating the number of	! MODES_NUM (in)    :: integer array indicating the number of
! FIELDS    (in)    :: Array of TYPE(MODE) of dimension 	! FIELDS    (in)    :: Array of TYPE(MODE) of dimension 
! U_FD      (out)   :: complex*16 matrix fourier decompositio	! U_FD      (out)   :: complex*16 matrix fourier decompositio
! E_DRESSED (out)   :: dressed energies				! E_DRESSED (out)   :: dressed energies
! INFO      (inout) :: error flag				! INFO      (inout) :: error flag
  USE TYPES_C							  USE TYPES_C
  USE SUBINTERFACE						  USE SUBINTERFACE
  USE MODES_4F							  USE MODES_4F
  USE TYPES							  USE TYPES
  IMPLICIT NONE							  IMPLICIT NONE

  TYPE(ATOM),                     INTENT(IN)  :: ID		  TYPE(ATOM),                     INTENT(IN)  :: ID
  INTEGER,    DIMENSION(:),       INTENT(IN)  :: DRESSINGFIEL	  INTEGER,    DIMENSION(:),       INTENT(IN)  :: DRESSINGFIEL
  INTEGER,    DIMENSION(:),       INTENT(IN)  :: MODES_NUM	  INTEGER,    DIMENSION(:),       INTENT(IN)  :: MODES_NUM
  TYPE(MODE), DIMENSION(:),       INTENT(IN)  :: FIELDS		  TYPE(MODE), DIMENSION(:),       INTENT(IN)  :: FIELDS
!  COMPLEX*16, DIMENSION(:,:),     ALLOCATABLE, INTENT(OUT) :	!  COMPLEX*16, DIMENSION(:,:),     ALLOCATABLE, INTENT(OUT) :
!  DOUBLE PRECISION, DIMENSION(:), ALLOCATABLE, INTENT(OUT) :	!  DOUBLE PRECISION, DIMENSION(:), ALLOCATABLE, INTENT(OUT) :
  INTEGER, INTENT(INOUT) :: INFO				  INTEGER, INTENT(INOUT) :: INFO

  write(*,*) dressingfields_indices(1)				  write(*,*) dressingfields_indices(1)
!  CALL MICROMOTIONFOURIERDRESSEDBASIS(ID,DRESSINGFIELDS_INDI	!  CALL MICROMOTIONFOURIERDRESSEDBASIS(ID,DRESSINGFIELDS_INDI

END SUBROUTINE MICROMOTIONFOURIERDRESSEDBASIS_C			END SUBROUTINE MICROMOTIONFOURIERDRESSEDBASIS_C

SUBROUTINE MICROMOTIONDRESSEDBASIS_C(ID,MODES_NUM,DRESSINGFIE	SUBROUTINE MICROMOTIONDRESSEDBASIS_C(ID,MODES_NUM,DRESSINGFIE

! ID (in)        :: TYPE(ATOM) system ID			! ID (in)        :: TYPE(ATOM) system ID
! MODES_NUM (in) :: integer array indicating the number of ha	! MODES_NUM (in) :: integer array indicating the number of ha
! DRESSINFIELDS_INDICES :: integer array indicating the indic	! DRESSINFIELDS_INDICES :: integer array indicating the indic
! FIELDS         :: Array of TYPE(MODES) with NM components (	! FIELDS         :: Array of TYPE(MODES) with NM components (
! U_F_MODES      :: complex*16 matrix of dimension DxD. Fouri	! U_F_MODES      :: complex*16 matrix of dimension DxD. Fouri
! E_MULTIFLOQUET :: dressed energies				! E_MULTIFLOQUET :: dressed energies
! T1             :: double precision, time			! T1             :: double precision, time
! U              :: complex*16 matrix of dimension D_BARE x D	! U              :: complex*16 matrix of dimension D_BARE x D
! INFO           :: error flag					! INFO           :: error flag


  USE TYPES_C							  USE TYPES_C
  USE SUBINTERFACE						  USE SUBINTERFACE
  USE MODES_4F							  USE MODES_4F
  USE TYPES							  USE TYPES
  IMPLICIT NONE							  IMPLICIT NONE
  TYPE(ATOM),                       INTENT(IN)    :: ID		  TYPE(ATOM),                       INTENT(IN)    :: ID
  INTEGER,          DIMENSION(:),   INTENT(IN)    :: MODES_NU	  INTEGER,          DIMENSION(:),   INTENT(IN)    :: MODES_NU
  INTEGER,          DIMENSION(:),   INTENT(IN)    :: DRESSING	  INTEGER,          DIMENSION(:),   INTENT(IN)    :: DRESSING
!  COMPLEX*16,       DIMENSION(:,:), INTENT(IN)    :: U_F_MOD	!  COMPLEX*16,       DIMENSION(:,:), INTENT(IN)    :: U_F_MOD
!  DOUBLE PRECISION, DIMENSION(:),   INTENT(IN)    :: E_MULTI	!  DOUBLE PRECISION, DIMENSION(:),   INTENT(IN)    :: E_MULTI
  TYPE(MODE),       DIMENSION(:),   INTENT(IN)    :: FIELDS	  TYPE(MODE),       DIMENSION(:),   INTENT(IN)    :: FIELDS
  DOUBLE PRECISION ,                INTENT(IN)    :: T1		  DOUBLE PRECISION ,                INTENT(IN)    :: T1
  COMPLEX*16,       DIMENSION(:,:), INTENT(OUT)   :: U		  COMPLEX*16,       DIMENSION(:,:), INTENT(OUT)   :: U
  INTEGER,                          INTENT(INOUT) :: INFO	  INTEGER,                          INTENT(INOUT) :: INFO
  								  

  CALL MICROMOTIONDRESSEDBASIS(ID,MODES_NUM,DRESSINGFIELDS_IN	  CALL MICROMOTIONDRESSEDBASIS(ID,MODES_NUM,DRESSINGFIELDS_IN

END SUBROUTINE MICROMOTIONDRESSEDBASIS_C			END SUBROUTINE MICROMOTIONDRESSEDBASIS_C


diff -y ./src/MultimodeMicroMotionDressedBasis.f90 ../../Downloads/MultimodeFloquet-0.3/src/MultimodeMicroMotionDressedBasis.f90
SUBROUTINE MICROMOTIONFOURIERDRESSEDBASIS(ID,DRESSINGFIELDS_I	SUBROUTINE MICROMOTIONFOURIERDRESSEDBASIS(ID,DRESSINGFIELDS_I
! THIS SUBROUTINE CALCULATES THE FOURIER COMPONENTS (U_FD) AN	! THIS SUBROUTINE CALCULATES THE FOURIER COMPONENTS (U_FD) AN
! ID        (in)    :: TYPE(ATOM) system ID			! ID        (in)    :: TYPE(ATOM) system ID
! DRESSINGFIELDS_INDICES (in) :: integer array indicating the	! DRESSINGFIELDS_INDICES (in) :: integer array indicating the
! MODES_NUM (in)    :: integer array indicating the number of	! MODES_NUM (in)    :: integer array indicating the number of
! FIELDS    (in)    :: Array of TYPE(MODE) of dimension 	! FIELDS    (in)    :: Array of TYPE(MODE) of dimension 
! U_FD      (out)   :: complex*16 matrix fourier decompositio	! U_FD      (out)   :: complex*16 matrix fourier decompositio
! E_DRESSED (out)   :: dressed energies				! E_DRESSED (out)   :: dressed energies
! INFO      (inout) :: error flag				! INFO      (inout) :: error flag
 								 
  USE TYPES							  USE TYPES
  IMPLICIT NONE							  IMPLICIT NONE
  TYPE(ATOM),                     INTENT(IN)  :: ID		  TYPE(ATOM),                     INTENT(IN)  :: ID
  INTEGER,    DIMENSION(:),       INTENT(IN)  :: DRESSINGFIEL	  INTEGER,    DIMENSION(:),       INTENT(IN)  :: DRESSINGFIEL
  INTEGER,    DIMENSION(:),       INTENT(IN)  :: MODES_NUM	  INTEGER,    DIMENSION(:),       INTENT(IN)  :: MODES_NUM
  TYPE(MODE), DIMENSION(:),       INTENT(IN)  :: FIELDS		  TYPE(MODE), DIMENSION(:),       INTENT(IN)  :: FIELDS
  COMPLEX*16, DIMENSION(:,:),     ALLOCATABLE, INTENT(OUT) ::	  COMPLEX*16, DIMENSION(:,:),     ALLOCATABLE, INTENT(OUT) ::
  DOUBLE PRECISION, DIMENSION(:), ALLOCATABLE, INTENT(OUT) ::	  DOUBLE PRECISION, DIMENSION(:), ALLOCATABLE, INTENT(OUT) ::
  INTEGER, INTENT(INOUT) :: INFO				  INTEGER, INTENT(INOUT) :: INFO

  INTEGER :: m							  INTEGER :: m
  INTEGER :: DRESSINGFIELDS, DRESSINGFLOQUETDIMENSION		  INTEGER :: DRESSINGFIELDS, DRESSINGFLOQUETDIMENSION

  DRESSINGFIELDS = SIZE(DRESSINGFIELDS_INDICES,1)   ! NUMBER 	  DRESSINGFIELDS = SIZE(DRESSINGFIELDS_INDICES,1)   ! NUMBER 
  DRESSINGFLOQUETDIMENSION = ID%D_BARE ! EXTENDEND DIMENSION 	  DRESSINGFLOQUETDIMENSION = ID%D_BARE ! EXTENDEND DIMENSION 
  DO m=2,DRESSINGFIELDS						  DO m=2,DRESSINGFIELDS
     DRESSINGFLOQUETDIMENSION = DRESSINGFLOQUETDIMENSION*(2*F	     DRESSINGFLOQUETDIMENSION = DRESSINGFLOQUETDIMENSION*(2*F
  END DO							  END DO
  ALLOCATE(U_FD(DRESSINGFLOQUETDIMENSION,DRESSINGFLOQUETDIMEN	  ALLOCATE(U_FD(DRESSINGFLOQUETDIMENSION,DRESSINGFLOQUETDIMEN
  ALLOCATE(E_DRESSED(DRESSINGFLOQUETDIMENSION))			  ALLOCATE(E_DRESSED(DRESSINGFLOQUETDIMENSION))
  CALL DRESSEDBASIS_SUBSET(ID,DRESSINGFLOQUETDIMENSION,DRESSI	  CALL DRESSEDBASIS_SUBSET(ID,DRESSINGFLOQUETDIMENSION,DRESSI
       & U_FD,E_DRESSED,INFO) ! U_FD IS THE TRANSFORMATION OP	       & U_FD,E_DRESSED,INFO) ! U_FD IS THE TRANSFORMATION OP

END SUBROUTINE MICROMOTIONFOURIERDRESSEDBASIS			END SUBROUTINE MICROMOTIONFOURIERDRESSEDBASIS

SUBROUTINE MICROMOTIONDRESSEDBASIS(ID,MODES_NUM,DRESSINGFIELD	SUBROUTINE MICROMOTIONDRESSEDBASIS(ID,MODES_NUM,DRESSINGFIELD
! THIS SUBROUTINE CALCULATES U: THE TIME-DEPENDENT MICROMOTIO	! THIS SUBROUTINE CALCULATES U: THE TIME-DEPENDENT MICROMOTIO

! ID (in)        :: TYPE(ATOM) system ID			! ID (in)        :: TYPE(ATOM) system ID
! MODES_NUM (in) :: integer array indicating the number of ha	! MODES_NUM (in) :: integer array indicating the number of ha
! DRESSINFIELDS_INDICES :: integer array indicating the indic	! DRESSINFIELDS_INDICES :: integer array indicating the indic
! FIELDS         :: Array of TYPE(MODES) with NM components (	! FIELDS         :: Array of TYPE(MODES) with NM components (
! U_F_MODES      :: complex*16 matrix of dimension DxD. Fouri	! U_F_MODES      :: complex*16 matrix of dimension DxD. Fouri
! E_MULTIFLOQUET :: dressed energies				! E_MULTIFLOQUET :: dressed energies
! T1             :: double precision, time			! T1             :: double precision, time
! U              :: complex*16 matrix of dimension D_BARE x D	! U              :: complex*16 matrix of dimension D_BARE x D
! INFO           :: error flag					! INFO           :: error flag


  USE TYPES							  USE TYPES
  IMPLICIT NONE							  IMPLICIT NONE
  TYPE(ATOM),                       INTENT(IN)    :: ID		  TYPE(ATOM),                       INTENT(IN)    :: ID
  INTEGER,          DIMENSION(:),   INTENT(IN)    :: MODES_NU	  INTEGER,          DIMENSION(:),   INTENT(IN)    :: MODES_NU
  INTEGER,          DIMENSION(:),   INTENT(IN)    :: DRESSING	  INTEGER,          DIMENSION(:),   INTENT(IN)    :: DRESSING
  COMPLEX*16,       DIMENSION(:,:), INTENT(IN)    :: U_F_MODE	  COMPLEX*16,       DIMENSION(:,:), INTENT(IN)    :: U_F_MODE
  DOUBLE PRECISION, DIMENSION(:),   INTENT(IN)    :: E_MULTIF	  DOUBLE PRECISION, DIMENSION(:),   INTENT(IN)    :: E_MULTIF
  TYPE(MODE),       DIMENSION(:),   INTENT(IN)    :: FIELDS	  TYPE(MODE),       DIMENSION(:),   INTENT(IN)    :: FIELDS
  DOUBLE PRECISION ,                INTENT(IN)    :: T1		  DOUBLE PRECISION ,                INTENT(IN)    :: T1
  COMPLEX*16,       DIMENSION(:,:), INTENT(OUT)   :: U		  COMPLEX*16,       DIMENSION(:,:), INTENT(OUT)   :: U
  INTEGER,                          INTENT(INOUT) :: INFO	  INTEGER,                          INTENT(INOUT) :: INFO
  								  

  INTEGER :: r,m,NM_,TOTAL_FREQUENCIES_,FIELD_INDEX,DRESSINGF	  INTEGER :: r,m,NM_,TOTAL_FREQUENCIES_,FIELD_INDEX,DRESSINGF
  INTEGER :: D, D_BARE						  INTEGER :: D, D_BARE

  INTEGER, DIMENSION(:), ALLOCATABLE :: MODES_NUM_		  INTEGER, DIMENSION(:), ALLOCATABLE :: MODES_NUM_
  TYPE(MODE) , DIMENSION(:), ALLOCATABLE :: FIELDS_		  TYPE(MODE) , DIMENSION(:), ALLOCATABLE :: FIELDS_

  								  
  D = SIZE(U_F_MODES,1)						  D = SIZE(U_F_MODES,1)
  D_BARE = ID%D_BARE						  D_BARE = ID%D_BARE

  DRESSINGFIELDS = SIZE(DRESSINGFIELDS_INDICES,1)		  DRESSINGFIELDS = SIZE(DRESSINGFIELDS_INDICES,1)
  								  
  NM_ = DRESSINGFIELDS  ! NUMBER OF DRESSING MODES		  NM_ = DRESSINGFIELDS  ! NUMBER OF DRESSING MODES
  ALLOCATE(MODES_NUM_(NM_))					  ALLOCATE(MODES_NUM_(NM_))
  DO r=1,NM_							  DO r=1,NM_
     MODES_NUM_(r)=modes_num(DRESSINGFIELDS_INDICES(r)) ! NUM	     MODES_NUM_(r)=modes_num(DRESSINGFIELDS_INDICES(r)) ! NUM
  END DO							  END DO
  								  
  TOTAL_FREQUENCIES_ = SUM(MODES_NUM_,1)  ! TOTAL NUMBER OF D	  TOTAL_FREQUENCIES_ = SUM(MODES_NUM_,1)  ! TOTAL NUMBER OF D
  ALLOCATE(FIELDS_(TOTAL_FREQUENCIES_))				  ALLOCATE(FIELDS_(TOTAL_FREQUENCIES_))
  DO m=1,TOTAL_FREQUENCIES_					  DO m=1,TOTAL_FREQUENCIES_
     ALLOCATE(FIELDS_(m)%V(ID%D_BARE,ID%D_BARE)) ! PREPARE SP	     ALLOCATE(FIELDS_(m)%V(ID%D_BARE,ID%D_BARE)) ! PREPARE SP
  END DO							  END DO

  DRESSINGFLOQUETDIMENSION = ID%D_BARE ! EXTENDEND DIMENSION 	  DRESSINGFLOQUETDIMENSION = ID%D_BARE ! EXTENDEND DIMENSION 
  DO m=2,DRESSINGFIELDS						  DO m=2,DRESSINGFIELDS
     DRESSINGFLOQUETDIMENSION = DRESSINGFLOQUETDIMENSION*(2*F	     DRESSINGFLOQUETDIMENSION = DRESSINGFLOQUETDIMENSION*(2*F
  END DO							  END DO
  								  
  FIELD_INDEX = 1						  FIELD_INDEX = 1
  DO r=1,DRESSINGFIELDS						  DO r=1,DRESSINGFIELDS
     DO m=1,MODES_NUM_(r)					     DO m=1,MODES_NUM_(r)
        FIELDS_(FIELD_INDEX) = FIELDS(DRESSINGFIELDS_INDICES(	        FIELDS_(FIELD_INDEX) = FIELDS(DRESSINGFIELDS_INDICES(
        FIELD_INDEX = FIELD_INDEX+1				        FIELD_INDEX = FIELD_INDEX+1
     END DO							     END DO
  END DO							  END DO
  								  
  CALL MULTIMODEMICROMOTION(ID,D,NM_,MODES_NUM_,U_F_MODES,E_M	  CALL MULTIMODEMICROMOTION(ID,D,NM_,MODES_NUM_,U_F_MODES,E_M
  								  
END SUBROUTINE MICROMOTIONDRESSEDBASIS				END SUBROUTINE MICROMOTIONDRESSEDBASIS


diff -y ./src/MultimodeMicroMotion.f90 ../../Downloads/MultimodeFloquet-0.3/src/MultimodeMicroMotion.f90
SUBROUTINE MULTIMODEFLOQUETTRANSFORMATION(D,NM,MODES_NUM,U_F_	SUBROUTINE MULTIMODEFLOQUETTRANSFORMATION(D,NM,MODES_NUM,U_F_

  ! TIME-DEPENDENT TRANSFORMATION BETWEEN THE EXTENDED BARE B	  ! TIME-DEPENDENT TRANSFORMATION BETWEEN THE EXTENDED BARE B
  ! U(T1) = sum_ U^n exp(i n omega T1)				  ! U(T1) = sum_ U^n exp(i n omega T1)
  ! 								  ! 
!!$  D              (IN)   : DIMENSION OF THE EXTENDED HILBER	!!$  D              (IN)   : DIMENSION OF THE EXTENDED HILBER
!!$  NM             (IN)   : NUMBER OF MODES            	!!$  NM             (IN)   : NUMBER OF MODES            
!!$  MODES_NUM      (IN)   : VECTOR (NM) INDICATING THE NUMBE	!!$  MODES_NUM      (IN)   : VECTOR (NM) INDICATING THE NUMBE
!!$  U_F_MODES      (IN)   : TRANSFORMATION, DIMENSOON (D,D) 	!!$  U_F_MODES      (IN)   : TRANSFORMATION, DIMENSOON (D,D) 
!!$  E_MULTIFLOQUET (IN)   : MULTIMODE FLOQUET SPECTRUM		!!$  E_MULTIFLOQUET (IN)   : MULTIMODE FLOQUET SPECTRUM
!!$  D_BARE         (IN)   : DIMENSION OF THE BARE HILBERT SP	!!$  D_BARE         (IN)   : DIMENSION OF THE BARE HILBERT SP
!!$  FIELD          (IN)   : STRUCTURE DESCRIBING THE COUPLIN	!!$  FIELD          (IN)   : STRUCTURE DESCRIBING THE COUPLIN
!!$  T1             (IN)   : TIME. THE BARE 2 DRESSED TRANSFO	!!$  T1             (IN)   : TIME. THE BARE 2 DRESSED TRANSFO
!!$  U              (OUT)  : TRANFORMATION BETWEEN THE EXTEND	!!$  U              (OUT)  : TRANFORMATION BETWEEN THE EXTEND
!!$  INFO           (INOUT): (POSSIBLE) ERROR FLAG		!!$  INFO           (INOUT): (POSSIBLE) ERROR FLAG
 								 
  USE TYPES							  USE TYPES

  IMPLICIT NONE							  IMPLICIT NONE
  INTEGER,                                    INTENT(IN)    :	  INTEGER,                                    INTENT(IN)    :
  INTEGER,                                    INTENT(INOUT) :	  INTEGER,                                    INTENT(INOUT) :
  INTEGER,          DIMENSION(NM),            INTENT(IN)    :	  INTEGER,          DIMENSION(NM),            INTENT(IN)    :
  TYPE(MODE),       DIMENSION(NM),            INTENT(IN)    :	  TYPE(MODE),       DIMENSION(NM),            INTENT(IN)    :
  DOUBLE PRECISION,                           INTENT(IN)    :	  DOUBLE PRECISION,                           INTENT(IN)    :
  DOUBLE PRECISION, DIMENSION(D),             INTENT(IN)    :	  DOUBLE PRECISION, DIMENSION(D),             INTENT(IN)    :
  COMPLEX*16,       DIMENSION(D,D),           INTENT(IN)    :	  COMPLEX*16,       DIMENSION(D,D),           INTENT(IN)    :
  COMPLEX*16,       DIMENSION(D_BARE,D),      INTENT(OUT)   :	  COMPLEX*16,       DIMENSION(D_BARE,D),      INTENT(OUT)   :


  COMPLEX*16,       DIMENSION(D,D)      :: U_DIAGONAL		  COMPLEX*16,       DIMENSION(D,D)      :: U_DIAGONAL
  COMPLEX*16,       DIMENSION(D_BARE,D) :: U_AUX		  COMPLEX*16,       DIMENSION(D_BARE,D) :: U_AUX

  INTEGER                                                :: M	  INTEGER                                                :: M
  INTEGER,                DIMENSION(NM)                  :: N	  INTEGER,                DIMENSION(NM)                  :: N
  DOUBLE PRECISION,       DIMENSION(NM)                  :: O	  DOUBLE PRECISION,       DIMENSION(NM)                  :: O
  TYPE(HARMONIC_FACTORS), DIMENSION(:),      ALLOCATABLE :: U	  TYPE(HARMONIC_FACTORS), DIMENSION(:),      ALLOCATABLE :: U
  DOUBLE PRECISION                                       :: P	  DOUBLE PRECISION                                       :: P

!  write(*,*) size(u_f_modes,1),size(u_f_modes,2)		!  write(*,*) size(u_f_modes,1),size(u_f_modes,2)
!  do n=1,size(u_f_modes,1)					!  do n=1,size(u_f_modes,1)
!     write(*,201) abs(u_f_modes(n,:))				!     write(*,201) abs(u_f_modes(n,:))
!  end do							!  end do

!  CALL WRITE_MATRIX('matrix.dat',ABS(U_F_MODES))		!  CALL WRITE_MATRIX('matrix.dat',ABS(U_F_MODES))

  MULTIMODE_HARMONICS   = D/D_BARE				  MULTIMODE_HARMONICS   = D/D_BARE
  !write(*,*) D, D_bare,multimode_harmonics			  !write(*,*) D, D_bare,multimode_harmonics
  ALLOCATE(U_MODES_n(MULTIMODE_HARMONICS))			  ALLOCATE(U_MODES_n(MULTIMODE_HARMONICS))
  DO n=1,MULTIMODE_HARMONICS					  DO n=1,MULTIMODE_HARMONICS
     ALLOCATE(U_MODES_n(n)%U(D_BARE,D))				     ALLOCATE(U_MODES_n(n)%U(D_BARE,D))
     U_MODES_n(n)%U = 0.0					     U_MODES_n(n)%U = 0.0
     ALLOCATE(U_MODES_n(n)%n(NM))				     ALLOCATE(U_MODES_n(n)%n(NM))
     U_MODES_n(n)%n = 0						     U_MODES_n(n)%n = 0
  END DO							  END DO

  N_FLOQUET = 0							  N_FLOQUET = 0
  OMEGA_VEC = 0							  OMEGA_VEC = 0

  DO n=2,NM							  DO n=2,NM
     FIELD_INDEX  = 2+SUM(MODES_NUM(2:n-1))			     FIELD_INDEX  = 2+SUM(MODES_NUM(2:n-1))
     N_FLOQUET(n) = FIELD(FIELD_INDEX)%N_Floquet		     N_FLOQUET(n) = FIELD(FIELD_INDEX)%N_Floquet
     OMEGA_VEC(n) = FIELD(FIELD_INDEX)%OMEGA 			     OMEGA_VEC(n) = FIELD(FIELD_INDEX)%OMEGA 
     !     write(*,*) n,N_FLOQUET(n),field_index,modes_num(n)	     !     write(*,*) n,N_FLOQUET(n),field_index,modes_num(n)
     IF(modes_num(n).GT.N_FLOQUET(n)+1) THEN			     IF(modes_num(n).GT.N_FLOQUET(n)+1) THEN
        WRITE(*,*) "TO BUILD THE EXTENDED HAMILTONIAN THE NUM	        WRITE(*,*) "TO BUILD THE EXTENDED HAMILTONIAN THE NUM
        WRITE(*,*) "LARGER THAN THE NUMBER OF FIELD MODES"	        WRITE(*,*) "LARGER THAN THE NUMBER OF FIELD MODES"
        INFO = -10						        INFO = -10
     END IF							     END IF
  END DO							  END DO


  i  = 1							  i  = 1
  DO index1=1,MULTIMODE_HARMONICS				  DO index1=1,MULTIMODE_HARMONICS
     DO n=1,D							     DO n=1,D
        j = n							        j = n
        i = 1 + (index1-1)*D_BARE 				        i = 1 + (index1-1)*D_BARE 
        DO m=1,D_BARE						        DO m=1,D_BARE
           U_MODES_n(index1)%U(m,n) = U_F_MODES(i,j)		           U_MODES_n(index1)%U(m,n) = U_F_MODES(i,j)
           i = i + 1           					           i = i + 1           
        END DO							        END DO
     END DO							     END DO
!     write(*,*)						!     write(*,*)
!     write(*,*) index1						!     write(*,*) index1
 !    do n=1,size(u_modes_n(index1)%U,1)			 !    do n=1,size(u_modes_n(index1)%U,1)
 !       write(*,201) abs(u_modes_n(index1)%U(n,:))		 !       write(*,201) abs(u_modes_n(index1)%U(n,:))
 !    end do     						 !    end do     
  END DO							  END DO

  DO i=0,MULTIMODE_HARMONICS-1					  DO i=0,MULTIMODE_HARMONICS-1
     U_MODES_n(i+1)%n = 0					     U_MODES_n(i+1)%n = 0
     index0 = i							     index0 = i
     DO j=2,NM							     DO j=2,NM
        U_MODES_n(i+1)%n(j)= -N_FLOQUET(j) + MOD(index0,(2*N_	        U_MODES_n(i+1)%n(j)= -N_FLOQUET(j) + MOD(index0,(2*N_
        index0 = INT(index0/(2*N_FLOQUET(j)+1))			        index0 = INT(index0/(2*N_FLOQUET(j)+1))
     END DO							     END DO
  END DO							  END DO


  U = 0.0							  U = 0.0
  DO index1=1,MULTIMODE_HARMONICS				  DO index1=1,MULTIMODE_HARMONICS
     PHASE = DOT_PRODUCT(U_MODES_n(index1)%n,omega_vec)*T1	     PHASE = DOT_PRODUCT(U_MODES_n(index1)%n,omega_vec)*T1
     U      = U  + EXP(DCMPLX(0.0,1.0)*PHASE)*U_MODES_n(index	     U      = U  + EXP(DCMPLX(0.0,1.0)*PHASE)*U_MODES_n(index
  END DO							  END DO
 ! write(*,*)							 ! write(*,*)
 ! write(*,*) 							 ! write(*,*) 
 ! do n=1,size(U,1)						 ! do n=1,size(U,1)
 !    write(*,201) abs(u(n,:))					 !    write(*,201) abs(u(n,:))
 ! end do							 ! end do

201 format(24E15.6)						201 format(24E15.6)
END SUBROUTINE MULTIMODEFLOQUETTRANSFORMATION			END SUBROUTINE MULTIMODEFLOQUETTRANSFORMATION


!SUBROUTINE MULTIMODEFLOQUETMICROMOTION(D,NM,MODES_NUM,U_F_MO	!SUBROUTINE MULTIMODEFLOQUETMICROMOTION(D,NM,MODES_NUM,U_F_MO
!								!
!  ! TIME-DEPENDENT TRANSFORMATION BETWEEN THE EXTENDED BARE 	!  ! TIME-DEPENDENT TRANSFORMATION BETWEEN THE EXTENDED BARE 
!  ! U(T1) = sum_ U^n exp(i n omega T1)				!  ! U(T1) = sum_ U^n exp(i n omega T1)
!  ! 								!  ! 
!!!$  D              (IN)   : DIMENSION OF THE EXTENDED HILBE	!!!$  D              (IN)   : DIMENSION OF THE EXTENDED HILBE
!!!$  NM             (IN)   : NUMBER OF MODES            	!!!$  NM             (IN)   : NUMBER OF MODES            
!!!$  MODES_NUM      (IN)   : VECTOR (NM) INDICATING THE NUMB	!!!$  MODES_NUM      (IN)   : VECTOR (NM) INDICATING THE NUMB
!!!$  U_F_MODES      (IN)   : TRANSFORMATION, DIMENSOON (D,D)	!!!$  U_F_MODES      (IN)   : TRANSFORMATION, DIMENSOON (D,D)
!!!$  E_MULTIFLOQUET (IN)   : MULTIMODE FLOQUET SPECTRUM	!!!$  E_MULTIFLOQUET (IN)   : MULTIMODE FLOQUET SPECTRUM
!!!$  D_BARE         (IN)   : DIMENSION OF THE BARE HILBERT S	!!!$  D_BARE         (IN)   : DIMENSION OF THE BARE HILBERT S
!!!$  FIELD          (IN)   : STRUCTURE DESCRIBING THE COUPLI	!!!$  FIELD          (IN)   : STRUCTURE DESCRIBING THE COUPLI
!!!$  T1             (IN)   : TIME. THE BARE 2 DRESSED TRANSF	!!!$  T1             (IN)   : TIME. THE BARE 2 DRESSED TRANSF
!!!$  U              (OUT)  : TRANFORMATION BETWEEN THE EXTEN	!!!$  U              (OUT)  : TRANFORMATION BETWEEN THE EXTEN
!!!$  INFO           (INOUT): (POSSIBLE) ERROR FLAG		!!!$  INFO           (INOUT): (POSSIBLE) ERROR FLAG
! 								! 
!  USE TYPES							!  USE TYPES
!								!
!  IMPLICIT NONE						!  IMPLICIT NONE
!  INTEGER,                                    INTENT(IN)    	!  INTEGER,                                    INTENT(IN)    
!  INTEGER,                                    INTENT(INOUT) 	!  INTEGER,                                    INTENT(INOUT) 
!  INTEGER,          DIMENSION(NM),            INTENT(IN)    	!  INTEGER,          DIMENSION(NM),            INTENT(IN)    
!  TYPE(MODE),       DIMENSION(NM),            INTENT(IN)    	!  TYPE(MODE),       DIMENSION(NM),            INTENT(IN)    
!  DOUBLE PRECISION,                           INTENT(IN)    	!  DOUBLE PRECISION,                           INTENT(IN)    
!  DOUBLE PRECISION, DIMENSION(D),             INTENT(IN)    	!  DOUBLE PRECISION, DIMENSION(D),             INTENT(IN)    
!  COMPLEX*16,       DIMENSION(D,D),           INTENT(IN)    	!  COMPLEX*16,       DIMENSION(D,D),           INTENT(IN)    
!  COMPLEX*16,       DIMENSION(D_BARE,D_BARE), INTENT(OUT)   	!  COMPLEX*16,       DIMENSION(D_BARE,D_BARE), INTENT(OUT)   
!								!
!								!
!  COMPLEX*16,       DIMENSION(D,D)      :: U_DIAGONAL		!  COMPLEX*16,       DIMENSION(D,D)      :: U_DIAGONAL
!  COMPLEX*16,       DIMENSION(D_BARE,D) :: U_AUX		!  COMPLEX*16,       DIMENSION(D_BARE,D) :: U_AUX
!								!
!  INTEGER                                                :: 	!  INTEGER                                                :: 
!  INTEGER,                DIMENSION(NM)                  :: 	!  INTEGER,                DIMENSION(NM)                  :: 
!  DOUBLE PRECISION,       DIMENSION(NM)                  :: 	!  DOUBLE PRECISION,       DIMENSION(NM)                  :: 
!  TYPE(HARMONIC_FACTORS), DIMENSION(:),      ALLOCATABLE :: 	!  TYPE(HARMONIC_FACTORS), DIMENSION(:),      ALLOCATABLE :: 
!  DOUBLE PRECISION                                       :: 	!  DOUBLE PRECISION                                       :: 
!								!
!  MULTIMODE_HARMONICS   = D/D_BARE				!  MULTIMODE_HARMONICS   = D/D_BARE
!  ALLOCATE(U_MODES_n(MULTIMODE_HARMONICS))			!  ALLOCATE(U_MODES_n(MULTIMODE_HARMONICS))
!  DO n=1,MULTIMODE_HARMONICS					!  DO n=1,MULTIMODE_HARMONICS
!     ALLOCATE(U_MODES_n(n)%U(D_BARE,D))			!     ALLOCATE(U_MODES_n(n)%U(D_BARE,D))
!     U_MODES_n(n)%U = 0.0					!     U_MODES_n(n)%U = 0.0
!     ALLOCATE(U_MODES_n(n)%n(NM))				!     ALLOCATE(U_MODES_n(n)%n(NM))
!     U_MODES_n(n)%n = 0					!     U_MODES_n(n)%n = 0
!  END DO							!  END DO
!								!
!  N_FLOQUET = 0						!  N_FLOQUET = 0
!  OMEGA_VEC = 0						!  OMEGA_VEC = 0
!								!
!  DO n=2,NM							!  DO n=2,NM
!     FIELD_INDEX  = 2+SUM(MODES_NUM(2:n-1))			!     FIELD_INDEX  = 2+SUM(MODES_NUM(2:n-1))
!     N_FLOQUET(n) = FIELD(FIELD_INDEX)%N_Floquet		!     N_FLOQUET(n) = FIELD(FIELD_INDEX)%N_Floquet
!     OMEGA_VEC(n) = FIELD(FIELD_INDEX)%OMEGA 			!     OMEGA_VEC(n) = FIELD(FIELD_INDEX)%OMEGA 
!     !     write(*,*) n,N_FLOQUET(n),field_index,modes_num(n	!     !     write(*,*) n,N_FLOQUET(n),field_index,modes_num(n
!     IF(modes_num(n).GT.N_FLOQUET(n)+1) THEN			!     IF(modes_num(n).GT.N_FLOQUET(n)+1) THEN
!        WRITE(*,*) "TO BUILD THE EXTENDED HAMILTONIAN THE NU	!        WRITE(*,*) "TO BUILD THE EXTENDED HAMILTONIAN THE NU
!        WRITE(*,*) "LARGER THAN THE NUMBER OF FIELD MODES"	!        WRITE(*,*) "LARGER THAN THE NUMBER OF FIELD MODES"
!        INFO = -10						!        INFO = -10
!     END IF							!     END IF
!  END DO							!  END DO
! ! DO i=1,NM							! ! DO i=1,NM
! !    OMEGA_VEC(i) = FIELD(i)%OMEGA				! !    OMEGA_VEC(i) = FIELD(i)%OMEGA
! ! END DO							! ! END DO
!								!
!								!
!  i  = 1							!  i  = 1
!  DO index1=1,MULTIMODE_HARMONICS				!  DO index1=1,MULTIMODE_HARMONICS
!     DO n=1,D							!     DO n=1,D
!        j = n							!        j = n
!        i = 1 + (index1-1)*D_BARE 				!        i = 1 + (index1-1)*D_BARE 
!        DO m=1,D_BARE						!        DO m=1,D_BARE
!           U_MODES_n(index1)%U(m,n) = U_F_MODES(i,j)		!           U_MODES_n(index1)%U(m,n) = U_F_MODES(i,j)
!           i = i + 1           				!           i = i + 1           
!        END DO							!        END DO
!     END DO							!     END DO
!  END DO							!  END DO
!								!
!  DO i=0,MULTIMODE_HARMONICS-1					!  DO i=0,MULTIMODE_HARMONICS-1
!     U_MODES_n(i+1)%n = 0					!     U_MODES_n(i+1)%n = 0
!     index0 = i						!     index0 = i
!     DO j=2,NM							!     DO j=2,NM
!        U_MODES_n(i+1)%n(j)= -N_FLOQUET(j) + MOD(index0,(2*N	!        U_MODES_n(i+1)%n(j)= -N_FLOQUET(j) + MOD(index0,(2*N
!        index0 = INT(index0/(2*N_FLOQUET(j)+1))		!        index0 = INT(index0/(2*N_FLOQUET(j)+1))
!     END DO							!     END DO
!  END DO							!  END DO
!								!
!								!
!  U_AUX = 0.0							!  U_AUX = 0.0
!  DO index1=1,MULTIMODE_HARMONICS				!  DO index1=1,MULTIMODE_HARMONICS
!     PHASE = DOT_PRODUCT(U_MODES_n(index1)%n,omega_vec)*T1	!     PHASE = DOT_PRODUCT(U_MODES_n(index1)%n,omega_vec)*T1
!     U_AUX      = U_AUX  + EXP(DCMPLX(0.0,1.0)*PHASE)*U_MODE	!     U_AUX      = U_AUX  + EXP(DCMPLX(0.0,1.0)*PHASE)*U_MODE
!  END DO							!  END DO
!								!
!  !INDEX_L = d_bare*d_bare*(((dressingfloquetdimension/d_bar	!  !INDEX_L = d_bare*d_bare*(((dressingfloquetdimension/d_bar
!  INDEX_L = D_BARE* ((D/D_BARE - 1)/2)!D/2 - D_BARE/2   	!  INDEX_L = D_BARE* ((D/D_BARE - 1)/2)!D/2 - D_BARE/2   
!  U = U_AUX(1:D_BARE,INDEX_L+1:INDEX_L+D_BARE)			!  U = U_AUX(1:D_BARE,INDEX_L+1:INDEX_L+D_BARE)
!								!
!END SUBROUTINE MULTIMODEFLOQUETMICROMOTION			!END SUBROUTINE MULTIMODEFLOQUETMICROMOTION



SUBROUTINE MULTIMODEMICROMOTION(ID,D,NM,MODES_NUM,U_F_MODES,E	SUBROUTINE MULTIMODEMICROMOTION(ID,D,NM,MODES_NUM,U_F_MODES,E

  ! TIME-DEPENDENT TRANSFORMATION BETWEEN THE EXTENDED BARE B	  ! TIME-DEPENDENT TRANSFORMATION BETWEEN THE EXTENDED BARE B
  ! U(T1) = sum_ U^n exp(i n omega T1)				  ! U(T1) = sum_ U^n exp(i n omega T1)
  ! 								  ! 
!!$  D              (IN)   : DIMENSION OF THE EXTENDED HILBER	!!$  D              (IN)   : DIMENSION OF THE EXTENDED HILBER
!!$  NM             (IN)   : NUMBER OF MODES            	!!$  NM             (IN)   : NUMBER OF MODES            
!!$  MODES_NUM      (IN)   : VECTOR (NM) INDICATING THE NUMBE	!!$  MODES_NUM      (IN)   : VECTOR (NM) INDICATING THE NUMBE
!!$  U_F_MODES      (IN)   : TRANSFORMATION, DIMENSOON (D,D) 	!!$  U_F_MODES      (IN)   : TRANSFORMATION, DIMENSOON (D,D) 
!!$  E_MULTIFLOQUET (IN)   : MULTIMODE FLOQUET SPECTRUM		!!$  E_MULTIFLOQUET (IN)   : MULTIMODE FLOQUET SPECTRUM
!!$  D_BARE         (IN)   : DIMENSION OF THE BARE HILBERT SP	!!$  D_BARE         (IN)   : DIMENSION OF THE BARE HILBERT SP
!!$  FIELD          (IN)   : STRUCTURE DESCRIBING THE COUPLIN	!!$  FIELD          (IN)   : STRUCTURE DESCRIBING THE COUPLIN
!!$  T1             (IN)   : TIME. THE BARE 2 DRESSED TRANSFO	!!$  T1             (IN)   : TIME. THE BARE 2 DRESSED TRANSFO
!!$  U              (OUT)  : TRANFORMATION BETWEEN THE EXTEND	!!$  U              (OUT)  : TRANFORMATION BETWEEN THE EXTEND
!!$  INFO           (INOUT): (POSSIBLE) ERROR FLAG		!!$  INFO           (INOUT): (POSSIBLE) ERROR FLAG
 								 
  !USE TYPES_C							  !USE TYPES_C
  USE TYPES							  USE TYPES
  !USE MODES_4F							  !USE MODES_4F
  USE SUBINTERFACE_LAPACK					  USE SUBINTERFACE_LAPACK
  USE ATOMIC_PROPERTIES						  USE ATOMIC_PROPERTIES

  IMPLICIT NONE							  IMPLICIT NONE
  TYPE(ATOM),                INTENT(IN)    :: ID		  TYPE(ATOM),                INTENT(IN)    :: ID
  INTEGER,                                    INTENT(IN)    :	  INTEGER,                                    INTENT(IN)    :
  INTEGER,                                    INTENT(INOUT) :	  INTEGER,                                    INTENT(INOUT) :
  INTEGER,          DIMENSION(NM),            INTENT(IN)    :	  INTEGER,          DIMENSION(NM),            INTENT(IN)    :
  TYPE(MODE),       DIMENSION(NM),            INTENT(IN)    :	  TYPE(MODE),       DIMENSION(NM),            INTENT(IN)    :
  DOUBLE PRECISION,                           INTENT(IN)    :	  DOUBLE PRECISION,                           INTENT(IN)    :
  DOUBLE PRECISION, DIMENSION(D),             INTENT(IN)    :	  DOUBLE PRECISION, DIMENSION(D),             INTENT(IN)    :
  COMPLEX*16,       DIMENSION(D,D),           INTENT(IN)    :	  COMPLEX*16,       DIMENSION(D,D),           INTENT(IN)    :
  COMPLEX*16,       DIMENSION(D_BARE,D_BARE), INTENT(OUT)   :	  COMPLEX*16,       DIMENSION(D_BARE,D_BARE), INTENT(OUT)   :

    								    
  COMPLEX*16,       DIMENSION(D_BARE,D) :: U_AUX ! TIME-DEPEN	  COMPLEX*16,       DIMENSION(D_BARE,D) :: U_AUX ! TIME-DEPEN

  INTEGER INDEX0						  INTEGER INDEX0
  								  
  !WRITE(*,*) "MICROMOTION SUBROUTINE    "			  !WRITE(*,*) "MICROMOTION SUBROUTINE    "
  CALL MULTIMODEFLOQUETTRANSFORMATION(D,NM,MODES_NUM,U_F_MODE	  CALL MULTIMODEFLOQUETTRANSFORMATION(D,NM,MODES_NUM,U_F_MODE
  U = 0.0							  U = 0.0
  IF(ID%id_system.EQ.3) THEN					  IF(ID%id_system.EQ.3) THEN
     INDEX0 = (2*Fdown+1)*FIELD(2)%N_FLOQUET			     INDEX0 = (2*Fdown+1)*FIELD(2)%N_FLOQUET
!     write(*,*) index0,Fdown,Fup				!     write(*,*) index0,Fdown,Fup
     U(1:2*Fdown+1,1:2*Fdown+1) = U_AUX(1:2*Fdown+1,INDEX0+1:	     U(1:2*Fdown+1,1:2*Fdown+1) = U_AUX(1:2*Fdown+1,INDEX0+1:
     INDEX0 = (2*Fdown+1)*(2*FIELD(2)%N_FLOQUET+1) + (2*Fup+1	     INDEX0 = (2*Fdown+1)*(2*FIELD(2)%N_FLOQUET+1) + (2*Fup+1
!     write(*,*) index0,Fdown,Fup,U_AUX(2*Fdown+2:2*Fdown+1+2	!     write(*,*) index0,Fdown,Fup,U_AUX(2*Fdown+2:2*Fdown+1+2
     U(2*Fdown+2:2*Fdown+1+2*Fup+1,2*Fdown+2:2*Fdown+1+2*Fup+	     U(2*Fdown+2:2*Fdown+1+2*Fup+1,2*Fdown+2:2*Fdown+1+2*Fup+
  ELSE								  ELSE
     INDEX0 = D_BARE*FIELD(2)%N_FLOQUET				     INDEX0 = D_BARE*FIELD(2)%N_FLOQUET
     !INDEX0 = D_BARE* ((D/D_BARE - 1)/2)!D/2 - D_BARE/2     	     !INDEX0 = D_BARE* ((D/D_BARE - 1)/2)!D/2 - D_BARE/2     
     U = U_AUX(1:D_BARE,INDEX0+1:INDEX0+D_BARE)			     U = U_AUX(1:D_BARE,INDEX0+1:INDEX0+D_BARE)

  END IF							  END IF
  								  
END SUBROUTINE MULTIMODEMICROMOTION				END SUBROUTINE MULTIMODEMICROMOTION


diff -y ./src/MultimodeTransitionAVG_C.f90 ../../Downloads/MultimodeFloquet-0.3/src/MultimodeTransitionAVG_C.f90
SUBROUTINE MULTIMODETRANSITIONAVG_C(D,NM,FIELD,MODES_NUM,U_F_	SUBROUTINE MULTIMODETRANSITIONAVG_C(D,NM,FIELD,MODES_NUM,U_F_
!!$   AVERAGE TIME EVOLUTION OPERATOR OF A MULTIMODE DRESSED 	!!$   AVERAGE TIME EVOLUTION OPERATOR OF A MULTIMODE DRESSED 
!!$   MULTIMODE FLOQUET HAMILTONIAN				!!$   MULTIMODE FLOQUET HAMILTONIAN
!!$   U : MATRIX OF AVERAGE TRANSITION PROBABILITIES		!!$   U : MATRIX OF AVERAGE TRANSITION PROBABILITIES
!!$								!!$
!!$  D              (IN)   : DIMENSION OF THE EXTENDED HILBER	!!$  D              (IN)   : DIMENSION OF THE EXTENDED HILBER
!!$  NM             (IN)   : NUMBER OF MODES            	!!$  NM             (IN)   : NUMBER OF MODES            
!!$  MODES_NUM      (IN)   : VECTOR (NM) INDICATING THE NUMBE	!!$  MODES_NUM      (IN)   : VECTOR (NM) INDICATING THE NUMBE
!!$  U_F_MODES      (IN)   : TRANSFORMATION, DIMENSOON (D,D) 	!!$  U_F_MODES      (IN)   : TRANSFORMATION, DIMENSOON (D,D) 
!!$  E_MULTIFLOQUET (IN)   : MULTIMODE FLOQUET SPECTRUM		!!$  E_MULTIFLOQUET (IN)   : MULTIMODE FLOQUET SPECTRUM
!!$  D_BARE         (IN)   : DIMENSION OF THE BARE HILBERT SP	!!$  D_BARE         (IN)   : DIMENSION OF THE BARE HILBERT SP
!!$  U              (OUT)  :  MATRIX OF AVERAGE TRANSITION PR	!!$  U              (OUT)  :  MATRIX OF AVERAGE TRANSITION PR
!!$  INFO           (INOUT): (POSSIBLE) ERROR FLAG		!!$  INFO           (INOUT): (POSSIBLE) ERROR FLAG
  								  
  USE TYPES							  USE TYPES
  USE TYPES_C							  USE TYPES_C
  USE MODES_4F							  USE MODES_4F
  !  USE SUBINTERFACE_LAPACK					  !  USE SUBINTERFACE_LAPACK
  								  
  IMPLICIT NONE							  IMPLICIT NONE
  TYPE(MODE_C),DIMENSION(NM), INTENT(IN)     :: FIELD		  TYPE(MODE_C),DIMENSION(NM), INTENT(IN)     :: FIELD
  INTEGER,     DIMENSION(NM), INTENT(IN)     :: MODES_NUM	  INTEGER,     DIMENSION(NM), INTENT(IN)     :: MODES_NUM

  INTEGER,                                    INTENT(IN)    :	  INTEGER,                                    INTENT(IN)    :
  INTEGER,                                    INTENT(INOUT) :	  INTEGER,                                    INTENT(INOUT) :
  DOUBLE PRECISION, DIMENSION(D),             INTENT(IN)    :	  DOUBLE PRECISION, DIMENSION(D),             INTENT(IN)    :
  COMPLEX*16,       DIMENSION(D,D),           INTENT(IN)    :	  COMPLEX*16,       DIMENSION(D,D),           INTENT(IN)    :
  DOUBLE PRECISION, DIMENSION(D_BARE,D_BARE), INTENT(OUT)   :	  DOUBLE PRECISION, DIMENSION(D_BARE,D_BARE), INTENT(OUT)   :
  								  
  CALL MULTIMODETRANSITIONAVG(D,NM,COUPLING,MODES_NUM,U_F_MOD	  CALL MULTIMODETRANSITIONAVG(D,NM,COUPLING,MODES_NUM,U_F_MOD
  								  
END SUBROUTINE MULTIMODETRANSITIONAVG_C				END SUBROUTINE MULTIMODETRANSITIONAVG_C


!!$SUBROUTINE MULTIMODETRANSITIONPROBABILITY_DRESSEDBASIS(D_F	!!$SUBROUTINE MULTIMODETRANSITIONPROBABILITY_DRESSEDBASIS(D_F
!!$     & D_BARE,P,P2,INFO)					!!$     & D_BARE,P,P2,INFO)
!!$								!!$
!!$  !D                : dimension of the multimode hilbert s	!!$  !D                : dimension of the multimode hilbert s
!!$  !D_F              : dimension of the dressed hilbert spa	!!$  !D_F              : dimension of the dressed hilbert spa
!!$  !U_F_MODES        : D x D matrix transformation to the m	!!$  !U_F_MODES        : D x D matrix transformation to the m
!!$  !U_F              : D_F x D_F matrix transformation to t	!!$  !U_F              : D_F x D_F matrix transformation to t
!!$  !E_DRESSED        : single mode eigenvalues == dressed e	!!$  !E_DRESSED        : single mode eigenvalues == dressed e
!!$  !E_MULTIFLOQUET   : multimode eigenvalues			!!$  !E_MULTIFLOQUET   : multimode eigenvalues
!!$  !D_BARE           : dimension of the bare hilbert space	!!$  !D_BARE           : dimension of the bare hilbert space
!!$  !P                : matrix of Time and phase average tra	!!$  !P                : matrix of Time and phase average tra
!!$  !INFO             : for info				!!$  !INFO             : for info
!!$								!!$
!!$  ! The dressed basis is not always well defined.		!!$  ! The dressed basis is not always well defined.
!!$  !Time average transition probability			!!$  !Time average transition probability
!!$								!!$
!!$  USE SUBINTERFACE_LAPACK					!!$  USE SUBINTERFACE_LAPACK
!!$!  USE FLOQUET						!!$!  USE FLOQUET
!!$  USE TYPES							!!$  USE TYPES
!!$								!!$
!!$  IMPLICIT NONE						!!$  IMPLICIT NONE
!!$  INTEGER,                                    INTENT(IN)  	!!$  INTEGER,                                    INTENT(IN)  
!!$  COMPLEX*16,       DIMENSION(D_F,D_F),       INTENT(INOUT	!!$  COMPLEX*16,       DIMENSION(D_F,D_F),       INTENT(INOUT
!!$  COMPLEX*16,       DIMENSION(D,D),           INTENT(INOUT	!!$  COMPLEX*16,       DIMENSION(D,D),           INTENT(INOUT
!!$  DOUBLE PRECISION, DIMENSION(D_F),           INTENT(IN)  	!!$  DOUBLE PRECISION, DIMENSION(D_F),           INTENT(IN)  
!!$  DOUBLE PRECISION, DIMENSION(D),             INTENT(IN)  	!!$  DOUBLE PRECISION, DIMENSION(D),             INTENT(IN)  
!!$  !  COMPLEX*16,       DIMENSION(D_Bare,D_Bare),       INT	!!$  !  COMPLEX*16,       DIMENSION(D_Bare,D_Bare),       INT
!!$  COMPLEX*16,       DIMENSION(D_F,D_F),       INTENT(OUT) 	!!$  COMPLEX*16,       DIMENSION(D_F,D_F),       INTENT(OUT) 
!!$								!!$
!!$  INTEGER,                                    INTENT(INOUT	!!$  INTEGER,                                    INTENT(INOUT
!!$								!!$
!!$								!!$
!!$  TYPE(HARMONIC_FACTORS), DIMENSION(:),ALLOCATABLE :: U_n,	!!$  TYPE(HARMONIC_FACTORS), DIMENSION(:),ALLOCATABLE :: U_n,
!!$  COMPLEX*16, DIMENSION(D,D)       :: U_AUX_F ! TEMPORAL V	!!$  COMPLEX*16, DIMENSION(D,D)       :: U_AUX_F ! TEMPORAL V
!!$  !COMPLEX*16, DIMENSION(D_F,D_F)  :: U_AUX			!!$  !COMPLEX*16, DIMENSION(D_F,D_F)  :: U_AUX
!!$  COMPLEX*16, DIMENSION(D_F,D)     :: U_AUX			!!$  COMPLEX*16, DIMENSION(D_F,D)     :: U_AUX
!!$  COMPLEX*16, DIMENSION(D,D_F)     :: U_AUX_2		!!$  COMPLEX*16, DIMENSION(D,D_F)     :: U_AUX_2
!!$								!!$
!!$  DOUBLE PRECISION, DIMENSION(D)   :: PHASE_CONVENTION_MOD	!!$  DOUBLE PRECISION, DIMENSION(D)   :: PHASE_CONVENTION_MOD
!!$  DOUBLE PRECISION, DIMENSION(D_F) :: PHASE_CONVENTION_SIN	!!$  DOUBLE PRECISION, DIMENSION(D_F) :: PHASE_CONVENTION_SIN
!!$								!!$
!!$  INTEGER n,m,index1,index2,i,j,index,index_,index3,index0	!!$  INTEGER n,m,index1,index2,i,j,index,index_,index3,index0
!!$  INTEGER DRESSED_HARMONICS, MULTIMODE_HARMONICS,D_AUX	!!$  INTEGER DRESSED_HARMONICS, MULTIMODE_HARMONICS,D_AUX
!!$								!!$
!!$  INTEGER :: a,c,e,g,k,k_,n_,lambda,l,l_			!!$  INTEGER :: a,c,e,g,k,k_,n_,lambda,l,l_
!!$								!!$
!!$  DRESSED_HARMONICS   = D_F/D_BARE				!!$  DRESSED_HARMONICS   = D_F/D_BARE
!!$  MULTIMODE_HARMONICS =   D/D_BARE				!!$  MULTIMODE_HARMONICS =   D/D_BARE
!!$								!!$
!!$  ALLOCATE(U_n(DRESSED_HARMONICS))				!!$  ALLOCATE(U_n(DRESSED_HARMONICS))
!!$  ALLOCATE(U_MODES_n(MULTIMODE_HARMONICS))			!!$  ALLOCATE(U_MODES_n(MULTIMODE_HARMONICS))
!!$  ALLOCATE(U_nn(DRESSED_HARMONICS*MULTIMODE_HARMONICS))	!!$  ALLOCATE(U_nn(DRESSED_HARMONICS*MULTIMODE_HARMONICS))
!!$  ALLOCATE(U_nn2(DRESSED_HARMONICS*MULTIMODE_HARMONICS))	!!$  ALLOCATE(U_nn2(DRESSED_HARMONICS*MULTIMODE_HARMONICS))
!!$								!!$
!!$  DO n=1,DRESSED_HARMONICS					!!$  DO n=1,DRESSED_HARMONICS
!!$     ALLOCATE(U_n(n)%U(D_BARE,D_F))   ! All singlemode dre	!!$     ALLOCATE(U_n(n)%U(D_BARE,D_F))   ! All singlemode dre
!!$     !ALLOCATE(U_n(n)%U(D_BARE,D_BARE)) ! Select a manifol	!!$     !ALLOCATE(U_n(n)%U(D_BARE,D_BARE)) ! Select a manifol
!!$     U_n(n)%U = 0.0						!!$     U_n(n)%U = 0.0
!!$  END DO							!!$  END DO
!!$								!!$
!!$  DO n=1,MULTIMODE_HARMONICS					!!$  DO n=1,MULTIMODE_HARMONICS
!!$     ALLOCATE(U_MODES_n(n)%U(D_BARE,D)) !Full set of multi	!!$     ALLOCATE(U_MODES_n(n)%U(D_BARE,D)) !Full set of multi
!!$     !ALLOCATE(U_MODES_n(n)%U(D_BARE,D_BARE)) !Single out 	!!$     !ALLOCATE(U_MODES_n(n)%U(D_BARE,D_BARE)) !Single out 
!!$     U_MODES_n(n)%U = 0.0					!!$     U_MODES_n(n)%U = 0.0
!!$     ALLOCATE(U_MODES_n(n)%n(MODES_NUM))			!!$     ALLOCATE(U_MODES_n(n)%n(MODES_NUM))
!!$     U_MODES_n(n)%n = 0					!!$     U_MODES_n(n)%n = 0
!!$  END DO							!!$  END DO
!!$								!!$
!!$  DO n=1,DRESSED_HARMONICS*MULTIMODE_HARMONICS		!!$  DO n=1,DRESSED_HARMONICS*MULTIMODE_HARMONICS
!!$     !ALLOCATE(U_nn(n)%U(D_F,D_BARE))			!!$     !ALLOCATE(U_nn(n)%U(D_F,D_BARE))
!!$     !U_nn(n)%U = 0.0					!!$     !U_nn(n)%U = 0.0
!!$     !ALLOCATE(U_nn2(n)%U(D_F,D_BARE))			!!$     !ALLOCATE(U_nn2(n)%U(D_F,D_BARE))
!!$     !U_nn2(n)%U = 0.0					!!$     !U_nn2(n)%U = 0.0
!!$     ALLOCATE(U_nn(n)%U(D_F,D))				!!$     ALLOCATE(U_nn(n)%U(D_F,D))
!!$     U_nn(n)%U = 0.0						!!$     U_nn(n)%U = 0.0
!!$     ALLOCATE(U_nn2(n)%U(D_F,D))				!!$     ALLOCATE(U_nn2(n)%U(D_F,D))
!!$     U_nn2(n)%U = 0.0					!!$     U_nn2(n)%U = 0.0
!!$  END DO							!!$  END DO
!!$  i  = 1							!!$  i  = 1
!!$  DO index1=1,DRESSED_HARMONICS				!!$  DO index1=1,DRESSED_HARMONICS
!!$     i = 1 + (index1-1)*D_BARE				!!$     i = 1 + (index1-1)*D_BARE
!!$     U_n(index1)%U = U_F(i:i+D_BARE-1,1:D_F)			!!$     U_n(index1)%U = U_F(i:i+D_BARE-1,1:D_F)
!!$     !index2 = D_BARE*N_FLOQUET(2)+1				!!$     !index2 = D_BARE*N_FLOQUET(2)+1
!!$     !U_n(index1)%U = U_F(i:i+D_BARE-1,index2:index2+D_BAR	!!$     !U_n(index1)%U = U_F(i:i+D_BARE-1,index2:index2+D_BAR
!!$     !call write_matrix(ABS(U_n(index1)%U))			!!$     !call write_matrix(ABS(U_n(index1)%U))
!!$     !							!!$     !
!!$  END DO							!!$  END DO
!!$								!!$
!!$								!!$
!!$  DO i=0,MULTIMODE_HARMONICS-1				!!$  DO i=0,MULTIMODE_HARMONICS-1
!!$     U_MODES_n(i+1)%n = 0					!!$     U_MODES_n(i+1)%n = 0
!!$     index1 = i						!!$     index1 = i
!!$     DO j=2,MODES_NUM					!!$     DO j=2,MODES_NUM
!!$        U_MODES_n(i+1)%n(j)= -N_FLOQUET(j) + MOD(index1,(2	!!$        U_MODES_n(i+1)%n(j)= -N_FLOQUET(j) + MOD(index1,(2
!!$        index1 = INT(index1/(2*N_FLOQUET(j)+1))		!!$        index1 = INT(index1/(2*N_FLOQUET(j)+1))
!!$     END DO							!!$     END DO
!!$  END DO							!!$  END DO
!!$								!!$
!!$  i  = 1							!!$  i  = 1
!!$  DO index1=1,MULTIMODE_HARMONICS				!!$  DO index1=1,MULTIMODE_HARMONICS
!!$     i = 1 + (index1-1)*D_BARE				!!$     i = 1 + (index1-1)*D_BARE
!!$     U_MODES_n(index1)%U = U_F_MODES(i:i+D_BARE-1,1:D)	!!$     U_MODES_n(index1)%U = U_F_MODES(i:i+D_BARE-1,1:D)
!!$     !WRITE(*,*) INDEX1,U_MODES_n(index1)%n			!!$     !WRITE(*,*) INDEX1,U_MODES_n(index1)%n
!!$     !call write_matrix(ABS(U_MODES_n(index1)%U))		!!$     !call write_matrix(ABS(U_MODES_n(index1)%U))
!!$								!!$
!!$     !index3 = MULTIMODE_HARMONICS*D_BARE/2.0 -1		!!$     !index3 = MULTIMODE_HARMONICS*D_BARE/2.0 -1
!!$     !     !U_MODES_n(index1)%U = U_F_MODES(i:i+D_BARE-1,i	!!$     !     !U_MODES_n(index1)%U = U_F_MODES(i:i+D_BARE-1,i
!!$  END DO							!!$  END DO
!!$								!!$
!!$  index1 =1							!!$  index1 =1
!!$  DO n=1,DRESSED_HARMONICS					!!$  DO n=1,DRESSED_HARMONICS
!!$     DO m=1,MULTIMODE_HARMONICS				!!$     DO m=1,MULTIMODE_HARMONICS
!!$        U_nn(index1)%U  = ABS(MATMUL(TRANSPOSE(CONJG(U_n(n	!!$        U_nn(index1)%U  = ABS(MATMUL(TRANSPOSE(CONJG(U_n(n
!!$        !      CALL WRITE_MATRIX(ABS(U_n(n)%U))		!!$        !      CALL WRITE_MATRIX(ABS(U_n(n)%U))
!!$        !      CALL WRITE_MATRIX(ABS(U_MODES_n(m)%U))	!!$        !      CALL WRITE_MATRIX(ABS(U_MODES_n(m)%U))
!!$        !      CALL WRITE_MATRIX(ABS(U_nn(index1)%U))	!!$        !      CALL WRITE_MATRIX(ABS(U_nn(index1)%U))
!!$        index1 =  index1 + 1					!!$        index1 =  index1 + 1
!!$     END DO							!!$     END DO
!!$  END DO							!!$  END DO
!!$								!!$
!!$  !P = ABS(MATMUL(TRANSPOSE(CONJG(U_F)),U_F_MODES))**2	!!$  !P = ABS(MATMUL(TRANSPOSE(CONJG(U_F)),U_F_MODES))**2
!!$  !P = MATMUL(P,TRANSPOSE(CONJG(P)))				!!$  !P = MATMUL(P,TRANSPOSE(CONJG(P)))
!!$  !								!!$  !
!!$  INDEX0 = (DRESSED_HARMONICS -1)/2 + 1			!!$  INDEX0 = (DRESSED_HARMONICS -1)/2 + 1
!!$  INDEX1 = (MULTIMODE_HARMONICS -1)/2 + 1			!!$  INDEX1 = (MULTIMODE_HARMONICS -1)/2 + 1
!!$  !write(*,*) '#',index0,index1				!!$  !write(*,*) '#',index0,index1
!!$								!!$
!!$  U_AUX = ABS(MATMUL(TRANSPOSE(CONJG(U_n(INDEX0)%U)),U_MOD	!!$  U_AUX = ABS(MATMUL(TRANSPOSE(CONJG(U_n(INDEX0)%U)),U_MOD
!!$								!!$
!!$  !as in 10.10.17						!!$  !as in 10.10.17
!!$  P = 0.0							!!$  P = 0.0
!!$  DO index1  = 1,DRESSED_HARMONICS*MULTIMODE_HARMONICS!,MU	!!$  DO index1  = 1,DRESSED_HARMONICS*MULTIMODE_HARMONICS!,MU
!!$     !write(*,*) size(U_aux,1),size(U_aux,2),size(u_nn(ind	!!$     !write(*,*) size(U_aux,1),size(U_aux,2),size(u_nn(ind
!!$     !P = P + MATMUL(U_AUX,transpose(conjg(U_nn(index1)%U)	!!$     !P = P + MATMUL(U_AUX,transpose(conjg(U_nn(index1)%U)
!!$     P = P + MATMUL(U_nn(index1)%U,TRANSPOSE(U_AUX))		!!$     P = P + MATMUL(U_nn(index1)%U,TRANSPOSE(U_AUX))
!!$     !P = P + MATMUL(U_AUX,TRANSPOSE(U_AUX))			!!$     !P = P + MATMUL(U_AUX,TRANSPOSE(U_AUX))
!!$  END DO							!!$  END DO
!!$								!!$
!!$								!!$
!!$  !  write(*,*) real(P(4,4)),real(P(4,5)),real(P(5,5))	!!$  !  write(*,*) real(P(4,4)),real(P(4,5)),real(P(5,5))
!!$  !  P = 0.0							!!$  !  P = 0.0
!!$  !  DO index1  = MULTIMODE_HARMONICS+1,MULTIMODE_HARMONIC	!!$  !  DO index1  = MULTIMODE_HARMONICS+1,MULTIMODE_HARMONIC
!!$  !     P = P + MATMUL(U_nn(index1)%U,TRANSPOSE(U_AUX))	!!$  !     P = P + MATMUL(U_nn(index1)%U,TRANSPOSE(U_AUX))
!!$  !  END DO							!!$  !  END DO
!!$  !  !CALL WRITE_MATRIX(ABS(P))				!!$  !  !CALL WRITE_MATRIX(ABS(P))
!!$  !								!!$  !
!!$  !  P = 0.0							!!$  !  P = 0.0
!!$  !  DO index1  = 2*MULTIMODE_HARMONICS+1,MULTIMODE_HARMON	!!$  !  DO index1  = 2*MULTIMODE_HARMONICS+1,MULTIMODE_HARMON
!!$  !     P = P + MATMUL(U_nn(index1)%U,TRANSPOSE(U_AUX))	!!$  !     P = P + MATMUL(U_nn(index1)%U,TRANSPOSE(U_AUX))
!!$  !  END DO							!!$  !  END DO
!!$  !  !CALL WRITE_MATRIX(ABS(P))				!!$  !  !CALL WRITE_MATRIX(ABS(P))
!!$  !								!!$  !
!!$  !								!!$  !
!!$  !  P = 0.0							!!$  !  P = 0.0
!!$  !  DO index1  = 1,DRESSED_HARMONICS*MULTIMODE_HARMONICS	!!$  !  DO index1  = 1,DRESSED_HARMONICS*MULTIMODE_HARMONICS
!!$  !     P = P + MATMUL(U_nn(index1)%U,TRANSPOSE(U_AUX))	!!$  !     P = P + MATMUL(U_nn(index1)%U,TRANSPOSE(U_AUX))
!!$  !  END DO							!!$  !  END DO
!!$  !  !CALL WRITE_MATRIX(ABS(P))				!!$  !  !CALL WRITE_MATRIX(ABS(P))
!!$  !								!!$  !
!!$  !  P = 0.0							!!$  !  P = 0.0
!!$  !  P = MATMUL(U_AUX,TRANSPOSE(U_AUX))			!!$  !  P = MATMUL(U_AUX,TRANSPOSE(U_AUX))
!!$  !  !CALL WRITE_MATRIX(ABS(P))				!!$  !  !CALL WRITE_MATRIX(ABS(P))
!!$								!!$
!!$								!!$
!!$  ! as in 19.01.17 b.					!!$  ! as in 19.01.17 b.
!!$								!!$
!!$  !DO index1 = 1,DRESSED_HARMONICS*MULTIMODE_HARMONICS	!!$  !DO index1 = 1,DRESSED_HARMONICS*MULTIMODE_HARMONICS
!!$  !   U_nn2(index1)%U = abs(U_nn(index1)%U)**2		!!$  !   U_nn2(index1)%U = abs(U_nn(index1)%U)**2
!!$  !END DO							!!$  !END DO
!!$  !P = 0.0							!!$  !P = 0.0
!!$  !DO index1 = 1,DRESSED_HARMONICS*MULTIMODE_HARMONICS	!!$  !DO index1 = 1,DRESSED_HARMONICS*MULTIMODE_HARMONICS
!!$  !   DO index2 = 1,DRESSED_HARMONICS			!!$  !   DO index2 = 1,DRESSED_HARMONICS
!!$  !      INDEX3 = INDEX2 + (MULTIMODE_HARMONICS-1)/2		!!$  !      INDEX3 = INDEX2 + (MULTIMODE_HARMONICS-1)/2
!!$  !      P =  P + MATMUL(U_nn2(index1)%U,TRANSPOSE(CONJG(U	!!$  !      P =  P + MATMUL(U_nn2(index1)%U,TRANSPOSE(CONJG(U
!!$  !   END DO							!!$  !   END DO
!!$  !END DO							!!$  !END DO
!!$								!!$
!!$								!!$
!!$  !! as in 17.01.17 ! selecting a dressed manifold		!!$  !! as in 17.01.17 ! selecting a dressed manifold
!!$								!!$
!!$  !  ALLOCATE(U_n(DRESSED_HARMONICS))			!!$  !  ALLOCATE(U_n(DRESSED_HARMONICS))
!!$  !  ALLOCATE(U_MODES_n(MULTIMODE_HARMONICS))		!!$  !  ALLOCATE(U_MODES_n(MULTIMODE_HARMONICS))
!!$  !  ALLOCATE(U_nn(DRESSED_HARMONICS*MULTIMODE_HARMONICS))	!!$  !  ALLOCATE(U_nn(DRESSED_HARMONICS*MULTIMODE_HARMONICS))
!!$  !  ALLOCATE(U_nn2(DRESSED_HARMONICS*MULTIMODE_HARMONICS)	!!$  !  ALLOCATE(U_nn2(DRESSED_HARMONICS*MULTIMODE_HARMONICS)
!!$  !								!!$  !
!!$  !  DO n=1,DRESSED_HARMONICS				!!$  !  DO n=1,DRESSED_HARMONICS
!!$  !     ALLOCATE(U_n(n)%U(D_BARE,D_BARE))			!!$  !     ALLOCATE(U_n(n)%U(D_BARE,D_BARE))
!!$  !     U_n(n)%U = 0.0					!!$  !     U_n(n)%U = 0.0
!!$  !  END DO							!!$  !  END DO
!!$  !								!!$  !
!!$  !  D_AUX = D_BARE						!!$  !  D_AUX = D_BARE
!!$  !  DO n=1,MULTIMODE_HARMONICS				!!$  !  DO n=1,MULTIMODE_HARMONICS
!!$  !     ALLOCATE(U_MODES_n(n)%U(D_BARE,D_aux))		!!$  !     ALLOCATE(U_MODES_n(n)%U(D_BARE,D_aux))
!!$  !     U_MODES_n(n)%U = 0.0					!!$  !     U_MODES_n(n)%U = 0.0
!!$  !     ALLOCATE(U_MODES_n(n)%n(MODES_NUM))			!!$  !     ALLOCATE(U_MODES_n(n)%n(MODES_NUM))
!!$  !     U_MODES_n(n)%n = 0					!!$  !     U_MODES_n(n)%n = 0
!!$  !  END DO							!!$  !  END DO
!!$  !								!!$  !
!!$  !  DO n=1,DRESSED_HARMONICS*MULTIMODE_HARMONICS		!!$  !  DO n=1,DRESSED_HARMONICS*MULTIMODE_HARMONICS
!!$  !     ALLOCATE(U_nn(n)%U(D_BARE,D_AUX))			!!$  !     ALLOCATE(U_nn(n)%U(D_BARE,D_AUX))
!!$  !     U_nn(n)%U = 0.0					!!$  !     U_nn(n)%U = 0.0
!!$  !     ALLOCATE(U_nn2(n)%U(D_BARE,D_AUX))			!!$  !     ALLOCATE(U_nn2(n)%U(D_BARE,D_AUX))
!!$  !     U_nn2(n)%U = 0.0					!!$  !     U_nn2(n)%U = 0.0
!!$  !  END DO							!!$  !  END DO
!!$  !								!!$  !
!!$  !  DO i=0,MULTIMODE_HARMONICS-1				!!$  !  DO i=0,MULTIMODE_HARMONICS-1
!!$  !     U_MODES_n(i+1)%n = 0					!!$  !     U_MODES_n(i+1)%n = 0
!!$  !     index1 = i						!!$  !     index1 = i
!!$  !     DO j=2,MODES_NUM					!!$  !     DO j=2,MODES_NUM
!!$  !        U_MODES_n(i+1)%n(j)= -N_FLOQUET(j) + MOD(index1	!!$  !        U_MODES_n(i+1)%n(j)= -N_FLOQUET(j) + MOD(index1
!!$  !        index1 = INT(index1/(2*N_FLOQUET(j)+1))		!!$  !        index1 = INT(index1/(2*N_FLOQUET(j)+1))
!!$  !     END DO						!!$  !     END DO
!!$  !  END DO							!!$  !  END DO
!!$  !								!!$  !
!!$  !								!!$  !
!!$  !  i  = 1							!!$  !  i  = 1
!!$  !  DO index1=1,DRESSED_HARMONICS				!!$  !  DO index1=1,DRESSED_HARMONICS
!!$  !     i =1 + (index1-1)*D_BARE				!!$  !     i =1 + (index1-1)*D_BARE
!!$  !     index2 = D_BARE*N_FLOQUET(2)+2			!!$  !     index2 = D_BARE*N_FLOQUET(2)+2
!!$  !     U_n(index1)%U = U_F(i:i+D_BARE-1,index2:index2+D_B	!!$  !     U_n(index1)%U = U_F(i:i+D_BARE-1,index2:index2+D_B
!!$  !  END DO							!!$  !  END DO
!!$  !  i  = 1							!!$  !  i  = 1
!!$  !  DO index1=1,MULTIMODE_HARMONICS				!!$  !  DO index1=1,MULTIMODE_HARMONICS
!!$  !     i = 1 + (index1-1)*D_BARE				!!$  !     i = 1 + (index1-1)*D_BARE
!!$  !     !U_MODES_n(index1)%U = U_F_MODES(i:i+D_BARE-1,1:D)	!!$  !     !U_MODES_n(index1)%U = U_F_MODES(i:i+D_BARE-1,1:D)
!!$  !     index = MULTIMODE_HARMONICS*D_BARE/2.0 + D_BARE+1	!!$  !     index = MULTIMODE_HARMONICS*D_BARE/2.0 + D_BARE+1
!!$  !     U_MODES_n(index1)%U = U_F_MODES(i:i+D_BARE-1,index	!!$  !     U_MODES_n(index1)%U = U_F_MODES(i:i+D_BARE-1,index
!!$  !     if(index1.eq.5) then					!!$  !     if(index1.eq.5) then
!!$  !         P = U_MODES_n(index1)%U				!!$  !         P = U_MODES_n(index1)%U
!!$  !     end if						!!$  !     end if
!!$  !  END DO							!!$  !  END DO
!!$  !								!!$  !
!!$  !  index1 =1						!!$  !  index1 =1
!!$  !  DO n=1,DRESSED_HARMONICS				!!$  !  DO n=1,DRESSED_HARMONICS
!!$  !     DO m=1,MULTIMODE_HARMONICS				!!$  !     DO m=1,MULTIMODE_HARMONICS
!!$  !        U_nn(index1)%U  = MATMUL(TRANSPOSE(CONJG(U_n(n)	!!$  !        U_nn(index1)%U  = MATMUL(TRANSPOSE(CONJG(U_n(n)
!!$  !        !write(*,*) n,m,index1				!!$  !        !write(*,*) n,m,index1
!!$  !        index1 =  index1 + 1				!!$  !        index1 =  index1 + 1
!!$  !     END DO						!!$  !     END DO
!!$  !  END DO							!!$  !  END DO
!!$  !								!!$  !
!!$  !!17.01.17  expressions where the sums are over a single	!!$  !!17.01.17  expressions where the sums are over a single
!!$  !								!!$  !
!!$  !  DO index1 = 1,DRESSED_HARMONICS*MULTIMODE_HARMONICS	!!$  !  DO index1 = 1,DRESSED_HARMONICS*MULTIMODE_HARMONICS
!!$  !     U_nn2(index1)%U = ABS(U_nn(index1)%U)**2		!!$  !     U_nn2(index1)%U = ABS(U_nn(index1)%U)**2
!!$  !!    CALL WRITE_MATRIX(ABS(U_nn2(index1)%U))		!!$  !!    CALL WRITE_MATRIX(ABS(U_nn2(index1)%U))
!!$  !  END DO							!!$  !  END DO
!!$  !								!!$  !
!!$  !  P = 0.0							!!$  !  P = 0.0
!!$  !  DO index1 = 1,DRESSED_HARMONICS*MULTIMODE_HARMONICS	!!$  !  DO index1 = 1,DRESSED_HARMONICS*MULTIMODE_HARMONICS
!!$  !     DO index2 = 1,DRESSED_HARMONICS*MULTIMODE_HARMONIC	!!$  !     DO index2 = 1,DRESSED_HARMONICS*MULTIMODE_HARMONIC
!!$  !              P      = P+MATMUL(U_nn2(INDEX1)%U,TRANSPO	!!$  !              P      = P+MATMUL(U_nn2(INDEX1)%U,TRANSPO
!!$  ! !       CALL WRITE_MATRIX(REAL(P))			!!$  ! !       CALL WRITE_MATRIX(REAL(P))
!!$  !     END DO						!!$  !     END DO
!!$  !  END DO							!!$  !  END DO
!!$								!!$
!!$  !13.01.17  expressions where the sums are over a single 	!!$  !13.01.17  expressions where the sums are over a single 
!!$								!!$
!!$  !  DO index1 = 1,DRESSED_HARMONICS*MULTIMODE_HARMONICS	!!$  !  DO index1 = 1,DRESSED_HARMONICS*MULTIMODE_HARMONICS
!!$  !     U_nn2(index1)%U = MATMUL(U_nn(index1)%U,TRANSPOSE(	!!$  !     U_nn2(index1)%U = MATMUL(U_nn(index1)%U,TRANSPOSE(
!!$  !  END DO							!!$  !  END DO
!!$  !								!!$  !
!!$  !  P = 0.0							!!$  !  P = 0.0
!!$  !  aDO i=1,D_BARE						!!$  !  aDO i=1,D_BARE
!!$  !     DO j=1,D_BARE					!!$  !     DO j=1,D_BARE
!!$  !        DO index1 = 1,DRESSED_HARMONICS*MULTIMODE_HARMO	!!$  !        DO index1 = 1,DRESSED_HARMONICS*MULTIMODE_HARMO
!!$  !           DO index2 = 1,DRESSED_HARMONICS*MULTIMODE_HA	!!$  !           DO index2 = 1,DRESSED_HARMONICS*MULTIMODE_HA
!!$  !              P(i,j) = P(i,j) + U_nn2(index1)%U(j,j)*U_	!!$  !              P(i,j) = P(i,j) + U_nn2(index1)%U(j,j)*U_
!!$  !           END DO						!!$  !           END DO
!!$  !        END DO						!!$  !        END DO
!!$  !     END DO						!!$  !     END DO
!!$  !  END DO							!!$  !  END DO
!!$  !								!!$  !
!!$								!!$
!!$								!!$
!!$END SUBROUTINE MULTIMODETRANSITIONPROBABILITY_DRESSEDBASIS	!!$END SUBROUTINE MULTIMODETRANSITIONPROBABILITY_DRESSEDBASIS
!!$								!!$

diff -y ./src/MultimodeTransitionAVG.f90 ../../Downloads/MultimodeFloquet-0.3/src/MultimodeTransitionAVG.f90
SUBROUTINE MULTIMODETRANSITIONAVG(D,NM,FIELD,MODES_NUM,U_F_MO	SUBROUTINE MULTIMODETRANSITIONAVG(D,NM,FIELD,MODES_NUM,U_F_MO
!!$   AVERAGE TIME EVOLUTION OPERATOR OF A MULTIMODE DRESSED 	!!$   AVERAGE TIME EVOLUTION OPERATOR OF A MULTIMODE DRESSED 
!!$   MULTIMODE FLOQUET HAMILTONIAN				!!$   MULTIMODE FLOQUET HAMILTONIAN
!!$   U : MATRIX OF AVERAGE TRANSITION PROBABILITIES		!!$   U : MATRIX OF AVERAGE TRANSITION PROBABILITIES
!!$								!!$
!!$  D              (IN)   : DIMENSION OF THE EXTENDED HILBER	!!$  D              (IN)   : DIMENSION OF THE EXTENDED HILBER
!!$  NM             (IN)   : NUMBER OF MODES            	!!$  NM             (IN)   : NUMBER OF MODES            
!!$  MODES_NUM      (IN)   : VECTOR (NM) INDICATING THE NUMBE	!!$  MODES_NUM      (IN)   : VECTOR (NM) INDICATING THE NUMBE
!!$  U_F_MODES      (IN)   : TRANSFORMATION, DIMENSOON (D,D) 	!!$  U_F_MODES      (IN)   : TRANSFORMATION, DIMENSOON (D,D) 
!!$  E_MULTIFLOQUET (IN)   : MULTIMODE FLOQUET SPECTRUM		!!$  E_MULTIFLOQUET (IN)   : MULTIMODE FLOQUET SPECTRUM
!!$  D_BARE         (IN)   : DIMENSION OF THE BARE HILBERT SP	!!$  D_BARE         (IN)   : DIMENSION OF THE BARE HILBERT SP
!!$  U              (OUT)  :  MATRIX OF AVERAGE TRANSITION PR	!!$  U              (OUT)  :  MATRIX OF AVERAGE TRANSITION PR
!!$  INFO           (INOUT): (POSSIBLE) ERROR FLAG		!!$  INFO           (INOUT): (POSSIBLE) ERROR FLAG

  USE TYPES							  USE TYPES

  IMPLICIT NONE							  IMPLICIT NONE
  TYPE(MODE),DIMENSION(NM), INTENT(IN)     :: FIELD		  TYPE(MODE),DIMENSION(NM), INTENT(IN)     :: FIELD
  INTEGER,   DIMENSION(NM), INTENT(IN)     :: MODES_NUM		  INTEGER,   DIMENSION(NM), INTENT(IN)     :: MODES_NUM

  INTEGER,                                    INTENT(IN)    :	  INTEGER,                                    INTENT(IN)    :
  INTEGER,                                    INTENT(INOUT) :	  INTEGER,                                    INTENT(INOUT) :
  DOUBLE PRECISION, DIMENSION(D),             INTENT(IN)    :	  DOUBLE PRECISION, DIMENSION(D),             INTENT(IN)    :
  COMPLEX*16,       DIMENSION(D,D),           INTENT(IN)    :	  COMPLEX*16,       DIMENSION(D,D),           INTENT(IN)    :
  DOUBLE PRECISION, DIMENSION(D_BARE,D_BARE), INTENT(OUT)   :	  DOUBLE PRECISION, DIMENSION(D_BARE,D_BARE), INTENT(OUT)   :

  COMPLEX*16, DIMENSION(D,D) :: U_DIAGONAL			  COMPLEX*16, DIMENSION(D,D) :: U_DIAGONAL
  COMPLEX*16, DIMENSION(D_BARE,D) :: U_AUX			  COMPLEX*16, DIMENSION(D_BARE,D) :: U_AUX

  INTEGER :: MULTIMODE_HARMONICS, n,i,j,m,index0,index1,field	  INTEGER :: MULTIMODE_HARMONICS, n,i,j,m,index0,index1,field
  INTEGER, DIMENSION(NM) :: N_FLOQUET				  INTEGER, DIMENSION(NM) :: N_FLOQUET
  DOUBLE PRECISION, DIMENSION(NM) :: OMEGA_VEC			  DOUBLE PRECISION, DIMENSION(NM) :: OMEGA_VEC
  TYPE(HARMONIC_FACTORS), DIMENSION(:),ALLOCATABLE:: U_MODES_	  TYPE(HARMONIC_FACTORS), DIMENSION(:),ALLOCATABLE:: U_MODES_
  DOUBLE PRECISION :: PHASE					  DOUBLE PRECISION :: PHASE

  MULTIMODE_HARMONICS   = D/D_BARE				  MULTIMODE_HARMONICS   = D/D_BARE
  OMEGA_VEC  = 0.0						  OMEGA_VEC  = 0.0
  U_DIAGONAL = 0.0						  U_DIAGONAL = 0.0
  U_AUX      = 0.0						  U_AUX      = 0.0
  PHASE      = 0.0						  PHASE      = 0.0
  U          = 0.0						  U          = 0.0

  DO n=2,NM							  DO n=2,NM
     FIELD_INDEX = 2+SUM(MODES_NUM(2:n-1))			     FIELD_INDEX = 2+SUM(MODES_NUM(2:n-1))
     N_FLOQUET(n)=FIELD(FIELD_INDEX)%N_Floquet			     N_FLOQUET(n)=FIELD(FIELD_INDEX)%N_Floquet
!     write(*,*) n,N_FLOQUET(n),field_index,modes_num(n)	!     write(*,*) n,N_FLOQUET(n),field_index,modes_num(n)
     IF(modes_num(n).GT.N_FLOQUET(n)+1) THEN			     IF(modes_num(n).GT.N_FLOQUET(n)+1) THEN
        WRITE(*,*) "TO BUILD THE EXTENDED HAMILTONIAN THE NUM	        WRITE(*,*) "TO BUILD THE EXTENDED HAMILTONIAN THE NUM
        WRITE(*,*) "LARGER THAN THE NUMBER OF FIELD MODES"	        WRITE(*,*) "LARGER THAN THE NUMBER OF FIELD MODES"
        INFO = -10						        INFO = -10
     END IF							     END IF
  END DO							  END DO

  ALLOCATE(U_MODES_n(MULTIMODE_HARMONICS))			  ALLOCATE(U_MODES_n(MULTIMODE_HARMONICS))

  DO n=1,MULTIMODE_HARMONICS					  DO n=1,MULTIMODE_HARMONICS
     ALLOCATE(U_MODES_n(n)%U(D_BARE,D))				     ALLOCATE(U_MODES_n(n)%U(D_BARE,D))
     U_MODES_n(n)%U = 0.0					     U_MODES_n(n)%U = 0.0
     ALLOCATE(U_MODES_n(n)%n(NM))				     ALLOCATE(U_MODES_n(n)%n(NM))
     U_MODES_n(n)%n = 0.0					     U_MODES_n(n)%n = 0.0
  END DO							  END DO

  DO i=0,MULTIMODE_HARMONICS-1					  DO i=0,MULTIMODE_HARMONICS-1
     U_MODES_n(i+1)%n = 0					     U_MODES_n(i+1)%n = 0
     index0 = i							     index0 = i
     DO j=2,NM							     DO j=2,NM
        U_MODES_n(i+1)%n(j)= -N_FLOQUET(j) + MOD(index0,(2*N_	        U_MODES_n(i+1)%n(j)= -N_FLOQUET(j) + MOD(index0,(2*N_
        index0 = INT(index0/(2*N_FLOQUET(j)+1))			        index0 = INT(index0/(2*N_FLOQUET(j)+1))
     END DO							     END DO
!     write(*,*) i+1,U_MODES_n(i+1)%n				!     write(*,*) i+1,U_MODES_n(i+1)%n
  END DO							  END DO

  i  = 1							  i  = 1
  DO index1=1,MULTIMODE_HARMONICS				  DO index1=1,MULTIMODE_HARMONICS
     DO n=1,D							     DO n=1,D
        j = n							        j = n
        i = 1 + (index1-1)*D_BARE				        i = 1 + (index1-1)*D_BARE
        DO m=1,D_BARE						        DO m=1,D_BARE
           U_MODES_n(index1)%U(m,n) = U_F_MODES(i,j)		           U_MODES_n(index1)%U(m,n) = U_F_MODES(i,j)
           i = i + 1						           i = i + 1
        END DO							        END DO
     END DO							     END DO
  END DO							  END DO

  index0 = (MULTIMODE_HARMONICS -1)/2 + 1			  index0 = (MULTIMODE_HARMONICS -1)/2 + 1
  U_AUX  =  U_MODES_n(index0)%U					  U_AUX  =  U_MODES_n(index0)%U
  U = 0.0							  U = 0.0
  DO index1=1,MULTIMODE_HARMONICS				  DO index1=1,MULTIMODE_HARMONICS
     U = U +  MATMUL(ABS(U_AUX)**2,ABS(TRANSPOSE(CONJG(U_MODE	     U = U +  MATMUL(ABS(U_AUX)**2,ABS(TRANSPOSE(CONJG(U_MODE
  END DO							  END DO

  info = 0							  info = 0

END SUBROUTINE MULTIMODETRANSITIONAVG				END SUBROUTINE MULTIMODETRANSITIONAVG


!!$SUBROUTINE MULTIMODETRANSITIONPROBABILITY_DRESSEDBASIS(D_F	!!$SUBROUTINE MULTIMODETRANSITIONPROBABILITY_DRESSEDBASIS(D_F
!!$     & D_BARE,P,P2,INFO)					!!$     & D_BARE,P,P2,INFO)
!!$								!!$
!!$  !D                : dimension of the multimode hilbert s	!!$  !D                : dimension of the multimode hilbert s
!!$  !D_F              : dimension of the dressed hilbert spa	!!$  !D_F              : dimension of the dressed hilbert spa
!!$  !U_F_MODES        : D x D matrix transformation to the m	!!$  !U_F_MODES        : D x D matrix transformation to the m
!!$  !U_F              : D_F x D_F matrix transformation to t	!!$  !U_F              : D_F x D_F matrix transformation to t
!!$  !E_DRESSED        : single mode eigenvalues == dressed e	!!$  !E_DRESSED        : single mode eigenvalues == dressed e
!!$  !E_MULTIFLOQUET   : multimode eigenvalues			!!$  !E_MULTIFLOQUET   : multimode eigenvalues
!!$  !D_BARE           : dimension of the bare hilbert space	!!$  !D_BARE           : dimension of the bare hilbert space
!!$  !P                : matrix of Time and phase average tra	!!$  !P                : matrix of Time and phase average tra
!!$  !INFO             : for info				!!$  !INFO             : for info
!!$								!!$
!!$  ! The dressed basis is not always well defined.		!!$  ! The dressed basis is not always well defined.
!!$  !Time average transition probability			!!$  !Time average transition probability
!!$								!!$
!!$  USE SUBINTERFACE_LAPACK					!!$  USE SUBINTERFACE_LAPACK
!!$!  USE FLOQUET						!!$!  USE FLOQUET
!!$  USE TYPES							!!$  USE TYPES
!!$								!!$
!!$  IMPLICIT NONE						!!$  IMPLICIT NONE
!!$  INTEGER,                                    INTENT(IN)  	!!$  INTEGER,                                    INTENT(IN)  
!!$  COMPLEX*16,       DIMENSION(D_F,D_F),       INTENT(INOUT	!!$  COMPLEX*16,       DIMENSION(D_F,D_F),       INTENT(INOUT
!!$  COMPLEX*16,       DIMENSION(D,D),           INTENT(INOUT	!!$  COMPLEX*16,       DIMENSION(D,D),           INTENT(INOUT
!!$  DOUBLE PRECISION, DIMENSION(D_F),           INTENT(IN)  	!!$  DOUBLE PRECISION, DIMENSION(D_F),           INTENT(IN)  
!!$  DOUBLE PRECISION, DIMENSION(D),             INTENT(IN)  	!!$  DOUBLE PRECISION, DIMENSION(D),             INTENT(IN)  
!!$  !  COMPLEX*16,       DIMENSION(D_Bare,D_Bare),       INT	!!$  !  COMPLEX*16,       DIMENSION(D_Bare,D_Bare),       INT
!!$  COMPLEX*16,       DIMENSION(D_F,D_F),       INTENT(OUT) 	!!$  COMPLEX*16,       DIMENSION(D_F,D_F),       INTENT(OUT) 
!!$								!!$
!!$  INTEGER,                                    INTENT(INOUT	!!$  INTEGER,                                    INTENT(INOUT
!!$								!!$
!!$								!!$
!!$  TYPE(HARMONIC_FACTORS), DIMENSION(:),ALLOCATABLE :: U_n,	!!$  TYPE(HARMONIC_FACTORS), DIMENSION(:),ALLOCATABLE :: U_n,
!!$  COMPLEX*16, DIMENSION(D,D)       :: U_AUX_F ! TEMPORAL V	!!$  COMPLEX*16, DIMENSION(D,D)       :: U_AUX_F ! TEMPORAL V
!!$  !COMPLEX*16, DIMENSION(D_F,D_F)  :: U_AUX			!!$  !COMPLEX*16, DIMENSION(D_F,D_F)  :: U_AUX
!!$  COMPLEX*16, DIMENSION(D_F,D)     :: U_AUX			!!$  COMPLEX*16, DIMENSION(D_F,D)     :: U_AUX
!!$  COMPLEX*16, DIMENSION(D,D_F)     :: U_AUX_2		!!$  COMPLEX*16, DIMENSION(D,D_F)     :: U_AUX_2
!!$								!!$
!!$  DOUBLE PRECISION, DIMENSION(D)   :: PHASE_CONVENTION_MOD	!!$  DOUBLE PRECISION, DIMENSION(D)   :: PHASE_CONVENTION_MOD
!!$  DOUBLE PRECISION, DIMENSION(D_F) :: PHASE_CONVENTION_SIN	!!$  DOUBLE PRECISION, DIMENSION(D_F) :: PHASE_CONVENTION_SIN
!!$								!!$
!!$  INTEGER n,m,index1,index2,i,j,index,index_,index3,index0	!!$  INTEGER n,m,index1,index2,i,j,index,index_,index3,index0
!!$  INTEGER DRESSED_HARMONICS, MULTIMODE_HARMONICS,D_AUX	!!$  INTEGER DRESSED_HARMONICS, MULTIMODE_HARMONICS,D_AUX
!!$								!!$
!!$  INTEGER :: a,c,e,g,k,k_,n_,lambda,l,l_			!!$  INTEGER :: a,c,e,g,k,k_,n_,lambda,l,l_
!!$								!!$
!!$  DRESSED_HARMONICS   = D_F/D_BARE				!!$  DRESSED_HARMONICS   = D_F/D_BARE
!!$  MULTIMODE_HARMONICS =   D/D_BARE				!!$  MULTIMODE_HARMONICS =   D/D_BARE
!!$								!!$
!!$  ALLOCATE(U_n(DRESSED_HARMONICS))				!!$  ALLOCATE(U_n(DRESSED_HARMONICS))
!!$  ALLOCATE(U_MODES_n(MULTIMODE_HARMONICS))			!!$  ALLOCATE(U_MODES_n(MULTIMODE_HARMONICS))
!!$  ALLOCATE(U_nn(DRESSED_HARMONICS*MULTIMODE_HARMONICS))	!!$  ALLOCATE(U_nn(DRESSED_HARMONICS*MULTIMODE_HARMONICS))
!!$  ALLOCATE(U_nn2(DRESSED_HARMONICS*MULTIMODE_HARMONICS))	!!$  ALLOCATE(U_nn2(DRESSED_HARMONICS*MULTIMODE_HARMONICS))
!!$								!!$
!!$  DO n=1,DRESSED_HARMONICS					!!$  DO n=1,DRESSED_HARMONICS
!!$     ALLOCATE(U_n(n)%U(D_BARE,D_F))   ! All singlemode dre	!!$     ALLOCATE(U_n(n)%U(D_BARE,D_F))   ! All singlemode dre
!!$     !ALLOCATE(U_n(n)%U(D_BARE,D_BARE)) ! Select a manifol	!!$     !ALLOCATE(U_n(n)%U(D_BARE,D_BARE)) ! Select a manifol
!!$     U_n(n)%U = 0.0						!!$     U_n(n)%U = 0.0
!!$  END DO							!!$  END DO
!!$								!!$
!!$  DO n=1,MULTIMODE_HARMONICS					!!$  DO n=1,MULTIMODE_HARMONICS
!!$     ALLOCATE(U_MODES_n(n)%U(D_BARE,D)) !Full set of multi	!!$     ALLOCATE(U_MODES_n(n)%U(D_BARE,D)) !Full set of multi
!!$     !ALLOCATE(U_MODES_n(n)%U(D_BARE,D_BARE)) !Single out 	!!$     !ALLOCATE(U_MODES_n(n)%U(D_BARE,D_BARE)) !Single out 
!!$     U_MODES_n(n)%U = 0.0					!!$     U_MODES_n(n)%U = 0.0
!!$     ALLOCATE(U_MODES_n(n)%n(MODES_NUM))			!!$     ALLOCATE(U_MODES_n(n)%n(MODES_NUM))
!!$     U_MODES_n(n)%n = 0					!!$     U_MODES_n(n)%n = 0
!!$  END DO							!!$  END DO
!!$								!!$
!!$  DO n=1,DRESSED_HARMONICS*MULTIMODE_HARMONICS		!!$  DO n=1,DRESSED_HARMONICS*MULTIMODE_HARMONICS
!!$     !ALLOCATE(U_nn(n)%U(D_F,D_BARE))			!!$     !ALLOCATE(U_nn(n)%U(D_F,D_BARE))
!!$     !U_nn(n)%U = 0.0					!!$     !U_nn(n)%U = 0.0
!!$     !ALLOCATE(U_nn2(n)%U(D_F,D_BARE))			!!$     !ALLOCATE(U_nn2(n)%U(D_F,D_BARE))
!!$     !U_nn2(n)%U = 0.0					!!$     !U_nn2(n)%U = 0.0
!!$     ALLOCATE(U_nn(n)%U(D_F,D))				!!$     ALLOCATE(U_nn(n)%U(D_F,D))
!!$     U_nn(n)%U = 0.0						!!$     U_nn(n)%U = 0.0
!!$     ALLOCATE(U_nn2(n)%U(D_F,D))				!!$     ALLOCATE(U_nn2(n)%U(D_F,D))
!!$     U_nn2(n)%U = 0.0					!!$     U_nn2(n)%U = 0.0
!!$  END DO							!!$  END DO
!!$  i  = 1							!!$  i  = 1
!!$  DO index1=1,DRESSED_HARMONICS				!!$  DO index1=1,DRESSED_HARMONICS
!!$     i = 1 + (index1-1)*D_BARE				!!$     i = 1 + (index1-1)*D_BARE
!!$     U_n(index1)%U = U_F(i:i+D_BARE-1,1:D_F)			!!$     U_n(index1)%U = U_F(i:i+D_BARE-1,1:D_F)
!!$     !index2 = D_BARE*N_FLOQUET(2)+1				!!$     !index2 = D_BARE*N_FLOQUET(2)+1
!!$     !U_n(index1)%U = U_F(i:i+D_BARE-1,index2:index2+D_BAR	!!$     !U_n(index1)%U = U_F(i:i+D_BARE-1,index2:index2+D_BAR
!!$     !call write_matrix(ABS(U_n(index1)%U))			!!$     !call write_matrix(ABS(U_n(index1)%U))
!!$     !							!!$     !
!!$  END DO							!!$  END DO
!!$								!!$
!!$								!!$
!!$  DO i=0,MULTIMODE_HARMONICS-1				!!$  DO i=0,MULTIMODE_HARMONICS-1
!!$     U_MODES_n(i+1)%n = 0					!!$     U_MODES_n(i+1)%n = 0
!!$     index1 = i						!!$     index1 = i
!!$     DO j=2,MODES_NUM					!!$     DO j=2,MODES_NUM
!!$        U_MODES_n(i+1)%n(j)= -N_FLOQUET(j) + MOD(index1,(2	!!$        U_MODES_n(i+1)%n(j)= -N_FLOQUET(j) + MOD(index1,(2
!!$        index1 = INT(index1/(2*N_FLOQUET(j)+1))		!!$        index1 = INT(index1/(2*N_FLOQUET(j)+1))
!!$     END DO							!!$     END DO
!!$  END DO							!!$  END DO
!!$								!!$
!!$  i  = 1							!!$  i  = 1
!!$  DO index1=1,MULTIMODE_HARMONICS				!!$  DO index1=1,MULTIMODE_HARMONICS
!!$     i = 1 + (index1-1)*D_BARE				!!$     i = 1 + (index1-1)*D_BARE
!!$     U_MODES_n(index1)%U = U_F_MODES(i:i+D_BARE-1,1:D)	!!$     U_MODES_n(index1)%U = U_F_MODES(i:i+D_BARE-1,1:D)
!!$     !WRITE(*,*) INDEX1,U_MODES_n(index1)%n			!!$     !WRITE(*,*) INDEX1,U_MODES_n(index1)%n
!!$     !call write_matrix(ABS(U_MODES_n(index1)%U))		!!$     !call write_matrix(ABS(U_MODES_n(index1)%U))
!!$								!!$
!!$     !index3 = MULTIMODE_HARMONICS*D_BARE/2.0 -1		!!$     !index3 = MULTIMODE_HARMONICS*D_BARE/2.0 -1
!!$     !     !U_MODES_n(index1)%U = U_F_MODES(i:i+D_BARE-1,i	!!$     !     !U_MODES_n(index1)%U = U_F_MODES(i:i+D_BARE-1,i
!!$  END DO							!!$  END DO
!!$								!!$
!!$  index1 =1							!!$  index1 =1
!!$  DO n=1,DRESSED_HARMONICS					!!$  DO n=1,DRESSED_HARMONICS
!!$     DO m=1,MULTIMODE_HARMONICS				!!$     DO m=1,MULTIMODE_HARMONICS
!!$        U_nn(index1)%U  = ABS(MATMUL(TRANSPOSE(CONJG(U_n(n	!!$        U_nn(index1)%U  = ABS(MATMUL(TRANSPOSE(CONJG(U_n(n
!!$        !      CALL WRITE_MATRIX(ABS(U_n(n)%U))		!!$        !      CALL WRITE_MATRIX(ABS(U_n(n)%U))
!!$        !      CALL WRITE_MATRIX(ABS(U_MODES_n(m)%U))	!!$        !      CALL WRITE_MATRIX(ABS(U_MODES_n(m)%U))
!!$        !      CALL WRITE_MATRIX(ABS(U_nn(index1)%U))	!!$        !      CALL WRITE_MATRIX(ABS(U_nn(index1)%U))
!!$        index1 =  index1 + 1					!!$        index1 =  index1 + 1
!!$     END DO							!!$     END DO
!!$  END DO							!!$  END DO
!!$								!!$
!!$  !P = ABS(MATMUL(TRANSPOSE(CONJG(U_F)),U_F_MODES))**2	!!$  !P = ABS(MATMUL(TRANSPOSE(CONJG(U_F)),U_F_MODES))**2
!!$  !P = MATMUL(P,TRANSPOSE(CONJG(P)))				!!$  !P = MATMUL(P,TRANSPOSE(CONJG(P)))
!!$  !								!!$  !
!!$  INDEX0 = (DRESSED_HARMONICS -1)/2 + 1			!!$  INDEX0 = (DRESSED_HARMONICS -1)/2 + 1
!!$  INDEX1 = (MULTIMODE_HARMONICS -1)/2 + 1			!!$  INDEX1 = (MULTIMODE_HARMONICS -1)/2 + 1
!!$  !write(*,*) '#',index0,index1				!!$  !write(*,*) '#',index0,index1
!!$								!!$
!!$  U_AUX = ABS(MATMUL(TRANSPOSE(CONJG(U_n(INDEX0)%U)),U_MOD	!!$  U_AUX = ABS(MATMUL(TRANSPOSE(CONJG(U_n(INDEX0)%U)),U_MOD
!!$								!!$
!!$  !as in 10.10.17						!!$  !as in 10.10.17
!!$  P = 0.0							!!$  P = 0.0
!!$  DO index1  = 1,DRESSED_HARMONICS*MULTIMODE_HARMONICS!,MU	!!$  DO index1  = 1,DRESSED_HARMONICS*MULTIMODE_HARMONICS!,MU
!!$     !write(*,*) size(U_aux,1),size(U_aux,2),size(u_nn(ind	!!$     !write(*,*) size(U_aux,1),size(U_aux,2),size(u_nn(ind
!!$     !P = P + MATMUL(U_AUX,transpose(conjg(U_nn(index1)%U)	!!$     !P = P + MATMUL(U_AUX,transpose(conjg(U_nn(index1)%U)
!!$     P = P + MATMUL(U_nn(index1)%U,TRANSPOSE(U_AUX))		!!$     P = P + MATMUL(U_nn(index1)%U,TRANSPOSE(U_AUX))
!!$     !P = P + MATMUL(U_AUX,TRANSPOSE(U_AUX))			!!$     !P = P + MATMUL(U_AUX,TRANSPOSE(U_AUX))
!!$  END DO							!!$  END DO
!!$								!!$
!!$								!!$
!!$  !  write(*,*) real(P(4,4)),real(P(4,5)),real(P(5,5))	!!$  !  write(*,*) real(P(4,4)),real(P(4,5)),real(P(5,5))
!!$  !  P = 0.0							!!$  !  P = 0.0
!!$  !  DO index1  = MULTIMODE_HARMONICS+1,MULTIMODE_HARMONIC	!!$  !  DO index1  = MULTIMODE_HARMONICS+1,MULTIMODE_HARMONIC
!!$  !     P = P + MATMUL(U_nn(index1)%U,TRANSPOSE(U_AUX))	!!$  !     P = P + MATMUL(U_nn(index1)%U,TRANSPOSE(U_AUX))
!!$  !  END DO							!!$  !  END DO
!!$  !  !CALL WRITE_MATRIX(ABS(P))				!!$  !  !CALL WRITE_MATRIX(ABS(P))
!!$  !								!!$  !
!!$  !  P = 0.0							!!$  !  P = 0.0
!!$  !  DO index1  = 2*MULTIMODE_HARMONICS+1,MULTIMODE_HARMON	!!$  !  DO index1  = 2*MULTIMODE_HARMONICS+1,MULTIMODE_HARMON
!!$  !     P = P + MATMUL(U_nn(index1)%U,TRANSPOSE(U_AUX))	!!$  !     P = P + MATMUL(U_nn(index1)%U,TRANSPOSE(U_AUX))
!!$  !  END DO							!!$  !  END DO
!!$  !  !CALL WRITE_MATRIX(ABS(P))				!!$  !  !CALL WRITE_MATRIX(ABS(P))
!!$  !								!!$  !
!!$  !								!!$  !
!!$  !  P = 0.0							!!$  !  P = 0.0
!!$  !  DO index1  = 1,DRESSED_HARMONICS*MULTIMODE_HARMONICS	!!$  !  DO index1  = 1,DRESSED_HARMONICS*MULTIMODE_HARMONICS
!!$  !     P = P + MATMUL(U_nn(index1)%U,TRANSPOSE(U_AUX))	!!$  !     P = P + MATMUL(U_nn(index1)%U,TRANSPOSE(U_AUX))
!!$  !  END DO							!!$  !  END DO
!!$  !  !CALL WRITE_MATRIX(ABS(P))				!!$  !  !CALL WRITE_MATRIX(ABS(P))
!!$  !								!!$  !
!!$  !  P = 0.0							!!$  !  P = 0.0
!!$  !  P = MATMUL(U_AUX,TRANSPOSE(U_AUX))			!!$  !  P = MATMUL(U_AUX,TRANSPOSE(U_AUX))
!!$  !  !CALL WRITE_MATRIX(ABS(P))				!!$  !  !CALL WRITE_MATRIX(ABS(P))
!!$								!!$
!!$								!!$
!!$  ! as in 19.01.17 b.					!!$  ! as in 19.01.17 b.
!!$								!!$
!!$  !DO index1 = 1,DRESSED_HARMONICS*MULTIMODE_HARMONICS	!!$  !DO index1 = 1,DRESSED_HARMONICS*MULTIMODE_HARMONICS
!!$  !   U_nn2(index1)%U = abs(U_nn(index1)%U)**2		!!$  !   U_nn2(index1)%U = abs(U_nn(index1)%U)**2
!!$  !END DO							!!$  !END DO
!!$  !P = 0.0							!!$  !P = 0.0
!!$  !DO index1 = 1,DRESSED_HARMONICS*MULTIMODE_HARMONICS	!!$  !DO index1 = 1,DRESSED_HARMONICS*MULTIMODE_HARMONICS
!!$  !   DO index2 = 1,DRESSED_HARMONICS			!!$  !   DO index2 = 1,DRESSED_HARMONICS
!!$  !      INDEX3 = INDEX2 + (MULTIMODE_HARMONICS-1)/2		!!$  !      INDEX3 = INDEX2 + (MULTIMODE_HARMONICS-1)/2
!!$  !      P =  P + MATMUL(U_nn2(index1)%U,TRANSPOSE(CONJG(U	!!$  !      P =  P + MATMUL(U_nn2(index1)%U,TRANSPOSE(CONJG(U
!!$  !   END DO							!!$  !   END DO
!!$  !END DO							!!$  !END DO
!!$								!!$
!!$								!!$
!!$  !! as in 17.01.17 ! selecting a dressed manifold		!!$  !! as in 17.01.17 ! selecting a dressed manifold
!!$								!!$
!!$  !  ALLOCATE(U_n(DRESSED_HARMONICS))			!!$  !  ALLOCATE(U_n(DRESSED_HARMONICS))
!!$  !  ALLOCATE(U_MODES_n(MULTIMODE_HARMONICS))		!!$  !  ALLOCATE(U_MODES_n(MULTIMODE_HARMONICS))
!!$  !  ALLOCATE(U_nn(DRESSED_HARMONICS*MULTIMODE_HARMONICS))	!!$  !  ALLOCATE(U_nn(DRESSED_HARMONICS*MULTIMODE_HARMONICS))
!!$  !  ALLOCATE(U_nn2(DRESSED_HARMONICS*MULTIMODE_HARMONICS)	!!$  !  ALLOCATE(U_nn2(DRESSED_HARMONICS*MULTIMODE_HARMONICS)
!!$  !								!!$  !
!!$  !  DO n=1,DRESSED_HARMONICS				!!$  !  DO n=1,DRESSED_HARMONICS
!!$  !     ALLOCATE(U_n(n)%U(D_BARE,D_BARE))			!!$  !     ALLOCATE(U_n(n)%U(D_BARE,D_BARE))
!!$  !     U_n(n)%U = 0.0					!!$  !     U_n(n)%U = 0.0
!!$  !  END DO							!!$  !  END DO
!!$  !								!!$  !
!!$  !  D_AUX = D_BARE						!!$  !  D_AUX = D_BARE
!!$  !  DO n=1,MULTIMODE_HARMONICS				!!$  !  DO n=1,MULTIMODE_HARMONICS
!!$  !     ALLOCATE(U_MODES_n(n)%U(D_BARE,D_aux))		!!$  !     ALLOCATE(U_MODES_n(n)%U(D_BARE,D_aux))
!!$  !     U_MODES_n(n)%U = 0.0					!!$  !     U_MODES_n(n)%U = 0.0
!!$  !     ALLOCATE(U_MODES_n(n)%n(MODES_NUM))			!!$  !     ALLOCATE(U_MODES_n(n)%n(MODES_NUM))
!!$  !     U_MODES_n(n)%n = 0					!!$  !     U_MODES_n(n)%n = 0
!!$  !  END DO							!!$  !  END DO
!!$  !								!!$  !
!!$  !  DO n=1,DRESSED_HARMONICS*MULTIMODE_HARMONICS		!!$  !  DO n=1,DRESSED_HARMONICS*MULTIMODE_HARMONICS
!!$  !     ALLOCATE(U_nn(n)%U(D_BARE,D_AUX))			!!$  !     ALLOCATE(U_nn(n)%U(D_BARE,D_AUX))
!!$  !     U_nn(n)%U = 0.0					!!$  !     U_nn(n)%U = 0.0
!!$  !     ALLOCATE(U_nn2(n)%U(D_BARE,D_AUX))			!!$  !     ALLOCATE(U_nn2(n)%U(D_BARE,D_AUX))
!!$  !     U_nn2(n)%U = 0.0					!!$  !     U_nn2(n)%U = 0.0
!!$  !  END DO							!!$  !  END DO
!!$  !								!!$  !
!!$  !  DO i=0,MULTIMODE_HARMONICS-1				!!$  !  DO i=0,MULTIMODE_HARMONICS-1
!!$  !     U_MODES_n(i+1)%n = 0					!!$  !     U_MODES_n(i+1)%n = 0
!!$  !     index1 = i						!!$  !     index1 = i
!!$  !     DO j=2,MODES_NUM					!!$  !     DO j=2,MODES_NUM
!!$  !        U_MODES_n(i+1)%n(j)= -N_FLOQUET(j) + MOD(index1	!!$  !        U_MODES_n(i+1)%n(j)= -N_FLOQUET(j) + MOD(index1
!!$  !        index1 = INT(index1/(2*N_FLOQUET(j)+1))		!!$  !        index1 = INT(index1/(2*N_FLOQUET(j)+1))
!!$  !     END DO						!!$  !     END DO
!!$  !  END DO							!!$  !  END DO
!!$  !								!!$  !
!!$  !								!!$  !
!!$  !  i  = 1							!!$  !  i  = 1
!!$  !  DO index1=1,DRESSED_HARMONICS				!!$  !  DO index1=1,DRESSED_HARMONICS
!!$  !     i =1 + (index1-1)*D_BARE				!!$  !     i =1 + (index1-1)*D_BARE
!!$  !     index2 = D_BARE*N_FLOQUET(2)+2			!!$  !     index2 = D_BARE*N_FLOQUET(2)+2
!!$  !     U_n(index1)%U = U_F(i:i+D_BARE-1,index2:index2+D_B	!!$  !     U_n(index1)%U = U_F(i:i+D_BARE-1,index2:index2+D_B
!!$  !  END DO							!!$  !  END DO
!!$  !  i  = 1							!!$  !  i  = 1
!!$  !  DO index1=1,MULTIMODE_HARMONICS				!!$  !  DO index1=1,MULTIMODE_HARMONICS
!!$  !     i = 1 + (index1-1)*D_BARE				!!$  !     i = 1 + (index1-1)*D_BARE
!!$  !     !U_MODES_n(index1)%U = U_F_MODES(i:i+D_BARE-1,1:D)	!!$  !     !U_MODES_n(index1)%U = U_F_MODES(i:i+D_BARE-1,1:D)
!!$  !     index = MULTIMODE_HARMONICS*D_BARE/2.0 + D_BARE+1	!!$  !     index = MULTIMODE_HARMONICS*D_BARE/2.0 + D_BARE+1
!!$  !     U_MODES_n(index1)%U = U_F_MODES(i:i+D_BARE-1,index	!!$  !     U_MODES_n(index1)%U = U_F_MODES(i:i+D_BARE-1,index
!!$  !     if(index1.eq.5) then					!!$  !     if(index1.eq.5) then
!!$  !         P = U_MODES_n(index1)%U				!!$  !         P = U_MODES_n(index1)%U
!!$  !     end if						!!$  !     end if
!!$  !  END DO							!!$  !  END DO
!!$  !								!!$  !
!!$  !  index1 =1						!!$  !  index1 =1
!!$  !  DO n=1,DRESSED_HARMONICS				!!$  !  DO n=1,DRESSED_HARMONICS
!!$  !     DO m=1,MULTIMODE_HARMONICS				!!$  !     DO m=1,MULTIMODE_HARMONICS
!!$  !        U_nn(index1)%U  = MATMUL(TRANSPOSE(CONJG(U_n(n)	!!$  !        U_nn(index1)%U  = MATMUL(TRANSPOSE(CONJG(U_n(n)
!!$  !        !write(*,*) n,m,index1				!!$  !        !write(*,*) n,m,index1
!!$  !        index1 =  index1 + 1				!!$  !        index1 =  index1 + 1
!!$  !     END DO						!!$  !     END DO
!!$  !  END DO							!!$  !  END DO
!!$  !								!!$  !
!!$  !!17.01.17  expressions where the sums are over a single	!!$  !!17.01.17  expressions where the sums are over a single
!!$  !								!!$  !
!!$  !  DO index1 = 1,DRESSED_HARMONICS*MULTIMODE_HARMONICS	!!$  !  DO index1 = 1,DRESSED_HARMONICS*MULTIMODE_HARMONICS
!!$  !     U_nn2(index1)%U = ABS(U_nn(index1)%U)**2		!!$  !     U_nn2(index1)%U = ABS(U_nn(index1)%U)**2
!!$  !!    CALL WRITE_MATRIX(ABS(U_nn2(index1)%U))		!!$  !!    CALL WRITE_MATRIX(ABS(U_nn2(index1)%U))
!!$  !  END DO							!!$  !  END DO
!!$  !								!!$  !
!!$  !  P = 0.0							!!$  !  P = 0.0
!!$  !  DO index1 = 1,DRESSED_HARMONICS*MULTIMODE_HARMONICS	!!$  !  DO index1 = 1,DRESSED_HARMONICS*MULTIMODE_HARMONICS
!!$  !     DO index2 = 1,DRESSED_HARMONICS*MULTIMODE_HARMONIC	!!$  !     DO index2 = 1,DRESSED_HARMONICS*MULTIMODE_HARMONIC
!!$  !              P      = P+MATMUL(U_nn2(INDEX1)%U,TRANSPO	!!$  !              P      = P+MATMUL(U_nn2(INDEX1)%U,TRANSPO
!!$  ! !       CALL WRITE_MATRIX(REAL(P))			!!$  ! !       CALL WRITE_MATRIX(REAL(P))
!!$  !     END DO						!!$  !     END DO
!!$  !  END DO							!!$  !  END DO
!!$								!!$
!!$  !13.01.17  expressions where the sums are over a single 	!!$  !13.01.17  expressions where the sums are over a single 
!!$								!!$
!!$  !  DO index1 = 1,DRESSED_HARMONICS*MULTIMODE_HARMONICS	!!$  !  DO index1 = 1,DRESSED_HARMONICS*MULTIMODE_HARMONICS
!!$  !     U_nn2(index1)%U = MATMUL(U_nn(index1)%U,TRANSPOSE(	!!$  !     U_nn2(index1)%U = MATMUL(U_nn(index1)%U,TRANSPOSE(
!!$  !  END DO							!!$  !  END DO
!!$  !								!!$  !
!!$  !  P = 0.0							!!$  !  P = 0.0
!!$  !  aDO i=1,D_BARE						!!$  !  aDO i=1,D_BARE
!!$  !     DO j=1,D_BARE					!!$  !     DO j=1,D_BARE
!!$  !        DO index1 = 1,DRESSED_HARMONICS*MULTIMODE_HARMO	!!$  !        DO index1 = 1,DRESSED_HARMONICS*MULTIMODE_HARMO
!!$  !           DO index2 = 1,DRESSED_HARMONICS*MULTIMODE_HA	!!$  !           DO index2 = 1,DRESSED_HARMONICS*MULTIMODE_HA
!!$  !              P(i,j) = P(i,j) + U_nn2(index1)%U(j,j)*U_	!!$  !              P(i,j) = P(i,j) + U_nn2(index1)%U(j,j)*U_
!!$  !           END DO						!!$  !           END DO
!!$  !        END DO						!!$  !        END DO
!!$  !     END DO						!!$  !     END DO
!!$  !  END DO							!!$  !  END DO
!!$  !								!!$  !
!!$								!!$
!!$								!!$
!!$END SUBROUTINE MULTIMODETRANSITIONPROBABILITY_DRESSEDBASIS	!!$END SUBROUTINE MULTIMODETRANSITIONPROBABILITY_DRESSEDBASIS
!!$								!!$

diff -y ./src/quick-sort-index-table.f90 ../../Downloads/MultimodeFloquet-0.3/src/quick-sort-index-table.f90
!!$PROGRAM SORTING						!!$PROGRAM SORTING
!!$								!!$
!!$  INTEGER, PARAMETER :: N = 4				!!$  INTEGER, PARAMETER :: N = 4
!!$  DOUBLE PRECISION   :: V(N)					!!$  DOUBLE PRECISION   :: V(N)
!!$  INTEGER            :: INDEX_T(N)				!!$  INTEGER            :: INDEX_T(N)
!!$								!!$
!!$  DO I = 1,N							!!$  DO I = 1,N
!!$     INDEX_T(I) = I						!!$     INDEX_T(I) = I
!!$     V(I) = 1.0*ran()					!!$     V(I) = 1.0*ran()
!!$     write(*,*) V(i)						!!$     write(*,*) V(i)
!!$  END DO							!!$  END DO
!!$								!!$
!!$  								!!$  
!!$  CALL QUICK_SORT_I_T(v,INDEX_T,N)				!!$  CALL QUICK_SORT_I_T(v,INDEX_T,N)
!!$								!!$
!!$  write(*,*) 						!!$  write(*,*) 
!!$  DO I = 1,N							!!$  DO I = 1,N
!!$     write(*,*) V(i),INDEX_T(i),V(INDEX_T(i))		!!$     write(*,*) V(i),INDEX_T(i),V(INDEX_T(i))
!!$  END DO							!!$  END DO
!!$END PROGRAM							!!$END PROGRAM

SUBROUTINE QUICK_SORT_I_T(v,index_t,N)				SUBROUTINE QUICK_SORT_I_T(v,index_t,N)

  IMPLICIT NONE							  IMPLICIT NONE
  INTEGER, INTENT(IN) :: N					  INTEGER, INTENT(IN) :: N
  								  
  !INTEGER, DIMENSION(N),INTENT(INOUT) :: v			  !INTEGER, DIMENSION(N),INTENT(INOUT) :: v
  DOUBLE PRECISION, DIMENSION(N),INTENT(INOUT) :: v		  DOUBLE PRECISION, DIMENSION(N),INTENT(INOUT) :: v
  INTEGER, DIMENSION(N),INTENT(INOUT) :: index_t		  INTEGER, DIMENSION(N),INTENT(INOUT) :: index_t

  INTEGER, PARAMETER :: NN=2500, NSTACK=500			  INTEGER, PARAMETER :: NN=2500, NSTACK=500
  real :: a, cpu						  real :: a, cpu
  integer :: trial						  integer :: trial
  INTEGER :: k,i,j,jstack,l,r,istack(NSTACK),indice		  INTEGER :: k,i,j,jstack,l,r,istack(NSTACK),indice
  								  
  jstack=0							  jstack=0
  l=1								  l=1
  r=n								  r=n
  do								  do
     if (r-l < NN) then						     if (r-l < NN) then
        do j=l+1,r						        do j=l+1,r
           indice = index_t(j)					           indice = index_t(j)
           a=v(j)						           a=v(j)
           do i=j-1,l,-1					           do i=j-1,l,-1
              if (v(index_t(i)) <= a) exit			              if (v(index_t(i)) <= a) exit
              index_t(i+1) = index_t(i)				              index_t(i+1) = index_t(i)
           end do						           end do
           index_t(i+1) = indice				           index_t(i+1) = indice
        end do							        end do
        if (jstack == 0) exit					        if (jstack == 0) exit
        r=istack(jstack)					        r=istack(jstack)
        l=istack(jstack-1)					        l=istack(jstack-1)
        jstack=jstack-2						        jstack=jstack-2
     else							     else
        k=(l+r)/2						        k=(l+r)/2
        call swap(index_t(k),index_t(l+1))			        call swap(index_t(k),index_t(l+1))
        if (v(index_t(l)) > v(index_t(r))) call swap(index_t(	        if (v(index_t(l)) > v(index_t(r))) call swap(index_t(
        if (v(index_t(l+1))>v(index_t(r))) call swap(index_t(	        if (v(index_t(l+1))>v(index_t(r))) call swap(index_t(
        if (v(index_t(l))>v(index_t(l+1))) call swap(index_t(	        if (v(index_t(l))>v(index_t(l+1))) call swap(index_t(
        							        
        i=l+1							        i=l+1
        j=r							        j=r
        indice = index_t(l+1)					        indice = index_t(l+1)
        a=v(indice)						        a=v(indice)
        do							        do
           do							           do
              i=i+1						              i=i+1
              if (v(index_t(i)) >= a) exit			              if (v(index_t(i)) >= a) exit
           end do						           end do
           do							           do
              j=j-1						              j=j-1
              if (v(index_t(j)) <= a) exit			              if (v(index_t(j)) <= a) exit
           end do						           end do
           if (j < i) exit					           if (j < i) exit
           call swap(index_t(i),index_t(j))			           call swap(index_t(i),index_t(j))
        end do							        end do
        index_t(l+1)=index_t(j)					        index_t(l+1)=index_t(j)
        index_t(j)=indice					        index_t(j)=indice
        jstack=jstack+2						        jstack=jstack+2
        if (jstack > NSTACK) then				        if (jstack > NSTACK) then
           print *, "NSTACK too small", jstack			           print *, "NSTACK too small", jstack
        end if							        end if
        if (r-i+1 >= j-l) then					        if (r-i+1 >= j-l) then
           istack(jstack)=r					           istack(jstack)=r
           istack(jstack-1)=i					           istack(jstack-1)=i
           r=j-1						           r=j-1
        else							        else
           istack(jstack)=j-1					           istack(jstack)=j-1
           istack(jstack-1)=l					           istack(jstack-1)=l
           l=i							           l=i
        end if							        end if
     end if							     end if
  end do							  end do
  								  
END SUBROUTINE QUICK_SORT_I_T					END SUBROUTINE QUICK_SORT_I_T

SUBROUTINE QUICK_SORT_INTEGERS(v,index_t,N)			SUBROUTINE QUICK_SORT_INTEGERS(v,index_t,N)

  IMPLICIT NONE							  IMPLICIT NONE
  INTEGER, INTENT(IN) :: N					  INTEGER, INTENT(IN) :: N
  INTEGER, DIMENSION(N),INTENT(INOUT) :: v			  INTEGER, DIMENSION(N),INTENT(INOUT) :: v
  INTEGER, DIMENSION(N),INTENT(INOUT) :: index_t		  INTEGER, DIMENSION(N),INTENT(INOUT) :: index_t

  INTEGER, PARAMETER :: NN=10000, NSTACK=8000			  INTEGER, PARAMETER :: NN=10000, NSTACK=8000
  real :: a, cpu						  real :: a, cpu
  integer :: trial						  integer :: trial
  INTEGER :: k,i,j,jstack,l,r,istack(NSTACK),indice		  INTEGER :: k,i,j,jstack,l,r,istack(NSTACK),indice

  DO j=1,N							  DO j=1,N
     index_t(j) = j						     index_t(j) = j
  END DO							  END DO
  								  
  jstack=0							  jstack=0
  l=1								  l=1
  r=n								  r=n
  do								  do
     if (r-l < NN) then						     if (r-l < NN) then
        do j=l+1,r						        do j=l+1,r
           indice = index_t(j)					           indice = index_t(j)
           a=v(j)						           a=v(j)
           do i=j-1,l,-1					           do i=j-1,l,-1
              if (v(index_t(i)) <= a) exit			              if (v(index_t(i)) <= a) exit
              index_t(i+1) = index_t(i)				              index_t(i+1) = index_t(i)
           end do						           end do
           index_t(i+1) = indice				           index_t(i+1) = indice
        end do							        end do
        if (jstack == 0) exit					        if (jstack == 0) exit
        r=istack(jstack)					        r=istack(jstack)
        l=istack(jstack-1)					        l=istack(jstack-1)
        jstack=jstack-2						        jstack=jstack-2
     else							     else
        k=(l+r)/2						        k=(l+r)/2
        call swap(index_t(k),index_t(l+1))			        call swap(index_t(k),index_t(l+1))
        if (v(index_t(l)) > v(index_t(r))) call swap(index_t(	        if (v(index_t(l)) > v(index_t(r))) call swap(index_t(
        if (v(index_t(l+1))>v(index_t(r))) call swap(index_t(	        if (v(index_t(l+1))>v(index_t(r))) call swap(index_t(
        if (v(index_t(l))>v(index_t(l+1))) call swap(index_t(	        if (v(index_t(l))>v(index_t(l+1))) call swap(index_t(
        							        
        i=l+1							        i=l+1
        j=r							        j=r
        indice = index_t(l+1)					        indice = index_t(l+1)
        a=v(indice)						        a=v(indice)
        do							        do
           do							           do
              i=i+1						              i=i+1
              if (v(index_t(i)) >= a) exit			              if (v(index_t(i)) >= a) exit
           end do						           end do
           do							           do
              j=j-1						              j=j-1
              if (v(index_t(j)) <= a) exit			              if (v(index_t(j)) <= a) exit
           end do						           end do
           if (j < i) exit					           if (j < i) exit
           call swap(index_t(i),index_t(j))			           call swap(index_t(i),index_t(j))
        end do							        end do
        index_t(l+1)=index_t(j)					        index_t(l+1)=index_t(j)
        index_t(j)=indice					        index_t(j)=indice
        jstack=jstack+2						        jstack=jstack+2
        if (jstack > NSTACK) then				        if (jstack > NSTACK) then
           print *, "NSTACK too small", jstack			           print *, "NSTACK too small", jstack
        end if							        end if
        if (r-i+1 >= j-l) then					        if (r-i+1 >= j-l) then
           istack(jstack)=r					           istack(jstack)=r
           istack(jstack-1)=i					           istack(jstack-1)=i
           r=j-1						           r=j-1
        else							        else
           istack(jstack)=j-1					           istack(jstack)=j-1
           istack(jstack-1)=l					           istack(jstack-1)=l
           l=i							           l=i
        end if							        end if
     end if							     end if
  end do							  end do
  								  
END SUBROUTINE QUICK_SORT_INTEGERS				END SUBROUTINE QUICK_SORT_INTEGERS

subroutine swap(a,b)						subroutine swap(a,b)
  !real, intent(inout) :: a, b					  !real, intent(inout) :: a, b
  !real :: c							  !real :: c
  integer, intent(inout) :: a,b					  integer, intent(inout) :: a,b
  integer :: c							  integer :: c
  c = a; a = b; b = c						  c = a; a = b; b = c
end subroutine swap						end subroutine swap

diff -y ./src/Runge-Kutta4thorder.f90 ../../Downloads/MultimodeFloquet-0.3/src/Runge-Kutta4thorder.f90
! gfortran Runge-Kutta4thorder_sub.f90 zufall_sub.f		! gfortran Runge-Kutta4thorder_sub.f90 zufall_sub.f
! Do not forget to include:					! Do not forget to include:
!     USE RungeKuttaModule					!     USE RungeKuttaModule
! in the program using this subroutine				! in the program using this subroutine


MODULE ODE_RightHandSide					MODULE ODE_RightHandSide
  IMPLICIT NONE							  IMPLICIT NONE
CONTAINS							CONTAINS
  								  
  !FUNCTION  F(t,y, beta_ijkl,beta_ijkl_map) RESULT(K)		  !FUNCTION  F(t,y, beta_ijkl,beta_ijkl_map) RESULT(K)
  FUNCTION F(t,y) RESULT(K)					  FUNCTION F(t,y) RESULT(K)
    !USE interaction_interface					    !USE interaction_interface
    								    
    IMPLICIT NONE						    IMPLICIT NONE
    COMPLEX*16,       DIMENSION(:), INTENT(IN) :: y		    COMPLEX*16,       DIMENSION(:), INTENT(IN) :: y
    !DOUBLE PRECISION, DIMENSION(:), INTENT(IN) :: beta_ijkl	    !DOUBLE PRECISION, DIMENSION(:), INTENT(IN) :: beta_ijkl
    !DOUBLE PRECISION, DIMENSION(:), INTENT(IN) :: beta_ijkl_	    !DOUBLE PRECISION, DIMENSION(:), INTENT(IN) :: beta_ijkl_
    DOUBLE PRECISION,               INTENT(IN) ::  t		    DOUBLE PRECISION,               INTENT(IN) ::  t
    COMPLEX*16,       DIMENSION(SIZE(y))       :: K    		    COMPLEX*16,       DIMENSION(SIZE(y))       :: K    
    								    
    !K(1) =  y(2) 						    !K(1) =  y(2) 
    !K(2) = -y(1)!-0.25*y(2)  					    !K(2) = -y(1)!-0.25*y(2)  
    								    
    K(1) = -2.0*Y(2)!4.0-Y(1)*Y(1)-4*Y(2)*Y(2)			    K(1) = -2.0*Y(2)!4.0-Y(1)*Y(1)-4*Y(2)*Y(2)
    K(2) = 0.4 + Y(1) + 0.3*Y(1)*Y(1) - 0.6*Y(2)*Y(2)!Y(2)*Y(	    K(2) = 0.4 + Y(1) + 0.3*Y(1)*Y(1) - 0.6*Y(2)*Y(2)!Y(2)*Y(


    !K(1) = DCMPLX(0.0,-1.0)*(0.5*Y(3)+sqrt(2.0)*exp(-t*t/5.0	    !K(1) = DCMPLX(0.0,-1.0)*(0.5*Y(3)+sqrt(2.0)*exp(-t*t/5.0
    !K(2) = DCMPLX(0.0,-1.0)*(sqrt(2.0)*exp(-t*t/5.0)*cos(t)*	    !K(2) = DCMPLX(0.0,-1.0)*(sqrt(2.0)*exp(-t*t/5.0)*cos(t)*
    !K(3) = DCMPLX(0.0,-1.0)*(-Y(3)+sqrt(2.0)*exp(-t*t/5.0)*c	    !K(3) = DCMPLX(0.0,-1.0)*(-Y(3)+sqrt(2.0)*exp(-t*t/5.0)*c
    !CALL INTERACTIONTERM(SIZE(y), y, K, beta_ijkl,beta_ijkl_	    !CALL INTERACTIONTERM(SIZE(y), y, K, beta_ijkl,beta_ijkl_
    !WRITE(*,*) K(2)						    !WRITE(*,*) K(2)
    								    
  END FUNCTION F						  END FUNCTION F
  								  
END MODULE ODE_RightHandSide					END MODULE ODE_RightHandSide

MODULE RungeKuttaModule						MODULE RungeKuttaModule
  IMPLICIT NONE							  IMPLICIT NONE
  INTERFACE							  INTERFACE
     								     
     SUBROUTINE RKFOURTHORDER(y,t,dt)       			     SUBROUTINE RKFOURTHORDER(y,t,dt)       
       USE ODE_RightHandSide					       USE ODE_RightHandSide
       IMPLICIT NONE						       IMPLICIT NONE
       COMPLEX*16, DIMENSION(:), INTENT(IN) :: y		       COMPLEX*16, DIMENSION(:), INTENT(IN) :: y
       DOUBLE PRECISION, INTENT(INOUT)  :: t			       DOUBLE PRECISION, INTENT(INOUT)  :: t
       DOUBLE PRECISION, INTENT(IN) :: dt			       DOUBLE PRECISION, INTENT(IN) :: dt
       !DOUBLE PRECISION, DIMENSION(:),  INTENT(IN):: beta_ij	       !DOUBLE PRECISION, DIMENSION(:),  INTENT(IN):: beta_ij
       !DOUBLE PRECISION, DIMENSION(:), INTENT(IN) :: beta_ij	       !DOUBLE PRECISION, DIMENSION(:), INTENT(IN) :: beta_ij
     END SUBROUTINE RKFOURTHORDER				     END SUBROUTINE RKFOURTHORDER
     								     
  END INTERFACE							  END INTERFACE
  								  
END MODULE RungeKuttaModule					END MODULE RungeKuttaModule


PROGRAM RungeKuttaProgram					PROGRAM RungeKuttaProgram
  USE RungeKuttaModule						  USE RungeKuttaModule
  IMPLICIT NONE							  IMPLICIT NONE
  								  
  COMPLEX*16,       DIMENSION(:), ALLOCATABLE :: y		  COMPLEX*16,       DIMENSION(:), ALLOCATABLE :: y
  DOUBLE PRECISION, DIMENSION(:), ALLOCATABLE :: y_aux		  DOUBLE PRECISION, DIMENSION(:), ALLOCATABLE :: y_aux
  DOUBLE PRECISION                            :: t,dt,pi	  DOUBLE PRECISION                            :: t,dt,pi
  								  
  INTEGER dim,i, iterations,j, seed				  INTEGER dim,i, iterations,j, seed
  !double precision CYCLE					  !double precision CYCLE
  !data CYCLE/2.0E-8/						  !data CYCLE/2.0E-8/
  								  
  dim  = 2							  dim  = 2
  ALLOCATE(y(dim))						  ALLOCATE(y(dim))
  ALLOCATE(y_aux(dim))						  ALLOCATE(y_aux(dim))
  								  
  pi = 4.0*ATAN(1.0)						  pi = 4.0*ATAN(1.0)
  iterations  = 4096						  iterations  = 4096

  dt = 10.0*2.0*pi/iterations					  dt = 10.0*2.0*pi/iterations
  t  = 0.0  							  t  = 0.0  
  								  
  y(1) =  1.0/sqrt(2.0)						  y(1) =  1.0/sqrt(2.0)
  y(2) =  1.0/sqrt(2.0)						  y(2) =  1.0/sqrt(2.0)
  !y(3) =  1.0/sqrt(2.0)					  !y(3) =  1.0/sqrt(2.0)

  !y = y/dot_product(y,y)					  !y = y/dot_product(y,y)

  write(*,*) t,(real(y(i)),i=1,dim),(aimag(y(i)), i=1,dim)	  write(*,*) t,(real(y(i)),i=1,dim),(aimag(y(i)), i=1,dim)
  DO j=1,iterations						  DO j=1,iterations
     CALL RKFOURTHORDER(y,t,dt)					     CALL RKFOURTHORDER(y,t,dt)
     WRITE(*,*) t,(real(y(i)),i=1,dim),(aimag(y(i)), i=1,dim)	     WRITE(*,*) t,(real(y(i)),i=1,dim),(aimag(y(i)), i=1,dim)
  END DO							  END DO
  								  

END PROGRAM RungeKuttaProgram					END PROGRAM RungeKuttaProgram





SUBROUTINE RKFOURTHORDER(y,t,dt)				SUBROUTINE RKFOURTHORDER(y,t,dt)

  USE ODE_RightHandSide						  USE ODE_RightHandSide
  								  
  IMPLICIT NONE							  IMPLICIT NONE
  COMPLEX*16,       DIMENSION(:), INTENT(INOUT) :: y		  COMPLEX*16,       DIMENSION(:), INTENT(INOUT) :: y
  DOUBLE PRECISION,               INTENT(INOUT) :: t		  DOUBLE PRECISION,               INTENT(INOUT) :: t
  DOUBLE PRECISION,               INTENT(IN)    :: dt		  DOUBLE PRECISION,               INTENT(IN)    :: dt
  !DOUBLE PRECISION, DIMENSION(:), INTENT(IN)    :: beta_ijkl	  !DOUBLE PRECISION, DIMENSION(:), INTENT(IN)    :: beta_ijkl
  !DOUBLE PRECISION, DIMENSION(:), INTENT(IN)    :: beta_ijkl	  !DOUBLE PRECISION, DIMENSION(:), INTENT(IN)    :: beta_ijkl
  								  
  COMPLEX*16, DIMENSION(:), ALLOCATABLE :: K1,K2,K3,K4,y_aux	  COMPLEX*16, DIMENSION(:), ALLOCATABLE :: K1,K2,K3,K4,y_aux
  								  
  								  
  INTEGER i,dim							  INTEGER i,dim
  								  
  ALLOCATE(K1(SIZE(Y)))						  ALLOCATE(K1(SIZE(Y)))
  ALLOCATE(K2(SIZE(Y)))						  ALLOCATE(K2(SIZE(Y)))
  ALLOCATE(K3(SIZE(Y)))						  ALLOCATE(K3(SIZE(Y)))
  ALLOCATE(K4(SIZE(Y)))						  ALLOCATE(K4(SIZE(Y)))
  ALLOCATE(y_aux(SIZE(Y)))					  ALLOCATE(y_aux(SIZE(Y)))
  								  
  !write(*,*) "k1"						  !write(*,*) "k1"
  !K1 = f(t,y,beta_ijkl,beta_ijkl_map) 				  !K1 = f(t,y,beta_ijkl,beta_ijkl_map) 
  K1 = f(t,y)							  K1 = f(t,y)
  y_aux = y +K1*dt*0.5						  y_aux = y +K1*dt*0.5
  								  
  !write(*,*) "k2"						  !write(*,*) "k2"
  !K2 = f(t+0.5*dt,y_aux,beta_ijkl,beta_ijkl_map)		  !K2 = f(t+0.5*dt,y_aux,beta_ijkl,beta_ijkl_map)
  K2 = f(t+0.5*dt,y_aux)					  K2 = f(t+0.5*dt,y_aux)
  y_aux = y +K2*dt*0.5						  y_aux = y +K2*dt*0.5
  								  
  !write(*,*) "k3"						  !write(*,*) "k3"
  !K3 = f(t+0.5*dt,y_aux,beta_ijkl,beta_ijkl_map)		  !K3 = f(t+0.5*dt,y_aux,beta_ijkl,beta_ijkl_map)
  K3 = f(t+0.5*dt,y_aux)					  K3 = f(t+0.5*dt,y_aux)
  y_aux = y +K3*dt						  y_aux = y +K3*dt
  								  
  !write(*,*) "k4"						  !write(*,*) "k4"
  !K4 = f(t+dt,y_aux,beta_ijkl,beta_ijkl_map)			  !K4 = f(t+dt,y_aux,beta_ijkl,beta_ijkl_map)
  K4 = f(t+dt,y_aux)						  K4 = f(t+dt,y_aux)
  y = y + dt*(K1 + 2.0*K2 + 2.0*K3 + K4)/6.0			  y = y + dt*(K1 + 2.0*K2 + 2.0*K3 + K4)/6.0
  								  
  t = t + dt;							  t = t + dt;
  !write(*,*) t,dt  						  !write(*,*) t,dt  
END SUBROUTINE RKFOURTHORDER					END SUBROUTINE RKFOURTHORDER
  								  
diff -y ./src/sparse_utils.f90 ../../Downloads/MultimodeFloquet-0.3/src/sparse_utils.f90
MODULE SPARSE_INTERFACE						MODULE SPARSE_INTERFACE
  INTERFACE							  INTERFACE
     SUBROUTINE MULTIMODEFLOQUETMATRIX_SP(ATOM_,NM,NF,MODES_N	     SUBROUTINE MULTIMODEFLOQUETMATRIX_SP(ATOM_,NM,NF,MODES_N
       USE TYPES						       USE TYPES
       IMPLICIT NONE						       IMPLICIT NONE
       INTEGER                  ,INTENT(IN)    :: NM,NF		       INTEGER                  ,INTENT(IN)    :: NM,NF
       TYPE(MODE), DIMENSION(NF),INTENT(INOUT) :: FIELDs	       TYPE(MODE), DIMENSION(NF),INTENT(INOUT) :: FIELDs
       TYPE(ATOM),               INTENT(IN)    :: ATOM_		       TYPE(ATOM),               INTENT(IN)    :: ATOM_
       INTEGER, DIMENSION(NM),   INTENT(IN)    :: MODES_NUM	       INTEGER, DIMENSION(NM),   INTENT(IN)    :: MODES_NUM
       INTEGER,                  INTENT(INOUT) :: INFO		       INTEGER,                  INTENT(INOUT) :: INFO
       COMPLEX*16, DIMENSION(:), ALLOCATABLE,INTENT(OUT) :: V	       COMPLEX*16, DIMENSION(:), ALLOCATABLE,INTENT(OUT) :: V
       INTEGER,    DIMENSION(:), ALLOCATABLE,INTENT(OUT) :: C	       INTEGER,    DIMENSION(:), ALLOCATABLE,INTENT(OUT) :: C
       INTEGER,    DIMENSION(:), ALLOCATABLE,INTENT(OUT) :: R	       INTEGER,    DIMENSION(:), ALLOCATABLE,INTENT(OUT) :: R
     END SUBROUTINE MULTIMODEFLOQUETMATRIX_SP			     END SUBROUTINE MULTIMODEFLOQUETMATRIX_SP
  END INTERFACE							  END INTERFACE
END MODULE SPARSE_INTERFACE					END MODULE SPARSE_INTERFACE
diff -y ./src/TestingUnitarity.f90 ../../Downloads/MultimodeFloquet-0.3/src/TestingUnitarity.f90
SUBROUTINE TESTUNITARITY(N,U,DELTA,INFO)			SUBROUTINE TESTUNITARITY(N,U,DELTA,INFO)
  IMPLICIT NONE							  IMPLICIT NONE
  INTEGER, INTENT(IN) :: N					  INTEGER, INTENT(IN) :: N
  COMPLEX*16, DIMENSION(N,N), INTENT(IN) :: U_F			  COMPLEX*16, DIMENSION(N,N), INTENT(IN) :: U_F
  INTEGER, INTENT(INOUT) :: INFO				  INTEGER, INTENT(INOUT) :: INFO
  DOUBLE PRECISION, INTENT(OUT) :: DELTA			  DOUBLE PRECISION, INTENT(OUT) :: DELTA
  								  
  								  
  DOUBLE PRECISION, DIMENSION(N,N) :: P				  DOUBLE PRECISION, DIMENSION(N,N) :: P
  INTEGER i_							  INTEGER i_

  P = MATMUL(TRANSPOSE(CONJG(U_F)),U_F))			  P = MATMUL(TRANSPOSE(CONJG(U_F)),U_F))

  DELTA = 0.0							  DELTA = 0.0

  DO i_=1,N							  DO i_=1,N

     DELTA = DELTA  +  ABS(P(i_,i_) - 1.0)			     DELTA = DELTA  +  ABS(P(i_,i_) - 1.0)

  END DO							  END DO


  								  

END SUBROUTINE TESTUNITARITY					END SUBROUTINE TESTUNITARITY
diff -y ./src/util_c.f90 ../../Downloads/MultimodeFloquet-0.3/src/util_c.f90
SUBROUTINE REC_WRITE_MATRIX_C(A,A_dim1,A_dim2)			SUBROUTINE REC_WRITE_MATRIX_C(A,A_dim1,A_dim2)
  ! it writes a matrix of doubles nxm on the screen	      |	! it writes a matrix of doubles nxm on the screen
  USE SUBINTERFACE_LAPACK					  USE SUBINTERFACE_LAPACK
  INTEGER, INTENT(IN) :: A_dim1,A_dim2  			  INTEGER, INTENT(IN) :: A_dim1,A_dim2  
  DOUBLE PRECISION, DIMENSION(A_dim1*A_dim2),intent(in) :: A 	  DOUBLE PRECISION, DIMENSION(A_dim1*A_dim2),intent(in) :: A 
							      |	  
							      |	  
  INTEGER I,J							  INTEGER I,J
  DOUBLE PRECISION, DIMENSION(A_dim1,A_dim2) :: A_FORTRAN	  DOUBLE PRECISION, DIMENSION(A_dim1,A_dim2) :: A_FORTRAN
							      |	  
  write(*,*) 'fortan says: ',A_DIM				  write(*,*) 'fortan says: ',A_DIM
							      |	  
							      |	  
  DO I=1,A_DIM1							  DO I=1,A_DIM1
     DO J = 1,A_DIM2					      |	      DO J = 1,A_DIM2
        A_FORTRAN(I,J) = A(I+(J-1)*A_DIM1)		      |	          A_FORTRAN(I,J) = A(I+(J-1)*A_DIM1)
     END DO						      |	      END DO
  END DO						      |	  END DO    
							      |	  
							      |	  
  CALL WRITE_MATRIX(A_FORTRAN)  				  CALL WRITE_MATRIX(A_FORTRAN)  
							      |	  
END SUBROUTINE REC_WRITE_MATRIX_C				END SUBROUTINE REC_WRITE_MATRIX_C

SUBROUTINE WRITE_MATRIX_C(A,A_dim)				SUBROUTINE WRITE_MATRIX_C(A,A_dim)
  ! it writes a matrix of doubles nxm on the screen	      |	! it writes a matrix of doubles nxm on the screen
  USE SUBINTERFACE_LAPACK					  USE SUBINTERFACE_LAPACK
  INTEGER, INTENT(IN) :: A_dim  				  INTEGER, INTENT(IN) :: A_dim  
  DOUBLE PRECISION, DIMENSION(A_dim*A_dim),intent(in) :: A 	  DOUBLE PRECISION, DIMENSION(A_dim*A_dim),intent(in) :: A 
							      |	  
							      |	  
  INTEGER I,J							  INTEGER I,J
  DOUBLE PRECISION, DIMENSION(A_dim,A_dim) :: A_FORTRAN		  DOUBLE PRECISION, DIMENSION(A_dim,A_dim) :: A_FORTRAN
							      |	  
  !write(*,*) 'fortan says: ',A_DIM				  !write(*,*) 'fortan says: ',A_DIM
							      |	  
							      |	  
  DO I=1,A_DIM							  DO I=1,A_DIM
     DO J = 1,A_DIM					      |	      DO J = 1,A_DIM
        A_FORTRAN(I,J) = A(I+(J-1)*A_DIM)		      |	          A_FORTRAN(I,J) = A(I+(J-1)*A_DIM)
     END DO						      |	      END DO
  END DO						      |	  END DO    
							      |	  
							      |	  
  CALL WRITE_MATRIX(A_FORTRAN)  				  CALL WRITE_MATRIX(A_FORTRAN)  
							      |	  
END SUBROUTINE WRITE_MATRIX_C					END SUBROUTINE WRITE_MATRIX_C

SUBROUTINE WRITE_MATRIX_INT_C(A,A_dim)				SUBROUTINE WRITE_MATRIX_INT_C(A,A_dim)
  !it writes a matrix of integer nxm on the screen	      |	!it writes a matrix of integer nxm on the screen
  USE SUBINTERFACE_LAPACK					  USE SUBINTERFACE_LAPACK
  INTEGER, INTENT(IN) :: A_dim					  INTEGER, INTENT(IN) :: A_dim
  DOUBLE PRECISION, DIMENSION(A_dim),intent(in) :: A 		  DOUBLE PRECISION, DIMENSION(A_dim),intent(in) :: A 

  INTEGER I,J							  INTEGER I,J
  INTEGER, DIMENSION(A_dim,A_dim) :: A_FORTRAN			  INTEGER, DIMENSION(A_dim,A_dim) :: A_FORTRAN
							      |	  
							      |	  

  DO I=1,A_DIM							  DO I=1,A_DIM
     DO J = 1,A_DIM					      |	      DO J = 1,A_DIM
        A_FORTRAN(I,J) = A(I+(J-1)*A_DIM)		      |	          A_FORTRAN(I,J) = A(I+(J-1)*A_DIM)
     END DO						      |	      END DO
  END DO						      |	  END DO    

  CALL WRITE_MATRIX_INT(A_FORTRAN)  				  CALL WRITE_MATRIX_INT(A_FORTRAN)  
END SUBROUTINE WRITE_MATRIX_INT_C				END SUBROUTINE WRITE_MATRIX_INT_C


SUBROUTINE COORDINATEPACKING_C(D,A,V,R,C,index,INFO)		SUBROUTINE COORDINATEPACKING_C(D,A,V,R,C,index,INFO)
  IMPLICIT NONE							  IMPLICIT NONE
  INTEGER,INTENT(IN):: D					  INTEGER,INTENT(IN):: D
  COMPLEX*16,DIMENSION(D,D),INTENT(IN)  :: A			  COMPLEX*16,DIMENSION(D,D),INTENT(IN)  :: A
  COMPLEX*16,DIMENSION(D*D),INTENT(OUT) :: V			  COMPLEX*16,DIMENSION(D*D),INTENT(OUT) :: V
  INTEGER, DIMENSION(D*D),  INTENT(OUT) :: R,C			  INTEGER, DIMENSION(D*D),  INTENT(OUT) :: R,C
  INTEGER, INTENT(OUT)   :: index				  INTEGER, INTENT(OUT)   :: index
  INTEGER, INTENT(INOUT) :: INFO				  INTEGER, INTENT(INOUT) :: INFO
							      |	  
  CALL COORDINATEPACKING(D,A,V,R,C,index,INFO)			  CALL COORDINATEPACKING(D,A,V,R,C,index,INFO)
							      |	  
END SUBROUTINE COORDINATEPACKING_C				END SUBROUTINE COORDINATEPACKING_C

MODULE MERGINGARRAYS_C						MODULE MERGINGARRAYS_C
  INTERFACE							  INTERFACE
     SUBROUTINE APPENDARRAYS_C(V,B,INFO)			     SUBROUTINE APPENDARRAYS_C(V,B,INFO)
       COMPLEX*16, DIMENSION(:),ALLOCATABLE, INTENT(INOUT) ::	       COMPLEX*16, DIMENSION(:),ALLOCATABLE, INTENT(INOUT) ::
       COMPLEX*16, DIMENSION(:),INTENT(IN)    :: B		       COMPLEX*16, DIMENSION(:),INTENT(IN)    :: B
       INTEGER,                 INTENT(INOUT) :: INFO		       INTEGER,                 INTENT(INOUT) :: INFO
     END SUBROUTINE APPENDARRAYS_C				     END SUBROUTINE APPENDARRAYS_C
     SUBROUTINE APPENDARRAYSI_C(V,B,INFO)			     SUBROUTINE APPENDARRAYSI_C(V,B,INFO)
       INTEGER, DIMENSION(:),ALLOCATABLE, INTENT(INOUT) :: V	       INTEGER, DIMENSION(:),ALLOCATABLE, INTENT(INOUT) :: V
       INTEGER, DIMENSION(:),INTENT(IN)    :: B			       INTEGER, DIMENSION(:),INTENT(IN)    :: B
       INTEGER,                 INTENT(INOUT) :: INFO		       INTEGER,                 INTENT(INOUT) :: INFO
     END SUBROUTINE APPENDARRAYSI_C				     END SUBROUTINE APPENDARRAYSI_C
  END INTERFACE							  END INTERFACE
END MODULE MERGINGARRAYS_C					END MODULE MERGINGARRAYS_C

SUBROUTINE APPENDARRAYS_C(V,B,INFO)				SUBROUTINE APPENDARRAYS_C(V,B,INFO)
  COMPLEX*16, DIMENSION(:),ALLOCATABLE, INTENT(INOUT) :: V	  COMPLEX*16, DIMENSION(:),ALLOCATABLE, INTENT(INOUT) :: V
  COMPLEX*16, DIMENSION(:),INTENT(IN)    :: B			  COMPLEX*16, DIMENSION(:),INTENT(IN)    :: B
  INTEGER,                 INTENT(INOUT) :: INFO		  INTEGER,                 INTENT(INOUT) :: INFO
							      |	  
  CALL APPENDARRAYS(V,B,INFO)					  CALL APPENDARRAYS(V,B,INFO)
							      |	  
END SUBROUTINE APPENDARRAYS_C					END SUBROUTINE APPENDARRAYS_C

SUBROUTINE APPENDARRAYSI_C(V,B,INFO)				SUBROUTINE APPENDARRAYSI_C(V,B,INFO)
  INTEGER, DIMENSION(:),ALLOCATABLE, INTENT(INOUT) :: V		  INTEGER, DIMENSION(:),ALLOCATABLE, INTENT(INOUT) :: V
  INTEGER, DIMENSION(:),INTENT(IN)    :: B			  INTEGER, DIMENSION(:),INTENT(IN)    :: B
  INTEGER,                 INTENT(INOUT) :: INFO		  INTEGER,                 INTENT(INOUT) :: INFO
							      |	  
  COMPLEX*16,DIMENSION(:),ALLOCATABLE :: tmp_arr		  COMPLEX*16,DIMENSION(:),ALLOCATABLE :: tmp_arr
							      |	  
  CALL APPENDARRAYSI(V,B,INFO)					  CALL APPENDARRAYSI(V,B,INFO)
							      |	  
END SUBROUTINE APPENDARRAYSI_C					END SUBROUTINE APPENDARRAYSI_C

!SUBROUTINE MATMUL_C(OP_LENGHT,OP,A,RA,CA,B,RB,CB,C,INFO)     |	SUBROUTINE MATMUL_C(OP_LENGHT,OP,A,RA,CA,B,RB,CB,C,INFO)
SUBROUTINE MATMUL_C(OP,A,RA,CA,B,RB,CB,C,INFO)		      |	    
							      <
  IMPLICIT NONE							  IMPLICIT NONE
  !INTEGER, INTENT(IN):: RA,CA,RB,CB,OP_LENGHT		      |	  INTEGER, INTENT(IN):: RA,CA,RB,CB,OP_LENGHT
  !CHARACTER(OP_LENGHT), INTENT(IN) :: OP		      |	  CHARACTER(OP_LENGHT), INTENT(IN) :: OP
  INTEGER, INTENT(IN):: RA,CA,RB,CB,OP			      <
							      <
  COMPLEX*16, DIMENSION(RA,CA), INTENT(IN)::A			  COMPLEX*16, DIMENSION(RA,CA), INTENT(IN)::A
  COMPLEX*16, DIMENSION(RB,CB), INTENT(IN)::B			  COMPLEX*16, DIMENSION(RB,CB), INTENT(IN)::B
  COMPLEX*16, DIMENSION(RA,CB), INTENT(INOUT)::C		  COMPLEX*16, DIMENSION(RA,CB), INTENT(INOUT)::C
  INTEGER, INTENT(INOUT):: INFO					  INTEGER, INTENT(INOUT):: INFO
							      |	    
							      |	        SELECT CASE (OP)
  SELECT CASE (OP)					      |	            
							      |	        CASE("T")
     !CASE("T")						      |	            IF(RA.EQ.RB) THEN
  CASE(1)						      |	            C = MATMUL(TRANSPOSE(A),B)
     IF(RA.EQ.RB) THEN					      |	            ELSE
        C = MATMUL(TRANSPOSE(A),B)			      |	                C = 0.0
     ELSE						      |	                INFO = -1
        C = 0.0						      |	                WRITE(*,*) 'ERROR, INCONSISTENCY WITH THE DIM
        INFO = -1					      |	            END IF  
        WRITE(*,*) 'ERROR, INCONSISTENCY WITH THE DIMENSIONS  |	            
     END IF						      |	            
							      |	        CASE("TC")
							      |	            !WRITE(*,*) "TC"
  !CASE("TC")						      |	            IF(RA.EQ.RB) THEN
  CASE(2)						      |	            C = MATMUL(TRANSPOSE(CONJG(A)),B)
     							      |	            ELSE
     !WRITE(*,*) "TC"					      |	                C = 0.0
     IF(RA.EQ.RB) THEN					      |	                INFO = -1
        C = MATMUL(TRANSPOSE(CONJG(A)),B)		      |	                WRITE(*,*) 'ERROR, INCONSISTENCY WITH THE DIM
     ELSE						      |	            END IF  
        C = 0.0						      |	            
        INFO = -1					      |	        CASE("C")
        WRITE(*,*) 'ERROR, INCONSISTENCY WITH THE DIMENSIONS  |	            IF(CA.EQ.RB) THEN
     END IF						      |	                C = MATMUL(CONJG(A),B)
							      |	            ELSE
  !CASE("C")						      |	                C = 0.0
  CASE(3)						      |	                INFO = -1
							      |	                WRITE(*,*) 'ERROR, INCONSISTENCY WITH THE DIM
     IF(CA.EQ.RB) THEN					      |	            END IF  
        C = MATMUL(CONJG(A),B)				      |	                
     ELSE						      |	        CASE("N")
        C = 0.0						      |	            !WRITE(*,*) "N"
        INFO = -1					      |	            IF(CA.EQ.RB) THEN
        WRITE(*,*) 'ERROR, INCONSISTENCY WITH THE DIMENSIONS  |	                C = MATMUL(A,B)
     END IF						      |	            ELSE
							      |	                C = 0.0
  !CASE("N")						      |	                INFO = -1
  CASE(4)						      |	                WRITE(*,*) 'ERROR, INCONSISTENCY WITH THE DIM
							      |	            END IF  
     !WRITE(*,*) "N"					      |	            
     IF(CA.EQ.RB) THEN					      |	            CASE default
        C = MATMUL(A,B)					      |	             !               WRITE(*,*) "DEFAULT"
     ELSE						      |	            IF(CA.EQ.RB) THEN
        C = 0.0						      |	                C = MATMUL(A,B)
        INFO = -1					      |	            ELSE
        WRITE(*,*) 'ERROR, INCONSISTENCY WITH THE DIMENSIONS  |	                C = 0.0
     END IF						      |	                INFO = -1
							      |	                WRITE(*,*) 'ERROR, INCONSISTENCY WITH THE DIM
  CASE default						      |	            END IF  
     !               WRITE(*,*) "DEFAULT"		      |	        END SELECT
     IF(CA.EQ.RB) THEN					      |	    
        C = MATMUL(A,B)					      <
     ELSE						      <
        C = 0.0						      <
        INFO = -1					      <
        WRITE(*,*) 'ERROR, INCONSISTENCY WITH THE DIMENSIONS  <
     END IF						      <
  END SELECT						      <
							      <
END SUBROUTINE MATMUL_C						END SUBROUTINE MATMUL_C
diff -y ./src/util.f90 ../../Downloads/MultimodeFloquet-0.3/src/util.f90
SUBROUTINE WRITE_MATRIX(A)					SUBROUTINE WRITE_MATRIX(A)
! it writes a matrix of doubles nxm on the screen		! it writes a matrix of doubles nxm on the screen
  DOUBLE PRECISION, DIMENSION(:,:) :: A				  DOUBLE PRECISION, DIMENSION(:,:) :: A
  CHARACTER(LEN=105) STRING					  CHARACTER(LEN=105) STRING
  CHARACTER(LEN=105) aux_char					  CHARACTER(LEN=105) aux_char
  integer :: aux						  integer :: aux

  aux = int(UBOUND(A,2))					  aux = int(UBOUND(A,2))
  !write(*,*) aux						  !write(*,*) aux
  write(aux_char,"(I4)") aux					  write(aux_char,"(I4)") aux
  aux_char = trim(aux_char)					  aux_char = trim(aux_char)
  write(string,"(A1,I4,A6)") "(",aux,"E15.6)"			  write(string,"(A1,I4,A6)") "(",aux,"E15.6)"

  DO I = LBOUND(A,1), UBOUND(A,1)				  DO I = LBOUND(A,1), UBOUND(A,1)
     WRITE(*,string) (A(I,J), J = LBOUND(A,2), UBOUND(A,2))	     WRITE(*,string) (A(I,J), J = LBOUND(A,2), UBOUND(A,2))
  END DO							  END DO
  WRITE(*,*)							  WRITE(*,*)
  WRITE(*,*)							  WRITE(*,*)
END SUBROUTINE WRITE_MATRIX					END SUBROUTINE WRITE_MATRIX

SUBROUTINE WRITE_MATRIX_INT(A)					SUBROUTINE WRITE_MATRIX_INT(A)
!it writes a matrix of integer nxm on the screen		!it writes a matrix of integer nxm on the screen
  INTEGER, DIMENSION(:,:) :: A					  INTEGER, DIMENSION(:,:) :: A
  WRITE(*,*)							  WRITE(*,*)
  DO I = LBOUND(A,1), UBOUND(A,1)				  DO I = LBOUND(A,1), UBOUND(A,1)
     WRITE(*,*) (A(I,J), J = LBOUND(A,2), UBOUND(A,2))		     WRITE(*,*) (A(I,J), J = LBOUND(A,2), UBOUND(A,2))
  END DO							  END DO
END SUBROUTINE WRITE_MATRIX_INT					END SUBROUTINE WRITE_MATRIX_INT


SUBROUTINE COORDINATEPACKING(D,A,V,R,C,index,INFO)		SUBROUTINE COORDINATEPACKING(D,A,V,R,C,index,INFO)
  IMPLICIT NONE							  IMPLICIT NONE
  INTEGER,INTENT(IN):: D					  INTEGER,INTENT(IN):: D
  COMPLEX*16,DIMENSION(D,D),INTENT(IN)  :: A			  COMPLEX*16,DIMENSION(D,D),INTENT(IN)  :: A
  COMPLEX*16,DIMENSION(D*D),INTENT(OUT) :: V			  COMPLEX*16,DIMENSION(D*D),INTENT(OUT) :: V
  INTEGER, DIMENSION(D*D),  INTENT(OUT) :: R,C			  INTEGER, DIMENSION(D*D),  INTENT(OUT) :: R,C
  INTEGER, INTENT(OUT)   :: index				  INTEGER, INTENT(OUT)   :: index
  INTEGER, INTENT(INOUT) :: INFO				  INTEGER, INTENT(INOUT) :: INFO
  								  
  INTEGER I,J							  INTEGER I,J
  V=0								  V=0
  R=0								  R=0
  C=0								  C=0
  								  
  index = 1							  index = 1
  DO I=1,D							  DO I=1,D
     DO J=1,D							     DO J=1,D
        IF(ABS(A(I,J)).GT.0) THEN				        IF(ABS(A(I,J)).GT.0) THEN
           V(index) = A(I,J)					           V(index) = A(I,J)
           R(index) = I						           R(index) = I
           C(index) = J						           C(index) = J
           index = index+1					           index = index+1
        END IF							        END IF
     END DO							     END DO
  END DO							  END DO
  index = index-1						  index = index-1
END SUBROUTINE COORDINATEPACKING				END SUBROUTINE COORDINATEPACKING

MODULE MERGINGARRAYS						MODULE MERGINGARRAYS
  INTERFACE							  INTERFACE
     SUBROUTINE APPENDARRAYS(V,B,INFO)				     SUBROUTINE APPENDARRAYS(V,B,INFO)
       COMPLEX*16, DIMENSION(:),ALLOCATABLE, INTENT(INOUT) ::	       COMPLEX*16, DIMENSION(:),ALLOCATABLE, INTENT(INOUT) ::
       COMPLEX*16, DIMENSION(:),INTENT(IN)    :: B		       COMPLEX*16, DIMENSION(:),INTENT(IN)    :: B
       INTEGER,                 INTENT(INOUT) :: INFO		       INTEGER,                 INTENT(INOUT) :: INFO
     END SUBROUTINE APPENDARRAYS				     END SUBROUTINE APPENDARRAYS
     SUBROUTINE APPENDARRAYSI(V,B,INFO)				     SUBROUTINE APPENDARRAYSI(V,B,INFO)
       INTEGER, DIMENSION(:),ALLOCATABLE, INTENT(INOUT) :: V	       INTEGER, DIMENSION(:),ALLOCATABLE, INTENT(INOUT) :: V
       INTEGER, DIMENSION(:),INTENT(IN)    :: B			       INTEGER, DIMENSION(:),INTENT(IN)    :: B
       INTEGER,                 INTENT(INOUT) :: INFO		       INTEGER,                 INTENT(INOUT) :: INFO
     END SUBROUTINE APPENDARRAYSI				     END SUBROUTINE APPENDARRAYSI
  END INTERFACE							  END INTERFACE
END MODULE MERGINGARRAYS					END MODULE MERGINGARRAYS

SUBROUTINE APPENDARRAYS(V,B,INFO)				SUBROUTINE APPENDARRAYS(V,B,INFO)
  COMPLEX*16, DIMENSION(:),ALLOCATABLE, INTENT(INOUT) :: V	  COMPLEX*16, DIMENSION(:),ALLOCATABLE, INTENT(INOUT) :: V
  COMPLEX*16, DIMENSION(:),INTENT(IN)    :: B			  COMPLEX*16, DIMENSION(:),INTENT(IN)    :: B
  INTEGER,                 INTENT(INOUT) :: INFO		  INTEGER,                 INTENT(INOUT) :: INFO
  								  
  COMPLEX*16,DIMENSION(:),ALLOCATABLE :: tmp_arr		  COMPLEX*16,DIMENSION(:),ALLOCATABLE :: tmp_arr
!  write(*,*) V							!  write(*,*) V
!  write(*,*) B							!  write(*,*) B
  ALLOCATE(tmp_arr(SIZE(V,1)+SIZE(B,1)))			  ALLOCATE(tmp_arr(SIZE(V,1)+SIZE(B,1)))
  tmp_arr(1:SIZE(V,1))=V					  tmp_arr(1:SIZE(V,1))=V
  tmp_arr(SIZE(V,1)+1:SIZE(tmp_arr))=B				  tmp_arr(SIZE(V,1)+1:SIZE(tmp_arr))=B
  DEALLOCATE(V)							  DEALLOCATE(V)
  ALLOCATE(V(SIZE(tmp_arr)))					  ALLOCATE(V(SIZE(tmp_arr)))
  V=tmp_arr							  V=tmp_arr
END SUBROUTINE APPENDARRAYS					END SUBROUTINE APPENDARRAYS

SUBROUTINE APPENDARRAYSI(V,B,INFO)				SUBROUTINE APPENDARRAYSI(V,B,INFO)
  INTEGER, DIMENSION(:),ALLOCATABLE, INTENT(INOUT) :: V		  INTEGER, DIMENSION(:),ALLOCATABLE, INTENT(INOUT) :: V
  INTEGER, DIMENSION(:),INTENT(IN)    :: B			  INTEGER, DIMENSION(:),INTENT(IN)    :: B
  INTEGER,                 INTENT(INOUT) :: INFO		  INTEGER,                 INTENT(INOUT) :: INFO
  								  
  COMPLEX*16,DIMENSION(:),ALLOCATABLE :: tmp_arr		  COMPLEX*16,DIMENSION(:),ALLOCATABLE :: tmp_arr
  								  
  ALLOCATE(tmp_arr(SIZE(V,1)+SIZE(B,1)))			  ALLOCATE(tmp_arr(SIZE(V,1)+SIZE(B,1)))
  tmp_arr(1:SIZE(V,1))=V					  tmp_arr(1:SIZE(V,1))=V
  tmp_arr(SIZE(V,1)+1:SIZE(tmp_arr))=B				  tmp_arr(SIZE(V,1)+1:SIZE(tmp_arr))=B
  DEALLOCATE(V)							  DEALLOCATE(V)
  ALLOCATE(V(SIZE(tmp_arr)))					  ALLOCATE(V(SIZE(tmp_arr)))
  V=tmp_arr							  V=tmp_arr
END SUBROUTINE APPENDARRAYSI					END SUBROUTINE APPENDARRAYSI


diff -y ./src/VarCRSPacking.f90 ../../Downloads/MultimodeFloquet-0.3/src/VarCRSPacking.f90
!!$PROGRAM CRCPACKINGTEST					!!$PROGRAM CRCPACKINGTEST
!!$								!!$
!!$  INTEGER                       :: N,DIM			!!$  INTEGER                       :: N,DIM
!!$  INTEGER                       :: INFO			!!$  INTEGER                       :: INFO
!!$  CHARACTER                     :: UPLO			!!$  CHARACTER                     :: UPLO
!!$  COMPLEX*16,DIMENSION(5,5)     :: A				!!$  COMPLEX*16,DIMENSION(5,5)     :: A
!!$								!!$
!!$  COMPLEX*16, DIMENSION(13) :: VALUES			!!$  COMPLEX*16, DIMENSION(13) :: VALUES
!!$  INTEGER,    DIMENSION(13) :: COLUMNS			!!$  INTEGER,    DIMENSION(13) :: COLUMNS
!!$  INTEGER,    DIMENSION(6) :: ROWINDEX			!!$  INTEGER,    DIMENSION(6) :: ROWINDEX
!!$								!!$
!!$  N    = SIZE(A,1)						!!$  N    = SIZE(A,1)
!!$  DIM  =  SIZE(VALUES)					!!$  DIM  =  SIZE(VALUES)
!!$  UPLO = "L"							!!$  UPLO = "L"
!!$  A = 0							!!$  A = 0
!!$  A(1,:) = (/ 1,-1, 0,-3, 0/)				!!$  A(1,:) = (/ 1,-1, 0,-3, 0/)
!!$  A(2,:) = (/-2, 5, 0, 0, 0/)				!!$  A(2,:) = (/-2, 5, 0, 0, 0/)
!!$  A(3,:) = (/ 0, 0, 4, 6, 4/)				!!$  A(3,:) = (/ 0, 0, 4, 6, 4/)
!!$  A(4,:) = (/-4, 0, 2, 0, 0/)				!!$  A(4,:) = (/-4, 0, 2, 0, 0/)
!!$  A(5,:) = (/ 0, 8, 0, 0,-5/)				!!$  A(5,:) = (/ 0, 8, 0, 0,-5/)
!!$								!!$
!!$  VALUES   = 0 						!!$  VALUES   = 0 
!!$  COLUMNS  = 0						!!$  COLUMNS  = 0
!!$  ROWINDEX = 0						!!$  ROWINDEX = 0
!!$  INFO     = 0						!!$  INFO     = 0
!!$								!!$
!!$  CALL VARCRCPACKING(N,DIM,UPLO,A,VALUES,COLUMNS,ROWINDEX,	!!$  CALL VARCRCPACKING(N,DIM,UPLO,A,VALUES,COLUMNS,ROWINDEX,
!!$  CALL WRITE_MATRIX(N,N, REAL(A))				!!$  CALL WRITE_MATRIX(N,N, REAL(A))
!!$  !WRITE(*,*) VALUES						!!$  !WRITE(*,*) VALUES
!!$  CALL WRITE_MATRIX(1,DIM,REAL(VALUES))			!!$  CALL WRITE_MATRIX(1,DIM,REAL(VALUES))
!!$  CALL WRITE_MATRIX_INT(1,DIM,COLUMNS)			!!$  CALL WRITE_MATRIX_INT(1,DIM,COLUMNS)
!!$  CALL WRITE_MATRIX_INT(1,N+1,ROWINDEX)			!!$  CALL WRITE_MATRIX_INT(1,N+1,ROWINDEX)
!!$								!!$
!!$END PROGRAM CRCPACKINGTEST					!!$END PROGRAM CRCPACKINGTEST


!!$SUBROUTINE WRITE_MATRIX(N1,N2,A)				!!$SUBROUTINE WRITE_MATRIX(N1,N2,A)
!!$  DOUBLE PRECISION, DIMENSION(N1,N2) :: A			!!$  DOUBLE PRECISION, DIMENSION(N1,N2) :: A
!!$  CHARACTER(LEN=55) STRING					!!$  CHARACTER(LEN=55) STRING
!!$  CHARACTER(LEN=55) aux_char					!!$  CHARACTER(LEN=55) aux_char
!!$  integer :: aux						!!$  integer :: aux
!!$								!!$
!!$  aux = int(UBOUND(A,2))					!!$  aux = int(UBOUND(A,2))
!!$  write(aux_char,"(I4)") aux					!!$  write(aux_char,"(I4)") aux
!!$  aux_char = trim(aux_char)					!!$  aux_char = trim(aux_char)
!!$  write(string,"(A1,I4,A6)") "(",aux,"E15.6)"		!!$  write(string,"(A1,I4,A6)") "(",aux,"E15.6)"
!!$  !!string = trim(string)					!!$  !!string = trim(string)
!!$  !WRITE(*,*) string, aux,LBOUND(A,1),UBOUND(A,1),LBOUND(A	!!$  !WRITE(*,*) string, aux,LBOUND(A,1),UBOUND(A,1),LBOUND(A
!!$								!!$
!!$  DO I = LBOUND(A,1), UBOUND(A,1)				!!$  DO I = LBOUND(A,1), UBOUND(A,1)
!!$     WRITE(*,string) (A(I,J), J = LBOUND(A,2), UBOUND(A,2)	!!$     WRITE(*,string) (A(I,J), J = LBOUND(A,2), UBOUND(A,2)
!!$  END DO							!!$  END DO
!!$  WRITE(*,*)							!!$  WRITE(*,*)
!!$!  WRITE(*,*)						!!$!  WRITE(*,*)
!!$  !101 format(string)					!!$  !101 format(string)
!!$END SUBROUTINE WRITE_MATRIX					!!$END SUBROUTINE WRITE_MATRIX
!!$								!!$
!!$								!!$
!!$SUBROUTINE WRITE_MATRIX_INT(N1,N2,A)				!!$SUBROUTINE WRITE_MATRIX_INT(N1,N2,A)
!!$  INTEGER, DIMENSION(N1,N2) :: A				!!$  INTEGER, DIMENSION(N1,N2) :: A
!!$  WRITE(*,*)							!!$  WRITE(*,*)
!!$  DO I = LBOUND(A,1), UBOUND(A,1)				!!$  DO I = LBOUND(A,1), UBOUND(A,1)
!!$     WRITE(*,*) (A(I,J), J = LBOUND(A,2), UBOUND(A,2))	!!$     WRITE(*,*) (A(I,J), J = LBOUND(A,2), UBOUND(A,2))
!!$  END DO							!!$  END DO
!!$END SUBROUTINE WRITE_MATRIX_INT				!!$END SUBROUTINE WRITE_MATRIX_INT
!!$								!!$

SUBROUTINE VARCRCPACKING(N,DIM,UPLO,zero,A,VALUES,COLUMNS,ROW	SUBROUTINE VARCRCPACKING(N,DIM,UPLO,zero,A,VALUES,COLUMNS,ROW

  INTEGER,                   INTENT(IN)    :: N			  INTEGER,                   INTENT(IN)    :: N
  INTEGER,                   INTENT(INOUT) :: INFO,DIM		  INTEGER,                   INTENT(INOUT) :: INFO,DIM
  CHARACTER,                 INTENT(IN)    :: UPLO		  CHARACTER,                 INTENT(IN)    :: UPLO
  DOUBLE PRECISION,          INTENT(IN)    :: ZERO		  DOUBLE PRECISION,          INTENT(IN)    :: ZERO
  COMPLEX*16,DIMENSION(N,N), INTENT(IN)    :: A			  COMPLEX*16,DIMENSION(N,N), INTENT(IN)    :: A

  COMPLEX*16, DIMENSION(DIM), INTENT(OUT) :: VALUES		  COMPLEX*16, DIMENSION(DIM), INTENT(OUT) :: VALUES
  INTEGER,    DIMENSION(DIM), INTENT(OUT) :: COLUMNS		  INTEGER,    DIMENSION(DIM), INTENT(OUT) :: COLUMNS
  INTEGER,    DIMENSION(N+1), INTENT(OUT) :: ROWINDEX		  INTEGER,    DIMENSION(N+1), INTENT(OUT) :: ROWINDEX

  INTEGER I,J, counter						  INTEGER I,J, counter


  VALUES   = 0							  VALUES   = 0
  counter  =  1							  counter  =  1
  columns  = -1							  columns  = -1
  ROWINDEX = -1							  ROWINDEX = -1

  SELECT CASE (UPLO)						  SELECT CASE (UPLO)
     								     
  CASE('F')							  CASE('F')
     DO I=1,N							     DO I=1,N
        DO J=1,N						        DO J=1,N
           IF(ABS(A(I,J)).GT.ZERO .OR. I.EQ.J ) THEN		           IF(ABS(A(I,J)).GT.ZERO .OR. I.EQ.J ) THEN
              VALUES(counter)  = A(I,J)				              VALUES(counter)  = A(I,J)
              COLUMNS(counter) = J				              COLUMNS(counter) = J
              IF(ROWINDEX(I).EQ.-1) ROWINDEX(I) = counter	              IF(ROWINDEX(I).EQ.-1) ROWINDEX(I) = counter
              counter = counter + 1				              counter = counter + 1
           END IF						           END IF
        END DO							        END DO
        IF(I.EQ.N-1) aux = COUNTER   				        IF(I.EQ.N-1) aux = COUNTER   
     END DO							     END DO
     AUX = COUNTER - 1 - AUX					     AUX = COUNTER - 1 - AUX
     ROWINDEX(N+1) = aux + ROWINDEX(N) + 1			     ROWINDEX(N+1) = aux + ROWINDEX(N) + 1
     								     

  CASE ('U')							  CASE ('U')
     DO I=1,N							     DO I=1,N
        DO J=I,N						        DO J=I,N
           IF(ABS(A(I,J)).GT.ZERO .OR. I.EQ.J) THEN		           IF(ABS(A(I,J)).GT.ZERO .OR. I.EQ.J) THEN
              VALUES(counter)  = A(I,J)				              VALUES(counter)  = A(I,J)
              COLUMNS(counter) = J				              COLUMNS(counter) = J
              IF(ROWINDEX(I).EQ.-1) ROWINDEX(I) = counter	              IF(ROWINDEX(I).EQ.-1) ROWINDEX(I) = counter
              counter = counter + 1				              counter = counter + 1
           END IF						           END IF
        END DO							        END DO
        IF(I.EQ.N-1) aux =COUNTER   				        IF(I.EQ.N-1) aux =COUNTER   
     END DO							     END DO
     AUX = COUNTER - 1 - AUX					     AUX = COUNTER - 1 - AUX

     ROWINDEX(N+1) = aux + ROWINDEX(N) + 1			     ROWINDEX(N+1) = aux + ROWINDEX(N) + 1
     								     
  CASE('L')							  CASE('L')
     DO I=1,N							     DO I=1,N
        DO J=1,I						        DO J=1,I
           IF(ABS(A(I,J)).GT.ZERO  .OR. I.EQ.J) THEN		           IF(ABS(A(I,J)).GT.ZERO  .OR. I.EQ.J) THEN
              VALUES(counter)  = A(I,J)				              VALUES(counter)  = A(I,J)
              COLUMNS(counter) = J				              COLUMNS(counter) = J
              IF(ROWINDEX(I).EQ.-1) ROWINDEX(I) = counter	              IF(ROWINDEX(I).EQ.-1) ROWINDEX(I) = counter
              counter = counter + 1				              counter = counter + 1
           END IF						           END IF
        END DO							        END DO
        IF(I.EQ.N-1) aux = COUNTER   				        IF(I.EQ.N-1) aux = COUNTER   
     END DO							     END DO
     AUX = COUNTER - 1 - AUX					     AUX = COUNTER - 1 - AUX

     ROWINDEX(N+1) = aux + ROWINDEX(N) + 1			     ROWINDEX(N+1) = aux + ROWINDEX(N) + 1
     								     
  END SELECT							  END SELECT

  DIM = counter - 1						  DIM = counter - 1

 								 
END SUBROUTINE VARCRCPACKING					END SUBROUTINE VARCRCPACKING


